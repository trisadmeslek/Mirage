<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Remote Actions </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Remote Actions ">
    <meta name="generator" content="docfx 2.56.6.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="../../toc.html">
    
    <meta property="docfx:rel" content="../../../">
    
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="remote-actions">Remote Actions</h1>

<p>The network system has ways to perform actions across the network. These type of actions are sometimes called Remote Procedure Calls. There are two types of RPCs in the network system, ServerRpc - which are called from the client and run on the server; and ClientRpc calls - which are called on the server and run on clients.</p>
<p>The diagram below shows the directions that remote actions take:</p>
<p><img src="UNetDirections.jpg" alt="Data Flow Graph"></p>
<h2 id="server-rpc-calls">Server RPC Calls</h2>
<p>Server RPC Calls are sent from player objects on the client to player objects on the server. For security, Server RPC Calls can only be sent from YOUR player object by default, so you cannot control the objects of other players.  You can bypass the authority check using <code>[ServerRpc(requireAuthority = false)]</code>.</p>
<p>To make a function into a Server RPC Calls, add the [ServerRpc] custom attribute to it. This function will now be run on the server when it is called on the client. Any parameters of <a href="../DataTypes.html">allowed data type</a> will be automatically passed to the server with the Server RPC Call.</p>
<p>Server RPC Calls functions cannot be static.</p>
<pre><code class="lang-cs">public class Player : NetworkBehaviour
{
    void Update()
    {
        if (!isLocalPlayer) return;

        if (Input.GetKey(KeyCode.X))
            DropCube();
    }

    // assigned in inspector
    public GameObject cubePrefab;

    [ServerRpc]
    void DropCube()
    {
        if (cubePrefab != null)
        {
            Vector3 spawnPos = transform.position + transform.forward * 2;
            Quaternion spawnRot = transform.rotation;
            GameObject cube = Instantiate(cubePrefab, spawnPos, spawnRot);
            NetworkServer.Spawn(cube);
        }
    }
}
</code></pre>
<p>Be careful of sending ServerRpcs from the client every frame! This can cause a lot of network traffic.</p>
<h3 id="returning-values">Returning values</h3>
<p>ServerRpcs can return values.  It can take a long time for the server to reply, so they must return a UniTask which the client can await.
To return a value,  add a return value using <code>UniTask&lt;MyReturnType&gt;</code> where <code>MyReturnType</code> is any <a href="../DataTypes.html">supported Mirage type</a>.  In the server you can make your method async,  or you can use <code>UniTask.FromResult(myresult);</code>.  For example:</p>
<pre><code class="lang-cs">public class Shop: NetworkBehavior {

    [ServerRpc]
    public UniTask&lt;int&gt; GetPrice(string item) 
    {
        switch (item) 
        {
             case &quot;turnip&quot;:
                 return UniTask.FromResult(10);
             case &quot;apple&quot;:
                return UniTask.FromResult(3);
             default:
                return UniTask.FromResult(int.MaxValue);
        }
    }

    [Client]
    public async UniTaskVoid DisplayTurnipPrice() 
    {
        // call the RPC and wait for the response without blocking the main thread
        int price = await GetPrice(&quot;turnip&quot;);
        Debug.Log($&quot;Turnips price {price}&quot;);
    }
}
</code></pre>
<h3 id="serverrpc-and-authority">ServerRpc and Authority</h3>
<p>It is possible to invoke ServerRpcs on non-player objects if any of the following are true:</p>
<ul>
<li>The object was spawned with client authority</li>
<li>The object has client authority set with <code>NetworkIdentity.AssignClientAuthority</code></li>
<li>the Server RPC Call has the <code>requireAuthority</code> option set false.
<ul>
<li>You can include an optional <code>NetworkConnectionToClient sender = null</code> parameter in the Server RPC Call method signature and Mirage will fill in the sending client for you.</li>
<li>Do not try to set a value for this optional parameter...it will be ignored.</li>
</ul>
</li>
</ul>
<p>Server RPC Calls sent from these object are run on the server instance of the object, not on the associated player object for the client.</p>
<pre><code class="lang-cs">public enum DoorState : byte
{
    Open, Closed
}

public class Door : NetworkBehaviour
{
    [SyncVar]
    public DoorState doorState;

    [ServerRpc(requireAuthority = false)]
    public void CmdSetDoorState(DoorState newDoorState, NetworkConnectionToClient sender = null)
    {
        if (sender.identity.GetComponent&lt;Player&gt;().hasDoorKey)
            doorState = newDoorState;
    }
}
</code></pre>
<h2 id="clientrpc-calls">ClientRpc Calls</h2>
<p>ClientRpc calls are sent from objects on the server to objects on clients. They can be sent from any server object with a NetworkIdentity that has been spawned. Since the server has authority, then there no security issues with server objects being able to send these calls. To make a function into a ClientRpc call, add the [ClientRpc] custom attribute to it. This function will now be run on clients when it is called on the server. Any parameters of <a href="../DataTypes.html">allowed data type</a> will automatically be passed to the clients with the ClientRpc call..</p>
<p>ClientRpc functions cannot be static.  They must return <code>void</code></p>
<p>ClientRpc messages are only sent to observers of an object according to its <a href="../Visibility.html">Network Visibility</a>. Player objects are always obeservers of themselves. In some cases, you may want to exclude the owner client when calling a ClientRpc.  This is done with the <code>excludeOwner</code> option: <code>[ClientRpc(excludeOwner = true)]</code>.</p>
<pre><code class="lang-cs">public class Player : NetworkBehaviour
{
    int health;

    public void TakeDamage(int amount)
    {
        if (!isServer) return;

        health -= amount;
        Damage(amount);
    }

    [ClientRpc]
    void Damage(int amount)
    {
        Debug.Log(&quot;Took damage:&quot; + amount);
    }
}
</code></pre>
<p>When running a game as a host with a local client, ClientRpc calls will be invoked on the local client even though it is in the same process as the server. So the behaviours of local and remote clients are the same for ClientRpc calls.</p>
<p>You can also specify which client gets the call with the <code>target</code> parameter.</p>
<p>If you only want the client that owns the object to be called,  use <code>[ClientRpc(target = Client.Owner)]</code> or you can specify which client gets the message by using <code>[ClientRpc(target = Client.Connection)]</code> and passing the connection as a parameter.  For example:</p>
<pre><code class="lang-cs">public class Player : NetworkBehaviour
{
    int health;

    [Server]
    void Magic(GameObject target, int damage)
    {
        target.GetComponent&lt;Player&gt;().health -= damage;

        NetworkIdentity opponentIdentity = target.GetComponent&lt;NetworkIdentity&gt;();
        DoMagic(opponentIdentity.connectionToClient, damage);
    }

    [ClientRpc(target = Client.Connection)]
    public void DoMagic(NetworkConnection target, int damage)
    {
        // This will appear on the opponent's client, not the attacking player's
        Debug.Log($&quot;Magic Damage = {damage}&quot;);
    }

    [Server]
    void HealMe()
    {
        health += 10;
        Healed(10);
    }

    [ClientRpc(target = Client.Owner)]
    public void Healed(int amount)
    {
        // No NetworkConnection parameter, so it goes to owner
        Debug.Log($&quot;Health increased by {amount}&quot;);
    }
}
</code></pre>
<h2 id="arguments-to-remote-actions">Arguments to Remote Actions</h2>
<p>The arguments passed to ServerRpc and ClientRpc calls are serialized and sent over the network. You can use any <a href="../DataTypes.html">supported Mirage type</a>.</p>
<p>Arguments to remote actions cannot be sub-components of game objects, such as script instances or Transforms.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
