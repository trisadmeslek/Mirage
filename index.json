{
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "api/Mirage.AddPlayerMessage.html": {
    "href": "api/Mirage.AddPlayerMessage.html",
    "title": "Struct AddPlayerMessage",
    "keywords": "Struct AddPlayerMessage Namespace : Mirage Assembly : doc.dll Syntax public struct AddPlayerMessage"
  },
  "api/Mirage.Channel.html": {
    "href": "api/Mirage.Channel.html",
    "title": "Class Channel",
    "keywords": "Class Channel Inheritance Object Channel Namespace : Mirage Assembly : doc.dll Syntax public static class Channel : object Fields | Improve this Doc View Source Reliable Declaration public const int Reliable = null Field Value Type Description Int32 | Improve this Doc View Source Unreliable Declaration public const int Unreliable = null Field Value Type Description Int32"
  },
  "api/Mirage.Client.html": {
    "href": "api/Mirage.Client.html",
    "title": "Enum Client",
    "keywords": "Enum Client Namespace : Mirage Assembly : doc.dll Syntax public enum Client : int Fields Name Description Connection Observers Owner"
  },
  "api/Mirage.ClientAttribute.html": {
    "href": "api/Mirage.ClientAttribute.html",
    "title": "Class ClientAttribute",
    "keywords": "Class ClientAttribute Prevents the server from running this method. Inheritance Object ClientAttribute Namespace : Mirage Assembly : doc.dll Syntax public class ClientAttribute : Attribute Fields | Improve this Doc View Source error If true, when the method is called from a client, it throws an error If false, no error is thrown, but the method won't execute useful for unity built in methods such as Await, Update, Start, etc. Declaration public bool error Field Value Type Description Boolean"
  },
  "api/Mirage.ClientObjectManager.html": {
    "href": "api/Mirage.ClientObjectManager.html",
    "title": "Class ClientObjectManager",
    "keywords": "Class ClientObjectManager Inheritance Object ClientObjectManager Implements IClientObjectManager IObjectLocator Namespace : Mirage Assembly : doc.dll Syntax public class ClientObjectManager : MonoBehaviour, IClientObjectManager, IObjectLocator Fields | Improve this Doc View Source Client Declaration public NetworkClient Client Field Value Type Description NetworkClient | Improve this Doc View Source NetworkSceneManager Declaration public NetworkSceneManager NetworkSceneManager Field Value Type Description NetworkSceneManager | Improve this Doc View Source spawnableObjects This is dictionary of the disabled NetworkIdentity objects in the scene that could be spawned by messages from the server. The key to the dictionary is the NetworkIdentity sceneId. Declaration public readonly Dictionary<ulong, NetworkIdentity> spawnableObjects Field Value Type Description Dictionary < UInt64 , NetworkIdentity > | Improve this Doc View Source spawnPrefabs Declaration public List<NetworkIdentity> spawnPrefabs Field Value Type Description List < NetworkIdentity > Properties | Improve this Doc View Source Item[UInt32] Declaration public NetworkIdentity this[uint netId] { get; } Parameters Type Name Description UInt32 netId Property Value Type Description NetworkIdentity | Improve this Doc View Source LocalPlayer NetworkIdentity of the localPlayer Declaration public NetworkIdentity LocalPlayer { get; } Property Value Type Description NetworkIdentity | Improve this Doc View Source Spawned Declaration public SpawnEvent Spawned { get; } Property Value Type Description SpawnEvent | Improve this Doc View Source SpawnedObjects List of all objects spawned in this client Declaration public Dictionary<uint, NetworkIdentity> SpawnedObjects { get; } Property Value Type Description Dictionary < UInt32 , NetworkIdentity > | Improve this Doc View Source UnSpawned Declaration public SpawnEvent UnSpawned { get; } Property Value Type Description SpawnEvent Methods | Improve this Doc View Source ClearSpawners() This clears the registered spawn prefabs and spawn handler functions for this client. Declaration public void ClearSpawners() | Improve this Doc View Source DestroyAllClientObjects() Destroys all networked objects on the client. This can be used to clean up when a network connection is closed. Declaration public void DestroyAllClientObjects() | Improve this Doc View Source GetPrefab(Guid) Find the registered prefab for this asset id. Useful for debuggers Declaration public NetworkIdentity GetPrefab(Guid assetId) Parameters Type Name Description Guid assetId asset id of the prefab Returns Type Description NetworkIdentity true if prefab was registered | Improve this Doc View Source PrepareToSpawnSceneObjects() Call this after loading/unloading a scene in the client after connection to register the spawnable objects Declaration public void PrepareToSpawnSceneObjects() | Improve this Doc View Source RegisterPrefab(NetworkIdentity) Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instantiate a corresponding client object with the same netId. The ClientObjectManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of NetworkAssetIds and prefab references. Declaration public void RegisterPrefab(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity A Prefab that will be spawned. | Improve this Doc View Source RegisterPrefab(NetworkIdentity, Guid) Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instantiate a corresponding client object with the same netId. The ClientObjectManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of NetworkAssetIds and prefab references. Declaration public void RegisterPrefab(NetworkIdentity identity, Guid newAssetId) Parameters Type Name Description NetworkIdentity identity A Prefab that will be spawned. Guid newAssetId An assetId to be assigned to this prefab. This allows a dynamically created game object to be registered for an already known asset Id. | Improve this Doc View Source RegisterPrefab(NetworkIdentity, SpawnHandlerDelegate, UnSpawnDelegate) Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instantiate a corresponding client object with the same netId. The ClientObjectManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of NetworkAssetIds and prefab references. Declaration public void RegisterPrefab(NetworkIdentity identity, SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description NetworkIdentity identity A Prefab that will be spawned. SpawnHandlerDelegate spawnHandler A method to use as a custom spawnhandler on clients. UnSpawnDelegate unspawnHandler A method to use as a custom un-spawnhandler on clients. | Improve this Doc View Source RegisterSpawnHandler(Guid, SpawnHandlerDelegate, UnSpawnDelegate) This is an advanced spawning function that registers a custom assetId with the UNET spawning system. This can be used to register custom spawning methods for an assetId - instead of the usual method of registering spawning methods for a prefab. This should be used when no prefab exists for the spawned objects - such as when they are constructed dynamically at runtime from configuration data. Declaration public void RegisterSpawnHandler(Guid assetId, SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description Guid assetId Custom assetId string. SpawnHandlerDelegate spawnHandler A method to use as a custom spawnhandler on clients. UnSpawnDelegate unspawnHandler A method to use as a custom un-spawnhandler on clients. | Improve this Doc View Source Start() Declaration public void Start() | Improve this Doc View Source UnregisterPrefab(NetworkIdentity) Removes a registered spawn prefab that was setup with ClientScene.RegisterPrefab. Declaration public void UnregisterPrefab(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity The prefab to be removed from registration. | Improve this Doc View Source UnregisterSpawnHandler(Guid) Removes a registered spawn handler function that was registered with ClientScene.RegisterHandler(). Declaration public void UnregisterSpawnHandler(Guid assetId) Parameters Type Name Description Guid assetId The assetId for the handler to be removed for. Implements IClientObjectManager IObjectLocator"
  },
  "api/Mirage.ClientRpcAttribute.html": {
    "href": "api/Mirage.ClientRpcAttribute.html",
    "title": "Class ClientRpcAttribute",
    "keywords": "Class ClientRpcAttribute The server uses a Remote Procedure Call (RPC) to run this function on specific clients. Note that if you set the target as Connection, you need to pass a specific connection as a parameter of your method Inheritance Object ClientRpcAttribute Namespace : Mirage Assembly : doc.dll Syntax public class ClientRpcAttribute : Attribute Fields | Improve this Doc View Source channel Declaration public int channel Field Value Type Description Int32 | Improve this Doc View Source excludeOwner Declaration public bool excludeOwner Field Value Type Description Boolean | Improve this Doc View Source target Declaration public Client target Field Value Type Description Client"
  },
  "api/Mirage.ClientSceneChangeEvent.html": {
    "href": "api/Mirage.ClientSceneChangeEvent.html",
    "title": "Class ClientSceneChangeEvent",
    "keywords": "Class ClientSceneChangeEvent Event fires from INetworkSceneManager when a scene change happens on either Server or Client. string - New ScenePath SceneOperation - Scene change type (Normal, Additive Load, Additive Unload). Inheritance Object ClientSceneChangeEvent Namespace : Mirage Assembly : doc.dll Syntax public class ClientSceneChangeEvent : UnityEvent<string, SceneOperation>"
  },
  "api/Mirage.Compression.html": {
    "href": "api/Mirage.Compression.html",
    "title": "Class Compression",
    "keywords": "Class Compression Credit to this man for converting gaffer games c code to c# https://gist.github.com/fversnel/0497ad7ab3b81e0dc1dd Inheritance Object Compression Namespace : Mirage Assembly : doc.dll Syntax public static class Compression : object"
  },
  "api/Mirage.ConnectState.html": {
    "href": "api/Mirage.ConnectState.html",
    "title": "Enum ConnectState",
    "keywords": "Enum ConnectState Namespace : Mirage Assembly : doc.dll Syntax public enum ConnectState : int Fields Name Description Connected Connecting Disconnected"
  },
  "api/Mirage.Experimental.html": {
    "href": "api/Mirage.Experimental.html",
    "title": "Namespace Mirage.Experimental",
    "keywords": "Namespace Mirage.Experimental Classes NetworkLerpRigidbody NetworkRigidbody NetworkRigidbody.ClientSyncState holds previously synced values NetworkTransform NetworkTransformBase NetworkTransformChild A component to synchronize the position of child transforms of networked objects. There must be a NetworkTransform on the root object of the hierarchy. There can be multiple NetworkTransformChild components on an object. This does not use physics for synchronization, it simply synchronizes the localPosition and localRotation of the child transform and lerps towards the recieved values. Structs NetworkTransformBase.DataPoint"
  },
  "api/Mirage.Experimental.NetworkLerpRigidbody.html": {
    "href": "api/Mirage.Experimental.NetworkLerpRigidbody.html",
    "title": "Class NetworkLerpRigidbody",
    "keywords": "Class NetworkLerpRigidbody Inheritance Object NetworkBehaviour NetworkLerpRigidbody Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage.Experimental Assembly : doc.dll Syntax public class NetworkLerpRigidbody : NetworkBehaviour Fields | Improve this Doc View Source clientAuthority Declaration public bool clientAuthority Field Value Type Description Boolean | Improve this Doc View Source lerpPositionAmount Declaration public float lerpPositionAmount Field Value Type Description Single | Improve this Doc View Source lerpVelocityAmount Declaration public float lerpVelocityAmount Field Value Type Description Single"
  },
  "api/Mirage.Experimental.NetworkRigidbody.ClientSyncState.html": {
    "href": "api/Mirage.Experimental.NetworkRigidbody.ClientSyncState.html",
    "title": "Class NetworkRigidbody.ClientSyncState",
    "keywords": "Class NetworkRigidbody.ClientSyncState holds previously synced values Inheritance Object NetworkRigidbody.ClientSyncState Namespace : Mirage.Experimental Assembly : doc.dll Syntax public class ClientSyncState : object Fields | Improve this Doc View Source angularDrag Declaration public float angularDrag Field Value Type Description Single | Improve this Doc View Source angularVelocity Declaration public Vector3 angularVelocity Field Value Type Description Vector3 | Improve this Doc View Source drag Declaration public float drag Field Value Type Description Single | Improve this Doc View Source isKinematic Declaration public bool isKinematic Field Value Type Description Boolean | Improve this Doc View Source nextSyncTime Next sync time that velocity will be synced, based on syncInterval. Declaration public float nextSyncTime Field Value Type Description Single | Improve this Doc View Source useGravity Declaration public bool useGravity Field Value Type Description Boolean | Improve this Doc View Source velocity Declaration public Vector3 velocity Field Value Type Description Vector3"
  },
  "api/Mirage.Experimental.NetworkRigidbody.html": {
    "href": "api/Mirage.Experimental.NetworkRigidbody.html",
    "title": "Class NetworkRigidbody",
    "keywords": "Class NetworkRigidbody Inheritance Object NetworkBehaviour NetworkRigidbody Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage.Experimental Assembly : doc.dll Syntax public class NetworkRigidbody : NetworkBehaviour Fields | Improve this Doc View Source angularVelocitySensitivity Declaration public float angularVelocitySensitivity Field Value Type Description Single | Improve this Doc View Source clearAngularVelocity Declaration public bool clearAngularVelocity Field Value Type Description Boolean | Improve this Doc View Source clearVelocity Declaration public bool clearVelocity Field Value Type Description Boolean | Improve this Doc View Source clientAuthority Declaration public bool clientAuthority Field Value Type Description Boolean | Improve this Doc View Source syncAngularVelocity Declaration public bool syncAngularVelocity Field Value Type Description Boolean | Improve this Doc View Source syncVelocity Declaration public bool syncVelocity Field Value Type Description Boolean | Improve this Doc View Source target Declaration public Rigidbody target Field Value Type Description Rigidbody | Improve this Doc View Source velocitySensitivity Declaration public float velocitySensitivity Field Value Type Description Single"
  },
  "api/Mirage.Experimental.NetworkTransform.html": {
    "href": "api/Mirage.Experimental.NetworkTransform.html",
    "title": "Class NetworkTransform",
    "keywords": "Class NetworkTransform Inheritance Object NetworkBehaviour NetworkTransformBase NetworkTransform Inherited Members NetworkTransformBase.clientAuthority NetworkTransformBase.excludeOwnerUpdate NetworkTransformBase.syncPosition NetworkTransformBase.syncRotation NetworkTransformBase.syncScale NetworkTransformBase.interpolatePosition NetworkTransformBase.interpolateRotation NetworkTransformBase.interpolateScale NetworkTransformBase.localPositionSensitivity NetworkTransformBase.localRotationSensitivity NetworkTransformBase.localScaleSensitivity NetworkTransformBase.lastPosition NetworkTransformBase.lastRotation NetworkTransformBase.lastScale NetworkTransformBase.start NetworkTransformBase.goal NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage.Experimental Assembly : doc.dll Syntax public class NetworkTransform : NetworkTransformBase Properties | Improve this Doc View Source TargetTransform Declaration protected override Transform TargetTransform { get; } Property Value Type Description Transform Overrides NetworkTransformBase.TargetTransform"
  },
  "api/Mirage.Experimental.NetworkTransformBase.DataPoint.html": {
    "href": "api/Mirage.Experimental.NetworkTransformBase.DataPoint.html",
    "title": "Struct NetworkTransformBase.DataPoint",
    "keywords": "Struct NetworkTransformBase.DataPoint Namespace : Mirage.Experimental Assembly : doc.dll Syntax public struct DataPoint Fields | Improve this Doc View Source localPosition Declaration public Vector3 localPosition Field Value Type Description Vector3 | Improve this Doc View Source localRotation Declaration public Quaternion localRotation Field Value Type Description Quaternion | Improve this Doc View Source localScale Declaration public Vector3 localScale Field Value Type Description Vector3 | Improve this Doc View Source movementSpeed Declaration public float movementSpeed Field Value Type Description Single | Improve this Doc View Source timeStamp Declaration public float timeStamp Field Value Type Description Single Properties | Improve this Doc View Source IsValid Declaration public bool IsValid { get; } Property Value Type Description Boolean"
  },
  "api/Mirage.Experimental.NetworkTransformBase.html": {
    "href": "api/Mirage.Experimental.NetworkTransformBase.html",
    "title": "Class NetworkTransformBase",
    "keywords": "Class NetworkTransformBase Inheritance Object NetworkBehaviour NetworkTransformBase NetworkTransform NetworkTransformChild Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage.Experimental Assembly : doc.dll Syntax public abstract class NetworkTransformBase : NetworkBehaviour Fields | Improve this Doc View Source clientAuthority Declaration public bool clientAuthority Field Value Type Description Boolean | Improve this Doc View Source excludeOwnerUpdate Declaration public bool excludeOwnerUpdate Field Value Type Description Boolean | Improve this Doc View Source goal Declaration public NetworkTransformBase.DataPoint goal Field Value Type Description NetworkTransformBase.DataPoint | Improve this Doc View Source interpolatePosition Declaration public bool interpolatePosition Field Value Type Description Boolean | Improve this Doc View Source interpolateRotation Declaration public bool interpolateRotation Field Value Type Description Boolean | Improve this Doc View Source interpolateScale Declaration public bool interpolateScale Field Value Type Description Boolean | Improve this Doc View Source lastPosition Declaration public Vector3 lastPosition Field Value Type Description Vector3 | Improve this Doc View Source lastRotation Declaration public Quaternion lastRotation Field Value Type Description Quaternion | Improve this Doc View Source lastScale Declaration public Vector3 lastScale Field Value Type Description Vector3 | Improve this Doc View Source localPositionSensitivity Declaration public float localPositionSensitivity Field Value Type Description Single | Improve this Doc View Source localRotationSensitivity Declaration public float localRotationSensitivity Field Value Type Description Single | Improve this Doc View Source localScaleSensitivity Declaration public float localScaleSensitivity Field Value Type Description Single | Improve this Doc View Source start Declaration public NetworkTransformBase.DataPoint start Field Value Type Description NetworkTransformBase.DataPoint | Improve this Doc View Source syncPosition Declaration public bool syncPosition Field Value Type Description Boolean | Improve this Doc View Source syncRotation Declaration public bool syncRotation Field Value Type Description Boolean | Improve this Doc View Source syncScale Declaration public bool syncScale Field Value Type Description Boolean Properties | Improve this Doc View Source TargetTransform Declaration protected abstract Transform TargetTransform { get; } Property Value Type Description Transform"
  },
  "api/Mirage.Experimental.NetworkTransformChild.html": {
    "href": "api/Mirage.Experimental.NetworkTransformChild.html",
    "title": "Class NetworkTransformChild",
    "keywords": "Class NetworkTransformChild A component to synchronize the position of child transforms of networked objects. There must be a NetworkTransform on the root object of the hierarchy. There can be multiple NetworkTransformChild components on an object. This does not use physics for synchronization, it simply synchronizes the localPosition and localRotation of the child transform and lerps towards the recieved values. Inheritance Object NetworkBehaviour NetworkTransformBase NetworkTransformChild Inherited Members NetworkTransformBase.clientAuthority NetworkTransformBase.excludeOwnerUpdate NetworkTransformBase.syncPosition NetworkTransformBase.syncRotation NetworkTransformBase.syncScale NetworkTransformBase.interpolatePosition NetworkTransformBase.interpolateRotation NetworkTransformBase.interpolateScale NetworkTransformBase.localPositionSensitivity NetworkTransformBase.localRotationSensitivity NetworkTransformBase.localScaleSensitivity NetworkTransformBase.lastPosition NetworkTransformBase.lastRotation NetworkTransformBase.lastScale NetworkTransformBase.start NetworkTransformBase.goal NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage.Experimental Assembly : doc.dll Syntax public class NetworkTransformChild : NetworkTransformBase Fields | Improve this Doc View Source target Declaration public Transform target Field Value Type Description Transform Properties | Improve this Doc View Source TargetTransform Declaration protected override Transform TargetTransform { get; } Property Value Type Description Transform Overrides NetworkTransformBase.TargetTransform"
  },
  "api/Mirage.ExponentialMovingAverage.html": {
    "href": "api/Mirage.ExponentialMovingAverage.html",
    "title": "Class ExponentialMovingAverage",
    "keywords": "Class ExponentialMovingAverage Inheritance Object ExponentialMovingAverage Namespace : Mirage Assembly : doc.dll Syntax public class ExponentialMovingAverage : object Constructors | Improve this Doc View Source ExponentialMovingAverage(Int32) Declaration public ExponentialMovingAverage(int n) Parameters Type Name Description Int32 n Properties | Improve this Doc View Source Value Declaration public double Value { get; } Property Value Type Description Double | Improve this Doc View Source Var Declaration public double Var { get; } Property Value Type Description Double Methods | Improve this Doc View Source Add(Double) Declaration public void Add(double newValue) Parameters Type Name Description Double newValue"
  },
  "api/Mirage.GameObjectSerializers.html": {
    "href": "api/Mirage.GameObjectSerializers.html",
    "title": "Class GameObjectSerializers",
    "keywords": "Class GameObjectSerializers Inheritance Object GameObjectSerializers Namespace : Mirage Assembly : doc.dll Syntax public static class GameObjectSerializers : object Methods | Improve this Doc View Source ReadGameObjectSyncVar(NetworkReader) Declaration public static GameObjectSyncvar ReadGameObjectSyncVar(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description GameObjectSyncvar | Improve this Doc View Source WriteGameObjectSyncVar(NetworkWriter, GameObjectSyncvar) Declaration public static void WriteGameObjectSyncVar(this NetworkWriter writer, GameObjectSyncvar id) Parameters Type Name Description NetworkWriter writer GameObjectSyncvar id"
  },
  "api/Mirage.GameObjectSyncvar.html": {
    "href": "api/Mirage.GameObjectSyncvar.html",
    "title": "Struct GameObjectSyncvar",
    "keywords": "Struct GameObjectSyncvar backing struct for a NetworkIdentity when used as a syncvar the weaver will replace the syncvar with this struct. Namespace : Mirage Assembly : doc.dll Syntax public struct GameObjectSyncvar Properties | Improve this Doc View Source Value Declaration public GameObject Value { get; set; } Property Value Type Description GameObject"
  },
  "api/Mirage.HasAuthorityAttribute.html": {
    "href": "api/Mirage.HasAuthorityAttribute.html",
    "title": "Class HasAuthorityAttribute",
    "keywords": "Class HasAuthorityAttribute Prevents players without authority from running this method. Inheritance Object HasAuthorityAttribute Namespace : Mirage Assembly : doc.dll Syntax public class HasAuthorityAttribute : Attribute Fields | Improve this Doc View Source error If true, when the method is called from a client, it throws an error If false, no error is thrown, but the method won't execute useful for unity built in methods such as Await, Update, Start, etc. Declaration public bool error Field Value Type Description Boolean"
  },
  "api/Mirage.HeadlessAutoStart.html": {
    "href": "api/Mirage.HeadlessAutoStart.html",
    "title": "Class HeadlessAutoStart",
    "keywords": "Class HeadlessAutoStart Inheritance Object HeadlessAutoStart Namespace : Mirage Assembly : doc.dll Syntax public class HeadlessAutoStart : MonoBehaviour Fields | Improve this Doc View Source Server Declaration public NetworkServer Server Field Value Type Description NetworkServer | Improve this Doc View Source startOnHeadless Automatically invoke StartServer() If the application is a Server Build or run with the -batchMode ServerRpc line arguement, StartServer is automatically invoked. Declaration public bool startOnHeadless Field Value Type Description Boolean"
  },
  "api/Mirage.HeadlessFrameLimiter.html": {
    "href": "api/Mirage.HeadlessFrameLimiter.html",
    "title": "Class HeadlessFrameLimiter",
    "keywords": "Class HeadlessFrameLimiter Inheritance Object HeadlessFrameLimiter Namespace : Mirage Assembly : doc.dll Syntax public class HeadlessFrameLimiter : MonoBehaviour Fields | Improve this Doc View Source serverTickRate Server Update frequency, per second. Use around 60Hz for fast paced games like Counter-Strike to minimize latency. Use around 30Hz for games like WoW to minimize computations. Use around 1-10Hz for slow paced games like EVE. Declaration public int serverTickRate Field Value Type Description Int32 Methods | Improve this Doc View Source Start() Set the frame rate for a headless server. Declaration public void Start()"
  },
  "api/Mirage.html": {
    "href": "api/Mirage.html",
    "title": "Namespace Mirage",
    "keywords": "Namespace Mirage Classes Channel ClientAttribute Prevents the server from running this method. ClientObjectManager ClientRpcAttribute The server uses a Remote Procedure Call (RPC) to run this function on specific clients. Note that if you set the target as Connection, you need to pass a specific connection as a parameter of your method ClientSceneChangeEvent Event fires from INetworkSceneManager when a scene change happens on either Server or Client. string - New ScenePath SceneOperation - Scene change type (Normal, Additive Load, Additive Unload). Compression Credit to this man for converting gaffer games c code to c# https://gist.github.com/fversnel/0497ad7ab3b81e0dc1dd ExponentialMovingAverage GameObjectSerializers HasAuthorityAttribute Prevents players without authority from running this method. HeadlessAutoStart HeadlessFrameLimiter ILoggerExtensions InvalidMessageException LobbyReady LocalPlayerAttribute Prevents nonlocal players from running this method. LogFactory LogSettings MessagePacker MethodInvocationException Exception thrown if a guarded method is invoked incorrectly MultiplexTransport NetworkAnimator A component to synchronize Mecanim animation states for networked objects. NetworkAuthenticator Base class for implementing component-based authentication during the Connect phase NetworkBehaviorSerializers NetworkBehaviour Base class which should be inherited by scripts which contain networking functionality. NetworkClient This is a network client class used by the networking system. It contains a NetworkConnection that is used to connect to a network server. The NetworkClient handle connection state, messages handlers, and connection configuration. There can be many NetworkClient instances in a process at a time, but only one that is connected to a game server ( NetworkServer ) that uses spawned objects. NetworkClient has an internal update function where it handles events from the transport layer. This includes asynchronous connect events, disconnect events and incoming data from a server. NetworkConnection A High level network connection. This is used for connections from client-to-server and for connection from server-to-client. NetworkConnectionEvent Event fires from a NetworkClient or NetworkServer during a new connection, a new authentication, or a disconnection. INetworkConnection - connection creating the event NetworkDiagnostics Provides profiling information from mirror A profiler can subscribe to these events and present the data in a friendly way to the user NetworkIdentity The NetworkIdentity identifies objects across the network, between server and clients. Its primary data is a NetworkInstanceId which is allocated by the server and then set on clients. This is used in network communications to be able to lookup game objects on different machines. NetworkIdentitySerializers NetworkManager NetworkManagerHud NetworkMatchChecker Component that controls visibility of networked objects based on match id. Any object with this component on it will only be visible to other objects in the same match. This would be used to isolate players to their respective matches within a single game server instance. NetworkMessageAttribute Tell the weaver to generate reader and writer for a class NetworkPingDisplay Component that will display the clients ping in milliseconds NetworkProximityChecker Component that controls visibility of networked objects for players. Any object with this component on it will not be visible to players more than a (configurable) distance away. NetworkReader Binary stream Reader. Supports simple types, buffers, arrays, structs, and nested types Use GetReader(Byte[]) to reduce memory allocation NetworkReaderExtensions NetworkReaderPool Pool of NetworkReaders Use this pool instead of NetworkReader to reduce memory allocation Use Capacity to change size of pool NetworkSceneChecker Component that controls visibility of networked objects between scenes. Any object with this component on it will only be visible to other objects in the same scene This would be used when the server has multiple additive subscenes loaded to isolate players to their respective subscenes NetworkSceneManager Provides Scene Management to a NetworkServer and or NetworkClient. The NetworkClient loads scenes as instructed by the NetworkServer . The NetworkServer controls the currently active Scene and any additive Load/Unload. NetworkServer The NetworkServer. NetworkTime Synchronize time between the server and the clients NetworkTransform NetworkTransformBase NetworkTransformBase.DataPoint NetworkTransformChild A component to synchronize the position of child transforms of networked objects. There must be a NetworkTransform on the root object of the hierarchy. There can be multiple NetworkTransformChild components on an object. This does not use physics for synchronization, it simply synchronizes the localPosition and localRotation of the child transform and lerps towards the recieved values. NetworkVisibility NetworkWriter Binary stream Writer. Supports simple types, buffers, arrays, structs, and nested types Use GetWriter() to reduce memory allocation NetworkWriterExtensions NetworkWriterPool Pool of NetworkWriters Use this pool instead of NetworkWriter to reduce memory allocation Use Capacity to change size of pool NotifyPacketSerializer ObjectReady OnlineOfflineScene PipeConnection A connection that is directly connected to another connection If you send data in one of them, you receive it on the other one PlayerSpawner Spawns a player as soon as the connection is authenticated PooledNetworkReader NetworkReader to be used with NetworkReaderPool PooledNetworkWriter NetworkWriter to be used with NetworkWriterPool Reader<T> a class that holds readers for the different types Note that c# creates a different static variable for each type This will be populated by the weaver SceneAttribute Converts a string property into a Scene property in the inspector ServerAttribute Prevents clients from running this method. ServerObjectManager The ServerObjectManager. ServerRpcAttribute Call this from a client to run this function on the server. Make sure to validate input etc. It's not possible to call this from a server. ShowInInspectorAttribute Used to show private SyncList in the inspector, Use instead of SerializeField for non Serializable types SpawnEvent StringHash SyncDictionary<TKey, TValue> SyncHashSet<T> SyncIDictionary<TKey, TValue> SyncList<T> SyncSet<T> SyncSortedSet<T> SyncVarAttribute SyncVars are used to synchronize a variable from the server to all clients automatically. Value must be changed on server, not directly by clients. Hook parameter allows you to define a client-side method to be invoked when the client gets an update from the server. Transport Base transport class, any transport should implement this class and it's abstract methods Transport.ConnectEvent Writer<T> a class that holds writers for the different types Note that c# creates a different static variable for each type This will be populated by the weaver Structs AddPlayerMessage GameObjectSyncvar backing struct for a NetworkIdentity when used as a syncvar the weaver will replace the syncvar with this struct. LogSettings.Level NetworkBehaviorSyncvar backing struct for a NetworkIdentity when used as a syncvar the weaver will replace the syncvar with this struct. NetworkDiagnostics.MessageInfo Describes an outgoing message NetworkIdentitySyncvar backing struct for a NetworkIdentity when used as a syncvar the weaver will replace the syncvar with this struct. NetworkPingMessage NetworkPongMessage NotifyAck NotifyPacket NotReadyMessage ObjectDestroyMessage ObjectHideMessage ReadyMessage RpcMessage SceneMessage SceneReadyMessage Sequencer ServerRpcMessage ServerRpcReply SpawnMessage SyncList<T>.Enumerator UpdateVarsMessage Interfaces IClientObjectManager IConnection IMessageHandler An object that can send and receive messages INetworkClient INetworkConnection A connection to a remote endpoint. May be from the server to client or from client to server INetworkManager INetworkSceneManager INetworkServer IObjectLocator An object that implements this interface can find objects by their net id This is used by readers when trying to deserialize gameobjects IObjectOwner An object that can own networked objects IServerObjectManager ISyncObject A sync object is an object that can synchronize it's state between server and client, such as a SyncList IVisibilityTracker An object that can observe NetworkIdentities. this is useful for interest management Enums Client ConnectState MirageInvokeType PlayerSpawner.PlayerSpawnMethod Enumeration of methods of where to spawn player objects in multiplayer games. SceneOperation SyncMode Sync to everyone, or only to owner. Version Delegates NetworkIdentity.ClientAuthorityCallback The delegate type for the clientAuthorityCallback. SpawnHandlerDelegate UnSpawnDelegate"
  },
  "api/Mirage.IClientObjectManager.html": {
    "href": "api/Mirage.IClientObjectManager.html",
    "title": "Interface IClientObjectManager",
    "keywords": "Interface IClientObjectManager Namespace : Mirage Assembly : doc.dll Syntax public interface IClientObjectManager Properties | Improve this Doc View Source LocalPlayer NetworkIdentity of the localPlayer Declaration NetworkIdentity LocalPlayer { get; } Property Value Type Description NetworkIdentity | Improve this Doc View Source Spawned Raised when the client spawns an object Declaration SpawnEvent Spawned { get; } Property Value Type Description SpawnEvent | Improve this Doc View Source UnSpawned Raised when the client unspawns an object Declaration SpawnEvent UnSpawned { get; } Property Value Type Description SpawnEvent Methods | Improve this Doc View Source ClearSpawners() Declaration void ClearSpawners() | Improve this Doc View Source DestroyAllClientObjects() Declaration void DestroyAllClientObjects() | Improve this Doc View Source GetPrefab(Guid) Declaration NetworkIdentity GetPrefab(Guid assetId) Parameters Type Name Description Guid assetId Returns Type Description NetworkIdentity | Improve this Doc View Source PrepareToSpawnSceneObjects() Declaration void PrepareToSpawnSceneObjects() | Improve this Doc View Source RegisterPrefab(NetworkIdentity) Declaration void RegisterPrefab(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity | Improve this Doc View Source RegisterPrefab(NetworkIdentity, Guid) Declaration void RegisterPrefab(NetworkIdentity identity, Guid newAssetId) Parameters Type Name Description NetworkIdentity identity Guid newAssetId | Improve this Doc View Source RegisterPrefab(NetworkIdentity, SpawnHandlerDelegate, UnSpawnDelegate) Declaration void RegisterPrefab(NetworkIdentity identity, SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description NetworkIdentity identity SpawnHandlerDelegate spawnHandler UnSpawnDelegate unspawnHandler | Improve this Doc View Source RegisterSpawnHandler(Guid, SpawnHandlerDelegate, UnSpawnDelegate) Declaration void RegisterSpawnHandler(Guid assetId, SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description Guid assetId SpawnHandlerDelegate spawnHandler UnSpawnDelegate unspawnHandler | Improve this Doc View Source UnregisterPrefab(NetworkIdentity) Declaration void UnregisterPrefab(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity | Improve this Doc View Source UnregisterSpawnHandler(Guid) Declaration void UnregisterSpawnHandler(Guid assetId) Parameters Type Name Description Guid assetId"
  },
  "api/Mirage.IConnection.html": {
    "href": "api/Mirage.IConnection.html",
    "title": "Interface IConnection",
    "keywords": "Interface IConnection Namespace : Mirage Assembly : doc.dll Syntax public interface IConnection Methods | Improve this Doc View Source Disconnect() Disconnect this connection Declaration void Disconnect() | Improve this Doc View Source GetEndPointAddress() the address of endpoint we are connected to Note this can be IPEndPoint or a custom implementation of EndPoint, which depends on the transport Declaration EndPoint GetEndPointAddress() Returns Type Description EndPoint | Improve this Doc View Source ReceiveAsync(MemoryStream) reads a message from connection Declaration UniTask<int> ReceiveAsync(MemoryStream buffer) Parameters Type Name Description MemoryStream buffer buffer where the message will be written Returns Type Description UniTask < Int32 > The channel where we got the message | Improve this Doc View Source SendAsync(ArraySegment<Byte>, Int32) Declaration UniTask SendAsync(ArraySegment<byte> data, int channel = null) Parameters Type Name Description ArraySegment < Byte > data Int32 channel Returns Type Description UniTask"
  },
  "api/Mirage.ILoggerExtensions.html": {
    "href": "api/Mirage.ILoggerExtensions.html",
    "title": "Class ILoggerExtensions",
    "keywords": "Class ILoggerExtensions Inheritance Object ILoggerExtensions Namespace : Mirage Assembly : doc.dll Syntax public static class ILoggerExtensions : object Methods | Improve this Doc View Source ErrorEnabled(ILogger) Declaration public static bool ErrorEnabled(this ILogger logger) Parameters Type Name Description ILogger logger Returns Type Description Boolean | Improve this Doc View Source LogEnabled(ILogger) Declaration public static bool LogEnabled(this ILogger logger) Parameters Type Name Description ILogger logger Returns Type Description Boolean | Improve this Doc View Source LogError(ILogger, Object) Declaration public static void LogError(this ILogger logger, object message) Parameters Type Name Description ILogger logger Object message | Improve this Doc View Source LogWarning(ILogger, Object) Declaration public static void LogWarning(this ILogger logger, object message) Parameters Type Name Description ILogger logger Object message | Improve this Doc View Source WarnEnabled(ILogger) Declaration public static bool WarnEnabled(this ILogger logger) Parameters Type Name Description ILogger logger Returns Type Description Boolean"
  },
  "api/Mirage.IMessageHandler.html": {
    "href": "api/Mirage.IMessageHandler.html",
    "title": "Interface IMessageHandler",
    "keywords": "Interface IMessageHandler An object that can send and receive messages Namespace : Mirage Assembly : doc.dll Syntax public interface IMessageHandler Methods | Improve this Doc View Source ClearHandlers() Declaration void ClearHandlers() | Improve this Doc View Source ProcessMessagesAsync() Declaration UniTask ProcessMessagesAsync() Returns Type Description UniTask | Improve this Doc View Source RegisterHandler<T>(Action<T>) Declaration void RegisterHandler<T>(Action<T> handler) Parameters Type Name Description Action <T> handler Type Parameters Name Description T | Improve this Doc View Source RegisterHandler<T>(Action<INetworkConnection, T>) Declaration void RegisterHandler<T>(Action<INetworkConnection, T> handler) Parameters Type Name Description Action < INetworkConnection , T> handler Type Parameters Name Description T | Improve this Doc View Source Send<T>(T, Int32) Declaration void Send<T>(T msg, int channelId = null) Parameters Type Name Description T msg Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SendAsync(ArraySegment<Byte>, Int32) Declaration UniTask SendAsync(ArraySegment<byte> segment, int channelId = null) Parameters Type Name Description ArraySegment < Byte > segment Int32 channelId Returns Type Description UniTask | Improve this Doc View Source SendAsync<T>(T, Int32) Declaration UniTask SendAsync<T>(T msg, int channelId = null) Parameters Type Name Description T msg Int32 channelId Returns Type Description UniTask Type Parameters Name Description T | Improve this Doc View Source SendNotify<T>(T, Object, Int32) Sends a message, but notify when it is delivered or lost Declaration void SendNotify<T>(T msg, object token, int channelId = null) Parameters Type Name Description T msg message to send Object token a arbitrary object that the sender will receive with their notification Int32 channelId Type Parameters Name Description T type of message to send | Improve this Doc View Source UnregisterHandler<T>() Declaration void UnregisterHandler<T>() Type Parameters Name Description T Events | Improve this Doc View Source NotifyDelivered Raised when a message is delivered Declaration event Action<INetworkConnection, object> NotifyDelivered Event Type Type Description Action < INetworkConnection , Object > | Improve this Doc View Source NotifyLost Raised when a message is lost Declaration event Action<INetworkConnection, object> NotifyLost Event Type Type Description Action < INetworkConnection , Object >"
  },
  "api/Mirage.INetworkClient.html": {
    "href": "api/Mirage.INetworkClient.html",
    "title": "Interface INetworkClient",
    "keywords": "Interface INetworkClient Namespace : Mirage Assembly : doc.dll Syntax public interface INetworkClient Properties | Improve this Doc View Source Active active is true while a client is connecting/connected (= while the network is active) Declaration bool Active { get; } Property Value Type Description Boolean | Improve this Doc View Source Authenticated Event fires after the Client connection has sucessfully been authenticated with its Server. Declaration NetworkConnectionEvent Authenticated { get; } Property Value Type Description NetworkConnectionEvent | Improve this Doc View Source Connected Event fires once the Client has connected its Server. Declaration NetworkConnectionEvent Connected { get; } Property Value Type Description NetworkConnectionEvent | Improve this Doc View Source Connection The NetworkConnection object this client is using. Declaration INetworkConnection Connection { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source Disconnected Event fires after the Client has disconnected from its Server and Cleanup has been called. Declaration UnityEvent Disconnected { get; } Property Value Type Description UnityEvent | Improve this Doc View Source IsLocalClient NetworkClient can connect to local server in host mode too Declaration bool IsLocalClient { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source Disconnect() Declaration void Disconnect() | Improve this Doc View Source Send<T>(T, Int32) Declaration void Send<T>(T message, int channelId = null) Parameters Type Name Description T message Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SendAsync<T>(T, Int32) Declaration UniTask SendAsync<T>(T message, int channelId = null) Parameters Type Name Description T message Int32 channelId Returns Type Description UniTask Type Parameters Name Description T"
  },
  "api/Mirage.INetworkConnection.html": {
    "href": "api/Mirage.INetworkConnection.html",
    "title": "Interface INetworkConnection",
    "keywords": "Interface INetworkConnection A connection to a remote endpoint. May be from the server to client or from client to server Inherited Members IMessageHandler.RegisterHandler<T>(Action<INetworkConnection, T>) IMessageHandler.RegisterHandler<T>(Action<T>) IMessageHandler.UnregisterHandler<T>() IMessageHandler.ClearHandlers() IMessageHandler.Send<T>(T, Int32) IMessageHandler.SendAsync<T>(T, Int32) IMessageHandler.SendAsync(ArraySegment<Byte>, Int32) IMessageHandler.ProcessMessagesAsync() IMessageHandler.SendNotify<T>(T, Object, Int32) IMessageHandler.NotifyDelivered IMessageHandler.NotifyLost IVisibilityTracker.AddToVisList(NetworkIdentity) IVisibilityTracker.RemoveFromVisList(NetworkIdentity) IVisibilityTracker.RemoveObservers() IObjectOwner.Identity IObjectOwner.RemoveOwnedObject(NetworkIdentity) IObjectOwner.AddOwnedObject(NetworkIdentity) IObjectOwner.DestroyOwnedObjects() Namespace : Mirage Assembly : doc.dll Syntax public interface INetworkConnection : IMessageHandler, IVisibilityTracker, IObjectOwner Properties | Improve this Doc View Source Address Declaration EndPoint Address { get; } Property Value Type Description EndPoint | Improve this Doc View Source AuthenticationData Declaration object AuthenticationData { get; set; } Property Value Type Description Object | Improve this Doc View Source IsReady Declaration bool IsReady { get; set; } Property Value Type Description Boolean Methods | Improve this Doc View Source Disconnect() Declaration void Disconnect()"
  },
  "api/Mirage.INetworkManager.html": {
    "href": "api/Mirage.INetworkManager.html",
    "title": "Interface INetworkManager",
    "keywords": "Interface INetworkManager Namespace : Mirage Assembly : doc.dll Syntax public interface INetworkManager Methods | Improve this Doc View Source StopHost() Declaration void StopHost()"
  },
  "api/Mirage.INetworkSceneManager.html": {
    "href": "api/Mirage.INetworkSceneManager.html",
    "title": "Interface INetworkSceneManager",
    "keywords": "Interface INetworkSceneManager Namespace : Mirage Assembly : doc.dll Syntax public interface INetworkSceneManager Properties | Improve this Doc View Source ClientChangeScene Event fires when the Client starts changing scene. Declaration ClientSceneChangeEvent ClientChangeScene { get; } Property Value Type Description ClientSceneChangeEvent | Improve this Doc View Source ClientSceneChanged Event fires after the Client has completed its scene change. Declaration ClientSceneChangeEvent ClientSceneChanged { get; } Property Value Type Description ClientSceneChangeEvent | Improve this Doc View Source ServerChangeScene Event fires before Server changes scene. Declaration ClientSceneChangeEvent ServerChangeScene { get; } Property Value Type Description ClientSceneChangeEvent | Improve this Doc View Source ServerSceneChanged Event fires after Server has completed scene change. Declaration ClientSceneChangeEvent ServerSceneChanged { get; } Property Value Type Description ClientSceneChangeEvent Methods | Improve this Doc View Source ChangeServerScene(String, SceneOperation) Declaration void ChangeServerScene(string scenePath, SceneOperation sceneOperation = SceneOperation.Normal) Parameters Type Name Description String scenePath SceneOperation sceneOperation"
  },
  "api/Mirage.INetworkServer.html": {
    "href": "api/Mirage.INetworkServer.html",
    "title": "Interface INetworkServer",
    "keywords": "Interface INetworkServer Namespace : Mirage Assembly : doc.dll Syntax public interface INetworkServer Properties | Improve this Doc View Source Active Checks if the server has been started. This will be true after NetworkServer.Listen() has been called. Declaration bool Active { get; } Property Value Type Description Boolean | Improve this Doc View Source Authenticated Event fires once a new Client has passed Authentication to the Server. Declaration NetworkConnectionEvent Authenticated { get; } Property Value Type Description NetworkConnectionEvent | Improve this Doc View Source Connected Event fires once a new Client has connect to the Server. Declaration NetworkConnectionEvent Connected { get; } Property Value Type Description NetworkConnectionEvent | Improve this Doc View Source Disconnected Event fires once a Client has Disconnected from the Server. Declaration NetworkConnectionEvent Disconnected { get; } Property Value Type Description NetworkConnectionEvent | Improve this Doc View Source LocalClient The host client for this server Declaration NetworkClient LocalClient { get; } Property Value Type Description NetworkClient | Improve this Doc View Source LocalClientActive True if there is a local client connected to this server (host mode) Declaration bool LocalClientActive { get; } Property Value Type Description Boolean | Improve this Doc View Source LocalConnection The connection to the host mode client (if any). Declaration INetworkConnection LocalConnection { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source OnStartHost This is invoked when a host is started. StartHost has multiple signatures, but they all cause this hook to be called. Declaration UnityEvent OnStartHost { get; } Property Value Type Description UnityEvent | Improve this Doc View Source OnStopHost This is called when a host is stopped. Declaration UnityEvent OnStopHost { get; } Property Value Type Description UnityEvent | Improve this Doc View Source Started This is invoked when a server is started - including when a host is started. Declaration UnityEvent Started { get; } Property Value Type Description UnityEvent | Improve this Doc View Source Stopped Declaration UnityEvent Stopped { get; } Property Value Type Description UnityEvent Methods | Improve this Doc View Source AddConnection(INetworkConnection) Declaration void AddConnection(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn | Improve this Doc View Source Disconnect() Declaration void Disconnect() | Improve this Doc View Source RemoveConnection(INetworkConnection) Declaration void RemoveConnection(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn | Improve this Doc View Source SendToAll<T>(T, Int32) Declaration void SendToAll<T>(T msg, int channelId = null) Parameters Type Name Description T msg Int32 channelId Type Parameters Name Description T"
  },
  "api/Mirage.InvalidMessageException.html": {
    "href": "api/Mirage.InvalidMessageException.html",
    "title": "Class InvalidMessageException",
    "keywords": "Class InvalidMessageException Inheritance Object InvalidMessageException Namespace : Mirage Assembly : doc.dll Syntax public class InvalidMessageException : Exception Constructors | Improve this Doc View Source InvalidMessageException() Declaration public InvalidMessageException() | Improve this Doc View Source InvalidMessageException(SerializationInfo, StreamingContext) Declaration protected InvalidMessageException(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source InvalidMessageException(String) Declaration public InvalidMessageException(string message) Parameters Type Name Description String message | Improve this Doc View Source InvalidMessageException(String, Exception) Declaration public InvalidMessageException(string message, Exception innerException) Parameters Type Name Description String message Exception innerException"
  },
  "api/Mirage.IObjectLocator.html": {
    "href": "api/Mirage.IObjectLocator.html",
    "title": "Interface IObjectLocator",
    "keywords": "Interface IObjectLocator An object that implements this interface can find objects by their net id This is used by readers when trying to deserialize gameobjects Namespace : Mirage Assembly : doc.dll Syntax public interface IObjectLocator Properties | Improve this Doc View Source Item[UInt32] Finds a network identity by id Declaration NetworkIdentity this[uint netId] { get; } Parameters Type Name Description UInt32 netId the id of the object to find Property Value Type Description NetworkIdentity The NetworkIdentity matching the netid or null if none is found"
  },
  "api/Mirage.IObjectOwner.html": {
    "href": "api/Mirage.IObjectOwner.html",
    "title": "Interface IObjectOwner",
    "keywords": "Interface IObjectOwner An object that can own networked objects Namespace : Mirage Assembly : doc.dll Syntax public interface IObjectOwner Properties | Improve this Doc View Source Identity Declaration NetworkIdentity Identity { get; set; } Property Value Type Description NetworkIdentity Methods | Improve this Doc View Source AddOwnedObject(NetworkIdentity) Declaration void AddOwnedObject(NetworkIdentity networkIdentity) Parameters Type Name Description NetworkIdentity networkIdentity | Improve this Doc View Source DestroyOwnedObjects() Declaration void DestroyOwnedObjects() | Improve this Doc View Source RemoveOwnedObject(NetworkIdentity) Declaration void RemoveOwnedObject(NetworkIdentity networkIdentity) Parameters Type Name Description NetworkIdentity networkIdentity"
  },
  "api/Mirage.IServerObjectManager.html": {
    "href": "api/Mirage.IServerObjectManager.html",
    "title": "Interface IServerObjectManager",
    "keywords": "Interface IServerObjectManager Namespace : Mirage Assembly : doc.dll Syntax public interface IServerObjectManager Properties | Improve this Doc View Source Spawned Raised when the client spawns an object Declaration SpawnEvent Spawned { get; } Property Value Type Description SpawnEvent | Improve this Doc View Source UnSpawned Raised when the client unspawns an object Declaration SpawnEvent UnSpawned { get; } Property Value Type Description SpawnEvent Methods | Improve this Doc View Source AddPlayerForConnection(INetworkConnection, GameObject) Declaration bool AddPlayerForConnection(INetworkConnection conn, GameObject player) Parameters Type Name Description INetworkConnection conn GameObject player Returns Type Description Boolean | Improve this Doc View Source AddPlayerForConnection(INetworkConnection, GameObject, Guid) Declaration bool AddPlayerForConnection(INetworkConnection conn, GameObject player, Guid assetId) Parameters Type Name Description INetworkConnection conn GameObject player Guid assetId Returns Type Description Boolean | Improve this Doc View Source Destroy(GameObject) Declaration void Destroy(GameObject obj) Parameters Type Name Description GameObject obj | Improve this Doc View Source ReplacePlayerForConnection(INetworkConnection, NetworkClient, GameObject, Guid, Boolean) Declaration bool ReplacePlayerForConnection(INetworkConnection conn, NetworkClient client, GameObject player, Guid assetId, bool keepAuthority = false) Parameters Type Name Description INetworkConnection conn NetworkClient client GameObject player Guid assetId Boolean keepAuthority Returns Type Description Boolean | Improve this Doc View Source ReplacePlayerForConnection(INetworkConnection, NetworkClient, GameObject, Boolean) Declaration bool ReplacePlayerForConnection(INetworkConnection conn, NetworkClient client, GameObject player, bool keepAuthority = false) Parameters Type Name Description INetworkConnection conn NetworkClient client GameObject player Boolean keepAuthority Returns Type Description Boolean | Improve this Doc View Source Spawn(GameObject, GameObject) Declaration void Spawn(GameObject obj, GameObject ownerPlayer) Parameters Type Name Description GameObject obj GameObject ownerPlayer | Improve this Doc View Source Spawn(GameObject, Guid, INetworkConnection) Declaration void Spawn(GameObject obj, Guid assetId, INetworkConnection ownerConnection = null) Parameters Type Name Description GameObject obj Guid assetId INetworkConnection ownerConnection | Improve this Doc View Source Spawn(GameObject, INetworkConnection) Declaration void Spawn(GameObject obj, INetworkConnection ownerConnection = null) Parameters Type Name Description GameObject obj INetworkConnection ownerConnection | Improve this Doc View Source SpawnObjects() Declaration bool SpawnObjects() Returns Type Description Boolean | Improve this Doc View Source UnSpawn(GameObject) Declaration void UnSpawn(GameObject obj) Parameters Type Name Description GameObject obj"
  },
  "api/Mirage.ISyncObject.html": {
    "href": "api/Mirage.ISyncObject.html",
    "title": "Interface ISyncObject",
    "keywords": "Interface ISyncObject A sync object is an object that can synchronize it's state between server and client, such as a SyncList Namespace : Mirage Assembly : doc.dll Syntax public interface ISyncObject Properties | Improve this Doc View Source IsDirty true if there are changes since the last flush Declaration bool IsDirty { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source Flush() Discard all the queued changes Consider the object fully synchronized with clients Declaration void Flush() | Improve this Doc View Source OnDeserializeAll(NetworkReader) Reads a full copy of the object Declaration void OnDeserializeAll(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnDeserializeDelta(NetworkReader) Reads the changes made to the object since last sync Declaration void OnDeserializeDelta(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnSerializeAll(NetworkWriter) Write a full copy of the object Declaration void OnSerializeAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source OnSerializeDelta(NetworkWriter) Write the changes made to the object since last sync Declaration void OnSerializeDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source Reset() Resets the SyncObject so that it can be re-used Declaration void Reset() Events | Improve this Doc View Source OnChange Raised after the list has been updated Note that if there are multiple changes this event is only raised once. Declaration event Action OnChange Event Type Type Description Action"
  },
  "api/Mirage.IVisibilityTracker.html": {
    "href": "api/Mirage.IVisibilityTracker.html",
    "title": "Interface IVisibilityTracker",
    "keywords": "Interface IVisibilityTracker An object that can observe NetworkIdentities. this is useful for interest management Namespace : Mirage Assembly : doc.dll Syntax public interface IVisibilityTracker Methods | Improve this Doc View Source AddToVisList(NetworkIdentity) Declaration void AddToVisList(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity | Improve this Doc View Source RemoveFromVisList(NetworkIdentity) Declaration void RemoveFromVisList(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity | Improve this Doc View Source RemoveObservers() Declaration void RemoveObservers()"
  },
  "api/Mirage.KCP.CommandType.html": {
    "href": "api/Mirage.KCP.CommandType.html",
    "title": "Enum CommandType",
    "keywords": "Enum CommandType Namespace : Mirage.KCP Assembly : doc.dll Syntax public enum CommandType : byte Fields Name Description Ack Push WindowAsk WindowTell"
  },
  "api/Mirage.KCP.HashCash.html": {
    "href": "api/Mirage.KCP.HashCash.html",
    "title": "Struct HashCash",
    "keywords": "Struct HashCash minimalistic hashcash-like token a simplification of the hashcash header described here: https://github.com/cliftonm/hashcash Implements IEquatable < HashCash > Namespace : Mirage.KCP Assembly : doc.dll Syntax public struct HashCash : IEquatable<HashCash> Remarks to make it light weight in the server I adjusted the field to plain numbers Constructors | Improve this Doc View Source HashCash(DateTime, Int32, UInt64, UInt64) Declaration public HashCash(DateTime dt, int resource, ulong salt, ulong counter) Parameters Type Name Description DateTime dt Int32 resource UInt64 salt UInt64 counter | Improve this Doc View Source HashCash(DateTime, String, UInt64, UInt64) Declaration public HashCash(DateTime dt, string resource, ulong salt, ulong counter) Parameters Type Name Description DateTime dt String resource UInt64 salt UInt64 counter Fields | Improve this Doc View Source counter counter used for making the token valid Declaration public readonly ulong counter Field Value Type Description UInt64 | Improve this Doc View Source dt Date and time when the token was generated Declaration public readonly DateTime dt Field Value Type Description DateTime | Improve this Doc View Source resource a number that represents the resource this hashcash is for. In the original they have a string, so just use a string hash here Declaration public readonly int resource Field Value Type Description Int32 | Improve this Doc View Source salt the random number. In the original they have a byte[], but we can limit it to 64 bits Declaration public readonly ulong salt Field Value Type Description UInt64 Methods | Improve this Doc View Source Equals(HashCash) Declaration public bool Equals(HashCash other) Parameters Type Name Description HashCash other Returns Type Description Boolean | Improve this Doc View Source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj Returns Type Description Boolean | Improve this Doc View Source GetHashCode() Declaration public override int GetHashCode() Returns Type Description Int32 | Improve this Doc View Source Mine(String, Int32) Mines a hashcash token for a given resource Declaration public static HashCash Mine(string resource, int bits = 18) Parameters Type Name Description String resource The resource for which we are mining the token the resource can be any number, but should be unique to your game for example, use Application.productName.GetStableHashCode() Int32 bits Returns Type Description HashCash A valid HashCash for the resource | Improve this Doc View Source Validate(String, Int32) Declaration public bool Validate(string resource, int bits = 18) Parameters Type Name Description String resource Int32 bits Returns Type Description Boolean Implements IEquatable<>"
  },
  "api/Mirage.KCP.HashCashEncoding.html": {
    "href": "api/Mirage.KCP.HashCashEncoding.html",
    "title": "Class HashCashEncoding",
    "keywords": "Class HashCashEncoding Inheritance Object HashCashEncoding Namespace : Mirage.KCP Assembly : doc.dll Syntax public static class HashCashEncoding : object Fields | Improve this Doc View Source SIZE Declaration public const int SIZE = null Field Value Type Description Int32 Methods | Improve this Doc View Source Decode(Byte[], Int32) Encode a hashcash token into a buffer Declaration public static HashCash Decode(byte[] buffer, int index) Parameters Type Name Description Byte [] buffer the buffer where to store the hashcash Int32 index the index in the buffer where to put it Returns Type Description HashCash the length of the written data | Improve this Doc View Source Encode(Byte[], Int32, HashCash) Encode a hashcash token into a buffer Declaration public static int Encode(byte[] buffer, int index, HashCash hashCash) Parameters Type Name Description Byte [] buffer the buffer where to store the hashcash Int32 index the index in the buffer where to put it HashCash hashCash the token to be encoded Returns Type Description Int32 the length of the written data"
  },
  "api/Mirage.KCP.html": {
    "href": "api/Mirage.KCP.html",
    "title": "Namespace Mirage.KCP",
    "keywords": "Namespace Mirage.KCP Classes HashCashEncoding IPEndpointComparer Kcp A reliability algorithm over an unreliable transport such as UDP. based on https://github.com/skywind3000/kcp KcpClientConnection KcpConnection KcpServerConnection KcpTransport Unreliable Manages unreliable channel Utils Structs HashCash minimalistic hashcash-like token a simplification of the hashcash header described here: https://github.com/cliftonm/hashcash Enums CommandType KcpDelayMode"
  },
  "api/Mirage.KCP.IPEndpointComparer.html": {
    "href": "api/Mirage.KCP.IPEndpointComparer.html",
    "title": "Class IPEndpointComparer",
    "keywords": "Class IPEndpointComparer Inheritance Object IPEndpointComparer Namespace : Mirage.KCP Assembly : doc.dll Syntax public class IPEndpointComparer : IEqualityComparer<IPEndPoint> Methods | Improve this Doc View Source Equals(IPEndPoint, IPEndPoint) Declaration public bool Equals(IPEndPoint x, IPEndPoint y) Parameters Type Name Description IPEndPoint x IPEndPoint y Returns Type Description Boolean | Improve this Doc View Source GetHashCode(IPEndPoint) Declaration public int GetHashCode(IPEndPoint obj) Parameters Type Name Description IPEndPoint obj Returns Type Description Int32"
  },
  "api/Mirage.KCP.Kcp.html": {
    "href": "api/Mirage.KCP.Kcp.html",
    "title": "Class Kcp",
    "keywords": "Class Kcp A reliability algorithm over an unreliable transport such as UDP. based on https://github.com/skywind3000/kcp Inheritance Object Kcp Namespace : Mirage.KCP Assembly : doc.dll Syntax public class Kcp : object Constructors | Improve this Doc View Source Kcp(UInt32, Action<Byte[], Int32>) create a new kcp control object, 'conv' must equal in two endpoint from the same connection. Declaration public Kcp(uint conv, Action<byte[], int> output) Parameters Type Name Description UInt32 conv a number that must match between two endpoints Action < Byte [], Int32 > output a delegate to use when sending data Fields | Improve this Doc View Source ASK_SEND Declaration public const int ASK_SEND = null Field Value Type Description Int32 | Improve this Doc View Source ASK_TELL Declaration public const int ASK_TELL = null Field Value Type Description Int32 | Improve this Doc View Source INTERVAL Declaration public const int INTERVAL = null Field Value Type Description Int32 | Improve this Doc View Source OVERHEAD Declaration public const int OVERHEAD = null Field Value Type Description Int32 | Improve this Doc View Source PROBE_INIT Declaration public const int PROBE_INIT = null Field Value Type Description Int32 | Improve this Doc View Source PROBE_LIMIT Declaration public const int PROBE_LIMIT = null Field Value Type Description Int32 | Improve this Doc View Source RTO_MAX Declaration public const int RTO_MAX = null Field Value Type Description Int32 | Improve this Doc View Source RTO_MIN Declaration public const int RTO_MIN = null Field Value Type Description Int32 | Improve this Doc View Source RTO_NDL Declaration public const int RTO_NDL = null Field Value Type Description Int32 | Improve this Doc View Source THRESH_INIT Declaration public const int THRESH_INIT = null Field Value Type Description Int32 | Improve this Doc View Source THRESH_MIN Declaration public const int THRESH_MIN = null Field Value Type Description Int32 | Improve this Doc View Source WND_RCV Declaration public const int WND_RCV = null Field Value Type Description Int32 Properties | Improve this Doc View Source Mtu Declaration public uint Mtu { get; set; } Property Value Type Description UInt32 | Improve this Doc View Source Reserved How many bytes to reserve at beginning of a packet the extra bytes can be used to store a CRC or other information Declaration public int Reserved { get; set; } Property Value Type Description Int32 | Improve this Doc View Source WaitSnd Declaration public int WaitSnd { get; } Property Value Type Description Int32 Methods | Improve this Doc View Source Check(UInt32) Declaration public uint Check(uint current_) Parameters Type Name Description UInt32 current_ Returns Type Description UInt32 | Improve this Doc View Source Flush() Declaration public void Flush() | Improve this Doc View Source Input(Byte[], Int32) Declaration public int Input(byte[] data, int size) Parameters Type Name Description Byte [] data Int32 size Returns Type Description Int32 | Improve this Doc View Source PeekSize() Declaration public int PeekSize() Returns Type Description Int32 | Improve this Doc View Source Receive(Byte[]) receive data from kcp state machine Declaration public int Receive(byte[] buffer) Parameters Type Name Description Byte [] buffer buffer where the data will be stored Returns Type Description Int32 number of read bytes | Improve this Doc View Source Send(Byte[], Int32, Int32) Declaration public void Send(byte[] buffer, int offset, int length) Parameters Type Name Description Byte [] buffer Int32 offset Int32 length | Improve this Doc View Source SetInterval(Int32) Declaration public void SetInterval(int interval) Parameters Type Name Description Int32 interval | Improve this Doc View Source SetNoDelay(KcpDelayMode) Convenience method to configure KCP for well known configurations Declaration public void SetNoDelay(KcpDelayMode mode) Parameters Type Name Description KcpDelayMode mode | Improve this Doc View Source SetNoDelay(Boolean, Int32, Int32, Boolean) Declaration public void SetNoDelay(bool nodelay = false, int interval = null, int resend = 0, bool nocwnd = false) Parameters Type Name Description Boolean nodelay Int32 interval Int32 resend Boolean nocwnd | Improve this Doc View Source SetWindowSize(UInt32, UInt32) Declaration public void SetWindowSize(uint sendWindow, uint receiveWindow) Parameters Type Name Description UInt32 sendWindow UInt32 receiveWindow | Improve this Doc View Source Update(UInt32) Declaration public void Update(uint currentTimeMilliSeconds) Parameters Type Name Description UInt32 currentTimeMilliSeconds"
  },
  "api/Mirage.KCP.KcpClientConnection.html": {
    "href": "api/Mirage.KCP.KcpClientConnection.html",
    "title": "Class KcpClientConnection",
    "keywords": "Class KcpClientConnection Inheritance Object KcpConnection KcpClientConnection Implements IConnection Inherited Members KcpConnection.socket KcpConnection.remoteEndpoint KcpConnection.kcp KcpConnection.unreliable KcpConnection.CHANNEL_SIZE KcpConnection.Timeout KcpConnection.RESERVED KcpConnection.SetupKcp() KcpConnection.SendAsync(ArraySegment<Byte>, Int32) KcpConnection.ReceiveAsync(MemoryStream) KcpConnection.Disconnect() KcpConnection.GetEndPointAddress() KcpConnection.GetChannel(Byte[]) Namespace : Mirage.KCP Assembly : doc.dll Syntax public class KcpClientConnection : KcpConnection, IConnection Constructors | Improve this Doc View Source KcpClientConnection(KcpDelayMode, Int32, Int32) Client connection, does not share the UDP client with anyone so we can set up our own read loop Declaration public KcpClientConnection(KcpDelayMode delayMode, int sendWindowSize, int receiveWindowSize) Parameters Type Name Description KcpDelayMode delayMode Int32 sendWindowSize Int32 receiveWindowSize Properties | Improve this Doc View Source HashCashBits Declaration public int HashCashBits { get; set; } Property Value Type Description Int32 Methods | Improve this Doc View Source Close() Declaration protected override void Close() Overrides KcpConnection.Close() | Improve this Doc View Source HandshakeAsync(Int32) Declaration protected UniTask HandshakeAsync(int bits) Parameters Type Name Description Int32 bits Returns Type Description UniTask | Improve this Doc View Source RawSend(Byte[], Int32) Declaration protected override void RawSend(byte[] data, int length) Parameters Type Name Description Byte [] data Int32 length Overrides KcpConnection.RawSend(Byte[], Int32) Implements IConnection"
  },
  "api/Mirage.KCP.KcpConnection.html": {
    "href": "api/Mirage.KCP.KcpConnection.html",
    "title": "Class KcpConnection",
    "keywords": "Class KcpConnection Inheritance Object KcpConnection KcpClientConnection KcpServerConnection Implements IConnection Namespace : Mirage.KCP Assembly : doc.dll Syntax public abstract class KcpConnection : object, IConnection Constructors | Improve this Doc View Source KcpConnection(KcpDelayMode, Int32, Int32) Declaration protected KcpConnection(KcpDelayMode delayMode, int sendWindowSize, int receiveWindowSize) Parameters Type Name Description KcpDelayMode delayMode Int32 sendWindowSize Int32 receiveWindowSize Fields | Improve this Doc View Source CHANNEL_SIZE Declaration public int CHANNEL_SIZE Field Value Type Description Int32 | Improve this Doc View Source kcp Declaration protected Kcp kcp Field Value Type Description Kcp | Improve this Doc View Source remoteEndpoint Declaration protected EndPoint remoteEndpoint Field Value Type Description EndPoint | Improve this Doc View Source RESERVED Space for CRC64 Declaration public const int RESERVED = null Field Value Type Description Int32 | Improve this Doc View Source socket Declaration protected Socket socket Field Value Type Description Socket | Improve this Doc View Source unreliable Declaration protected Unreliable unreliable Field Value Type Description Unreliable Properties | Improve this Doc View Source Timeout Declaration public int Timeout { get; set; } Property Value Type Description Int32 Methods | Improve this Doc View Source Close() Declaration protected virtual void Close() | Improve this Doc View Source Disconnect() Disconnect this connection Declaration public virtual void Disconnect() | Improve this Doc View Source GetChannel(Byte[]) Declaration public static int GetChannel(byte[] data) Parameters Type Name Description Byte [] data Returns Type Description Int32 | Improve this Doc View Source GetEndPointAddress() the address of endpoint we are connected to Note this can be IPEndPoint or a custom implementation of EndPoint, which depends on the transport Declaration public EndPoint GetEndPointAddress() Returns Type Description EndPoint | Improve this Doc View Source RawSend(Byte[], Int32) Declaration protected abstract void RawSend(byte[] data, int length) Parameters Type Name Description Byte [] data Int32 length | Improve this Doc View Source ReceiveAsync(MemoryStream) reads a message from connection Declaration public UniTask<int> ReceiveAsync(MemoryStream buffer) Parameters Type Name Description MemoryStream buffer buffer where the message will be written Returns Type Description UniTask < Int32 > true if we got a message, false if we got disconnected | Improve this Doc View Source SendAsync(ArraySegment<Byte>, Int32) Declaration public UniTask SendAsync(ArraySegment<byte> data, int channel = null) Parameters Type Name Description ArraySegment < Byte > data Int32 channel Returns Type Description UniTask | Improve this Doc View Source SetupKcp() Declaration protected void SetupKcp() Implements IConnection"
  },
  "api/Mirage.KCP.KcpDelayMode.html": {
    "href": "api/Mirage.KCP.KcpDelayMode.html",
    "title": "Enum KcpDelayMode",
    "keywords": "Enum KcpDelayMode Namespace : Mirage.KCP Assembly : doc.dll Syntax public enum KcpDelayMode : int Fields Name Description Fast No Delay Off, 30ms rate, No Fast Resend, Congestion Window Fast2 No Delay ON, 20ms rate, No Fast Resend, Congestion Window Fast3 No Delay ON, 10ms rate, No Fast Resend, Congestion Window Normal No Delay Off, 40ms rate, No Fast Resend, No Congestion Window"
  },
  "api/Mirage.KCP.KcpServerConnection.html": {
    "href": "api/Mirage.KCP.KcpServerConnection.html",
    "title": "Class KcpServerConnection",
    "keywords": "Class KcpServerConnection Inheritance Object KcpConnection KcpServerConnection Implements IConnection Inherited Members KcpConnection.socket KcpConnection.remoteEndpoint KcpConnection.kcp KcpConnection.unreliable KcpConnection.CHANNEL_SIZE KcpConnection.Timeout KcpConnection.RESERVED KcpConnection.SetupKcp() KcpConnection.Close() KcpConnection.SendAsync(ArraySegment<Byte>, Int32) KcpConnection.ReceiveAsync(MemoryStream) KcpConnection.Disconnect() KcpConnection.GetEndPointAddress() KcpConnection.GetChannel(Byte[]) Namespace : Mirage.KCP Assembly : doc.dll Syntax public class KcpServerConnection : KcpConnection, IConnection Constructors | Improve this Doc View Source KcpServerConnection(Socket, EndPoint, KcpDelayMode, Int32, Int32) Declaration public KcpServerConnection(Socket socket, EndPoint remoteEndpoint, KcpDelayMode delayMode, int sendWindowSize, int receiveWindowSize) Parameters Type Name Description Socket socket EndPoint remoteEndpoint KcpDelayMode delayMode Int32 sendWindowSize Int32 receiveWindowSize Methods | Improve this Doc View Source RawSend(Byte[], Int32) Declaration protected override void RawSend(byte[] data, int length) Parameters Type Name Description Byte [] data Int32 length Overrides KcpConnection.RawSend(Byte[], Int32) Implements IConnection"
  },
  "api/Mirage.KCP.KcpTransport.html": {
    "href": "api/Mirage.KCP.KcpTransport.html",
    "title": "Class KcpTransport",
    "keywords": "Class KcpTransport Inheritance Object Transport KcpTransport Inherited Members Transport.Connected Transport.Started Namespace : Mirage.KCP Assembly : doc.dll Syntax public class KcpTransport : Transport Fields | Improve this Doc View Source delayMode Declaration public KcpDelayMode delayMode Field Value Type Description KcpDelayMode | Improve this Doc View Source HashCashBits Declaration public int HashCashBits Field Value Type Description Int32 | Improve this Doc View Source Port Declaration public ushort Port Field Value Type Description UInt16 | Improve this Doc View Source ReceiveWindowSize Declaration public int ReceiveWindowSize Field Value Type Description Int32 | Improve this Doc View Source SendWindowSize Declaration public int SendWindowSize Field Value Type Description Int32 Properties | Improve this Doc View Source ReceivedBytes Declaration public override long ReceivedBytes { get; } Property Value Type Description Int64 Overrides Transport.ReceivedBytes | Improve this Doc View Source ReceivedMessageCount Declaration public long ReceivedMessageCount { get; } Property Value Type Description Int64 | Improve this Doc View Source Scheme Declaration public override IEnumerable<string> Scheme { get; } Property Value Type Description IEnumerable < String > Overrides Transport.Scheme | Improve this Doc View Source SentBytes Declaration public override long SentBytes { get; } Property Value Type Description Int64 Overrides Transport.SentBytes | Improve this Doc View Source Supported Determines if this transport is supported in the current platform Declaration public override bool Supported { get; } Property Value Type Description Boolean true if the transport works in this platform Overrides Transport.Supported Methods | Improve this Doc View Source ConnectAsync(Uri) Connect to a server located at a provided uri Declaration public override UniTask<IConnection> ConnectAsync(Uri uri) Parameters Type Name Description Uri uri address of the server to connect to Returns Type Description UniTask < IConnection > The connection to the server Overrides Transport.ConnectAsync(Uri) | Improve this Doc View Source Disconnect() Stop listening to the port Declaration public override void Disconnect() Overrides Transport.Disconnect() | Improve this Doc View Source ListenAsync() Open up the port and listen for connections Use in servers. Declaration public override UniTask ListenAsync() Returns Type Description UniTask Overrides Transport.ListenAsync() | Improve this Doc View Source ServerUri() Retrieves the address of this server. Useful for network discovery Declaration public override IEnumerable<Uri> ServerUri() Returns Type Description IEnumerable < Uri > the url at which this server can be reached Overrides Transport.ServerUri() | Improve this Doc View Source Update() Declaration public void Update()"
  },
  "api/Mirage.KCP.Unreliable.html": {
    "href": "api/Mirage.KCP.Unreliable.html",
    "title": "Class Unreliable",
    "keywords": "Class Unreliable Manages unreliable channel Inheritance Object Unreliable Namespace : Mirage.KCP Assembly : doc.dll Syntax public class Unreliable : object Constructors | Improve this Doc View Source Unreliable(Action<Byte[], Int32>) Declaration public Unreliable(Action<byte[], int> output_) Parameters Type Name Description Action < Byte [], Int32 > output_ Fields | Improve this Doc View Source OVERHEAD Declaration public const int OVERHEAD = null Field Value Type Description Int32 Properties | Improve this Doc View Source Reserved Declaration public int Reserved { get; set; } Property Value Type Description Int32 Methods | Improve this Doc View Source Input(Byte[], Int32) Input Used when you receive a low level packet (eg. UDP packet) Returns int (-3, -1, or 0) Declaration public int Input(byte[] data, int size) Parameters Type Name Description Byte [] data Int32 size Returns Type Description Int32 | Improve this Doc View Source PeekSize() Declaration public int PeekSize() Returns Type Description Int32 | Improve this Doc View Source Receive(Byte[], Int32) Receive Receive data from kcp state machine Return number of bytes read. Return -1 when there is no readable data. Return -2 if len(buffer) is smaller than kcp.PeekSize(). Declaration public int Receive(byte[] buffer, int length) Parameters Type Name Description Byte [] buffer Int32 length Returns Type Description Int32 | Improve this Doc View Source Send(Byte[], Int32, Int32) Declaration public void Send(byte[] buffer, int offset, int length) Parameters Type Name Description Byte [] buffer Int32 offset Int32 length"
  },
  "api/Mirage.KCP.Utils.html": {
    "href": "api/Mirage.KCP.Utils.html",
    "title": "Class Utils",
    "keywords": "Class Utils Inheritance Object Utils Namespace : Mirage.KCP Assembly : doc.dll Syntax public static class Utils : object Methods | Improve this Doc View Source Clamp(Int32, Int32, Int32) Declaration public static int Clamp(int value, int lower, int upper) Parameters Type Name Description Int32 value Int32 lower Int32 upper Returns Type Description Int32 | Improve this Doc View Source Equal(ArraySegment<Byte>, ArraySegment<Byte>) Declaration public static bool Equal(ArraySegment<byte> seg1, ArraySegment<byte> seg2) Parameters Type Name Description ArraySegment < Byte > seg1 ArraySegment < Byte > seg2 Returns Type Description Boolean"
  },
  "api/Mirage.LobbyReady.html": {
    "href": "api/Mirage.LobbyReady.html",
    "title": "Class LobbyReady",
    "keywords": "Class LobbyReady Inheritance Object LobbyReady Namespace : Mirage Assembly : doc.dll Syntax public class LobbyReady : MonoBehaviour Fields | Improve this Doc View Source ObjectReadyList Declaration public List<ObjectReady> ObjectReadyList Field Value Type Description List < ObjectReady > Methods | Improve this Doc View Source SendToReady<T>(NetworkIdentity, T, Boolean, Int32) Declaration public void SendToReady<T>(NetworkIdentity identity, T msg, bool includeOwner = true, int channelId = null) Parameters Type Name Description NetworkIdentity identity T msg Boolean includeOwner Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SetAllClientsNotReady() Declaration public void SetAllClientsNotReady()"
  },
  "api/Mirage.LocalPlayerAttribute.html": {
    "href": "api/Mirage.LocalPlayerAttribute.html",
    "title": "Class LocalPlayerAttribute",
    "keywords": "Class LocalPlayerAttribute Prevents nonlocal players from running this method. Inheritance Object LocalPlayerAttribute Namespace : Mirage Assembly : doc.dll Syntax public class LocalPlayerAttribute : Attribute Fields | Improve this Doc View Source error If true, when the method is called from a client, it throws an error If false, no error is thrown, but the method won't execute useful for unity built in methods such as Await, Update, Start, etc. Declaration public bool error Field Value Type Description Boolean"
  },
  "api/Mirage.LogFactory.html": {
    "href": "api/Mirage.LogFactory.html",
    "title": "Class LogFactory",
    "keywords": "Class LogFactory Inheritance Object LogFactory Namespace : Mirage Assembly : doc.dll Syntax public static class LogFactory : object Methods | Improve this Doc View Source GetLogger(String, LogType) Declaration public static ILogger GetLogger(string loggerName, LogType defaultLogLevel = null) Parameters Type Name Description String loggerName LogType defaultLogLevel Returns Type Description ILogger | Improve this Doc View Source GetLogger(System.Type, LogType) Declaration public static ILogger GetLogger(System.Type type, LogType defaultLogLevel = null) Parameters Type Name Description System.Type type LogType defaultLogLevel Returns Type Description ILogger | Improve this Doc View Source GetLogger<T>(LogType) Declaration public static ILogger GetLogger<T>(LogType defaultLogLevel = null) Parameters Type Name Description LogType defaultLogLevel Returns Type Description ILogger Type Parameters Name Description T"
  },
  "api/Mirage.LogSettings.html": {
    "href": "api/Mirage.LogSettings.html",
    "title": "Class LogSettings",
    "keywords": "Class LogSettings Inheritance Object LogSettings Namespace : Mirage Assembly : doc.dll Syntax public class LogSettings : MonoBehaviour Fields | Improve this Doc View Source Levels Declaration public List<LogSettings.Level> Levels Field Value Type Description List < LogSettings.Level > Methods | Improve this Doc View Source SetLogLevels() Declaration public void SetLogLevels()"
  },
  "api/Mirage.LogSettings.Level.html": {
    "href": "api/Mirage.LogSettings.Level.html",
    "title": "Struct LogSettings.Level",
    "keywords": "Struct LogSettings.Level Namespace : Mirage Assembly : doc.dll Syntax public struct Level Fields | Improve this Doc View Source level Declaration public LogType level Field Value Type Description LogType | Improve this Doc View Source Name Declaration public string Name Field Value Type Description String"
  },
  "api/Mirage.MessagePacker.html": {
    "href": "api/Mirage.MessagePacker.html",
    "title": "Class MessagePacker",
    "keywords": "Class MessagePacker Inheritance Object MessagePacker Namespace : Mirage Assembly : doc.dll Syntax public static class MessagePacker : object Methods | Improve this Doc View Source GetId(Type) Declaration public static int GetId(Type type) Parameters Type Name Description Type type Returns Type Description Int32 | Improve this Doc View Source GetId<T>() Declaration public static int GetId<T>() Returns Type Description Int32 Type Parameters Name Description T | Improve this Doc View Source GetMessageType(Int32) Declaration public static Type GetMessageType(int id) Parameters Type Name Description Int32 id Returns Type Description Type | Improve this Doc View Source Pack<T>(T) Declaration public static byte[] Pack<T>(T message) Parameters Type Name Description T message Returns Type Description Byte [] Type Parameters Name Description T | Improve this Doc View Source Pack<T>(T, NetworkWriter) Declaration public static void Pack<T>(T message, NetworkWriter writer) Parameters Type Name Description T message NetworkWriter writer Type Parameters Name Description T | Improve this Doc View Source RegisterMessage<T>() Declaration public static void RegisterMessage<T>() Type Parameters Name Description T | Improve this Doc View Source Unpack<T>(Byte[]) Declaration public static T Unpack<T>(byte[] data) Parameters Type Name Description Byte [] data Returns Type Description T Type Parameters Name Description T | Improve this Doc View Source UnpackId(NetworkReader) Declaration public static int UnpackId(NetworkReader messageReader) Parameters Type Name Description NetworkReader messageReader Returns Type Description Int32"
  },
  "api/Mirage.MethodInvocationException.html": {
    "href": "api/Mirage.MethodInvocationException.html",
    "title": "Class MethodInvocationException",
    "keywords": "Class MethodInvocationException Exception thrown if a guarded method is invoked incorrectly Inheritance Object MethodInvocationException Namespace : Mirage Assembly : doc.dll Syntax public class MethodInvocationException : Exception Constructors | Improve this Doc View Source MethodInvocationException() Initializes a new instance of the MethodInvocationException class Declaration public MethodInvocationException() | Improve this Doc View Source MethodInvocationException(SerializationInfo, StreamingContext) Declaration protected MethodInvocationException(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source MethodInvocationException(String) Initializes a new instance of the MethodInvocationException class Declaration public MethodInvocationException(string message) Parameters Type Name Description String message A String that describes the exception."
  },
  "api/Mirage.MirageInvokeType.html": {
    "href": "api/Mirage.MirageInvokeType.html",
    "title": "Enum MirageInvokeType",
    "keywords": "Enum MirageInvokeType Namespace : Mirage Assembly : doc.dll Syntax public enum MirageInvokeType : int Fields Name Description ClientRpc ServerRpc"
  },
  "api/Mirage.MultiplexTransport.html": {
    "href": "api/Mirage.MultiplexTransport.html",
    "title": "Class MultiplexTransport",
    "keywords": "Class MultiplexTransport Inheritance Object Transport MultiplexTransport Inherited Members Transport.Connected Transport.Started Transport.ReceivedBytes Transport.SentBytes Namespace : Mirage Assembly : doc.dll Syntax public class MultiplexTransport : Transport Fields | Improve this Doc View Source transports Declaration public Transport[] transports Field Value Type Description Transport [] Properties | Improve this Doc View Source Scheme Declaration public override IEnumerable<string> Scheme { get; } Property Value Type Description IEnumerable < String > Overrides Transport.Scheme | Improve this Doc View Source Supported Declaration public override bool Supported { get; } Property Value Type Description Boolean Overrides Transport.Supported Methods | Improve this Doc View Source ConnectAsync(Uri) Declaration public override UniTask<IConnection> ConnectAsync(Uri uri) Parameters Type Name Description Uri uri Returns Type Description UniTask < IConnection > Overrides Transport.ConnectAsync(Uri) | Improve this Doc View Source Disconnect() Declaration public override void Disconnect() Overrides Transport.Disconnect() | Improve this Doc View Source ListenAsync() Declaration public override UniTask ListenAsync() Returns Type Description UniTask Overrides Transport.ListenAsync() | Improve this Doc View Source ServerUri() Declaration public override IEnumerable<Uri> ServerUri() Returns Type Description IEnumerable < Uri > Overrides Transport.ServerUri() | Improve this Doc View Source Start() Declaration public void Start()"
  },
  "api/Mirage.NetworkAnimator.html": {
    "href": "api/Mirage.NetworkAnimator.html",
    "title": "Class NetworkAnimator",
    "keywords": "Class NetworkAnimator A component to synchronize Mecanim animation states for networked objects. Inheritance Object NetworkBehaviour NetworkAnimator Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage Assembly : doc.dll Syntax public class NetworkAnimator : NetworkBehaviour Remarks The animation of game objects can be networked by this component. There are two models of authority for networked movement: If the object has authority on the client, then it should be animated locally on the owning client. The animation state information will be sent from the owning client to the server, then broadcast to all of the other clients. This is common for player objects. If the object has authority on the server, then it should be animated on the server and state information will be sent to all clients. This is common for objects not related to a specific client, such as an enemy unit. The NetworkAnimator synchronizes all animation parameters of the selected Animator. It does not automatically sychronize triggers. The function SetTrigger can by used by an object with authority to fire an animation trigger on other clients. Fields | Improve this Doc View Source Animator The animator component to synchronize. Declaration public Animator Animator Field Value Type Description Animator | Improve this Doc View Source ClientAuthority Declaration public bool ClientAuthority Field Value Type Description Boolean Methods | Improve this Doc View Source OnDeserialize(NetworkReader, Boolean) Custom Deserialization Declaration public override void OnDeserialize(NetworkReader reader, bool initialState) Parameters Type Name Description NetworkReader reader Boolean initialState Overrides NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) | Improve this Doc View Source OnSerialize(NetworkWriter, Boolean) Custom Serialization Declaration public override bool OnSerialize(NetworkWriter writer, bool initialState) Parameters Type Name Description NetworkWriter writer Boolean initialState Returns Type Description Boolean Overrides NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) | Improve this Doc View Source ResetTrigger(Int32) Causes an animation trigger to be reset for a networked object. Declaration public void ResetTrigger(int hash) Parameters Type Name Description Int32 hash Hash id of trigger (from the Animator). | Improve this Doc View Source ResetTrigger(String) Causes an animation trigger to be reset for a networked object. If local authority is set, and this is called from the client, then the trigger will be reset on the server and all clients. If not, then this is called on the server, and the trigger will be reset on all clients. Declaration public void ResetTrigger(string triggerName) Parameters Type Name Description String triggerName Name of trigger. | Improve this Doc View Source SetTrigger(Int32) Causes an animation trigger to be invoked for a networked object. Declaration public void SetTrigger(int hash) Parameters Type Name Description Int32 hash Hash id of trigger (from the Animator). | Improve this Doc View Source SetTrigger(String) Causes an animation trigger to be invoked for a networked object. If local authority is set, and this is called from the client, then the trigger will be invoked on the server and all clients. If not, then this is called on the server, and the trigger will be called on all clients. Declaration public void SetTrigger(string triggerName) Parameters Type Name Description String triggerName Name of trigger."
  },
  "api/Mirage.NetworkAuthenticator.html": {
    "href": "api/Mirage.NetworkAuthenticator.html",
    "title": "Class NetworkAuthenticator",
    "keywords": "Class NetworkAuthenticator Base class for implementing component-based authentication during the Connect phase Inheritance Object NetworkAuthenticator Namespace : Mirage Assembly : doc.dll Syntax public abstract class NetworkAuthenticator : MonoBehaviour Methods | Improve this Doc View Source OnClientAuthenticate(INetworkConnection) Called on client from OnClientAuthenticateInternal when a client needs to authenticate Declaration public virtual void OnClientAuthenticate(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Connection of the client. | Improve this Doc View Source OnServerAuthenticate(INetworkConnection) Called on server from OnServerAuthenticateInternal when a client needs to authenticate Declaration public virtual void OnServerAuthenticate(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Connection to client. Events | Improve this Doc View Source OnClientAuthenticated Notify subscribers on the client when the client is authenticated Declaration public event Action<INetworkConnection> OnClientAuthenticated Event Type Type Description Action < INetworkConnection > | Improve this Doc View Source OnServerAuthenticated Notify subscribers on the server when a client is authenticated Declaration public event Action<INetworkConnection> OnServerAuthenticated Event Type Type Description Action < INetworkConnection >"
  },
  "api/Mirage.NetworkBehaviorSerializers.html": {
    "href": "api/Mirage.NetworkBehaviorSerializers.html",
    "title": "Class NetworkBehaviorSerializers",
    "keywords": "Class NetworkBehaviorSerializers Inheritance Object NetworkBehaviorSerializers Namespace : Mirage Assembly : doc.dll Syntax public static class NetworkBehaviorSerializers : object Methods | Improve this Doc View Source ReadNetworkBehaviourSyncVar(NetworkReader) Declaration public static NetworkBehaviorSyncvar ReadNetworkBehaviourSyncVar(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description NetworkBehaviorSyncvar | Improve this Doc View Source WriteNetworkBehaviorSyncVar(NetworkWriter, NetworkBehaviorSyncvar) Declaration public static void WriteNetworkBehaviorSyncVar(this NetworkWriter writer, NetworkBehaviorSyncvar id) Parameters Type Name Description NetworkWriter writer NetworkBehaviorSyncvar id"
  },
  "api/Mirage.NetworkBehaviorSyncvar.html": {
    "href": "api/Mirage.NetworkBehaviorSyncvar.html",
    "title": "Struct NetworkBehaviorSyncvar",
    "keywords": "Struct NetworkBehaviorSyncvar backing struct for a NetworkIdentity when used as a syncvar the weaver will replace the syncvar with this struct. Namespace : Mirage Assembly : doc.dll Syntax public struct NetworkBehaviorSyncvar Properties | Improve this Doc View Source Value Declaration public NetworkBehaviour Value { get; set; } Property Value Type Description NetworkBehaviour"
  },
  "api/Mirage.NetworkBehaviour.html": {
    "href": "api/Mirage.NetworkBehaviour.html",
    "title": "Class NetworkBehaviour",
    "keywords": "Class NetworkBehaviour Base class which should be inherited by scripts which contain networking functionality. Inheritance Object NetworkBehaviour NetworkLerpRigidbody NetworkRigidbody NetworkTransformBase NetworkAnimator NetworkTransformBase NetworkVisibility ObjectReady Namespace : Mirage Assembly : doc.dll Syntax public abstract class NetworkBehaviour : MonoBehaviour Remarks This is a MonoBehaviour class so scripts which need to use the networking feature should inherit this class instead of MonoBehaviour. It allows you to invoke networked actions, receive various callbacks, and automatically synchronize state from server-to-client. The NetworkBehaviour component requires a NetworkIdentity on the game object. There can be multiple NetworkBehaviours on a single game object. For an object with sub-components in a hierarchy, the NetworkIdentity must be on the root object, and NetworkBehaviour scripts must also be on the root object. Some of the built-in components of the networking system are derived from NetworkBehaviour, including NetworkTransport, NetworkAnimator and NetworkProximityChecker. Fields | Improve this Doc View Source syncInterval sync interval for OnSerialize (in seconds) Declaration public float syncInterval Field Value Type Description Single | Improve this Doc View Source syncMode sync mode for OnSerialize Declaration public SyncMode syncMode Field Value Type Description SyncMode | Improve this Doc View Source syncObjects objects that can synchronize themselves, such as synclists Declaration protected readonly List<ISyncObject> syncObjects Field Value Type Description List < ISyncObject > Properties | Improve this Doc View Source Client The NetworkClient associated to this object. Declaration public NetworkClient Client { get; } Property Value Type Description NetworkClient | Improve this Doc View Source ClientObjectManager Quick Reference to the NetworkIdentities ClientObjectManager. Present only for instances instances. Declaration public ClientObjectManager ClientObjectManager { get; } Property Value Type Description ClientObjectManager | Improve this Doc View Source ComponentIndex Returns the index of the component on this object Declaration public int ComponentIndex { get; } Property Value Type Description Int32 | Improve this Doc View Source ConnectionToClient The NetworkConnection associated with this NetworkIdentity This is only valid for player objects on the server. Declaration public INetworkConnection ConnectionToClient { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source ConnectionToServer The NetworkConnection associated with this NetworkIdentity This is only valid for player objects on the client. Declaration public INetworkConnection ConnectionToServer { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source HasAuthority This returns true if this object is the authoritative version of the object in the distributed network application. The HasAuthority value on the NetworkIdentity determines how authority is determined. For most objects, authority is held by the server. For objects with HasAuthority set, authority is held by the client of that player. Declaration public bool HasAuthority { get; } Property Value Type Description Boolean | Improve this Doc View Source IsClient Returns true if running as a client and this object was spawned by a server. Declaration public bool IsClient { get; } Property Value Type Description Boolean | Improve this Doc View Source IsClientOnly True if this object exists on a client that is not also acting as a server Declaration public bool IsClientOnly { get; } Property Value Type Description Boolean | Improve this Doc View Source IsLocalClient Returns true if we're on host mode. Declaration public bool IsLocalClient { get; } Property Value Type Description Boolean | Improve this Doc View Source IsLocalPlayer This returns true if this object is the one that represents the player on the local machine. In multiplayer games, there are multiple instances of the Player object. The client needs to know which one is for \"themselves\" so that only that player processes input and potentially has a camera attached. The IsLocalPlayer function will return true only for the player instance that belongs to the player on the local machine, so it can be used to filter out input for non-local players. Declaration public bool IsLocalPlayer { get; } Property Value Type Description Boolean | Improve this Doc View Source IsServer Returns true if this object is active on an active server. This is only true if the object has been spawned. This is different from NetworkServer.active, which is true if the server itself is active rather than this object being active. Declaration public bool IsServer { get; } Property Value Type Description Boolean | Improve this Doc View Source IsServerOnly True if this object only exists on the server Declaration public bool IsServerOnly { get; } Property Value Type Description Boolean | Improve this Doc View Source NetId The unique network Id of this object. This is assigned at runtime by the network server and will be unique for all objects for that network session. Declaration public uint NetId { get; } Property Value Type Description UInt32 | Improve this Doc View Source NetIdentity Returns the NetworkIdentity of this object Declaration public NetworkIdentity NetIdentity { get; } Property Value Type Description NetworkIdentity | Improve this Doc View Source NetworkTime Returns the appropriate NetworkTime instance based on if this NetworkBehaviour is running as a Server or Client. Declaration public NetworkTime NetworkTime { get; } Property Value Type Description NetworkTime | Improve this Doc View Source Server The NetworkServer associated to this object. Declaration public NetworkServer Server { get; } Property Value Type Description NetworkServer | Improve this Doc View Source ServerObjectManager Quick Reference to the NetworkIdentities ServerObjectManager. Present only for server/host instances. Declaration public ServerObjectManager ServerObjectManager { get; } Property Value Type Description ServerObjectManager | Improve this Doc View Source SyncVarDirtyBits Declaration protected ulong SyncVarDirtyBits { get; } Property Value Type Description UInt64 Methods | Improve this Doc View Source ClearAllDirtyBits() This clears all the dirty bits that were set on this script by SetDirtyBits(); This is automatically invoked when an update is sent for this object, but can be called manually as well. Declaration public void ClearAllDirtyBits() | Improve this Doc View Source DeserializeSyncVars(NetworkReader, Boolean) Declaration public virtual void DeserializeSyncVars(NetworkReader reader, bool initialState) Parameters Type Name Description NetworkReader reader Boolean initialState | Improve this Doc View Source GetSyncVarHookGuard(UInt64) Declaration protected bool GetSyncVarHookGuard(ulong dirtyBit) Parameters Type Name Description UInt64 dirtyBit Returns Type Description Boolean | Improve this Doc View Source InitSyncObject(ISyncObject) Declaration protected void InitSyncObject(ISyncObject syncObject) Parameters Type Name Description ISyncObject syncObject | Improve this Doc View Source IsDirty() Declaration public bool IsDirty() Returns Type Description Boolean | Improve this Doc View Source OnDeserialize(NetworkReader, Boolean) Virtual function to override to receive custom serialization data. The corresponding function to send serialization data is OnSerialize(). Declaration public virtual void OnDeserialize(NetworkReader reader, bool initialState) Parameters Type Name Description NetworkReader reader Reader to read from the stream. Boolean initialState True if being sent initial state. | Improve this Doc View Source OnSerialize(NetworkWriter, Boolean) Virtual function to override to send custom serialization data. The corresponding function to send serialization data is OnDeserialize(). Declaration public virtual bool OnSerialize(NetworkWriter writer, bool initialState) Parameters Type Name Description NetworkWriter writer Writer to use to write to the stream. Boolean initialState If this is being called to send initial state. Returns Type Description Boolean True if data was written. Remarks The initialState flag is useful to differentiate between the first time an object is serialized and when incremental updates can be sent. The first time an object is sent to a client, it must include a full state snapshot, but subsequent updates can save on bandwidth by including only incremental changes. Note that SyncVar hook functions are not called when initialState is true, only for incremental updates. If a class has SyncVars, then an implementation of this function and OnDeserialize() are added automatically to the class. So a class that has SyncVars cannot also have custom serialization functions. The OnSerialize function should return true to indicate that an update should be sent. If it returns true, then the dirty bits for that script are set to zero, if it returns false then the dirty bits are not changed. This allows multiple changes to a script to be accumulated over time and sent when the system is ready, instead of every frame. | Improve this Doc View Source SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) Declaration protected void SendRpcInternal(Type invokeClass, string rpcName, NetworkWriter writer, int channelId, bool excludeOwner) Parameters Type Name Description Type invokeClass String rpcName NetworkWriter writer Int32 channelId Boolean excludeOwner | Improve this Doc View Source SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) Declaration protected void SendServerRpcInternal(Type invokeClass, string cmdName, NetworkWriter writer, int channelId, bool requireAuthority = true) Parameters Type Name Description Type invokeClass String cmdName NetworkWriter writer Int32 channelId Boolean requireAuthority | Improve this Doc View Source SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) Declaration protected UniTask<T> SendServerRpcWithReturn<T>(Type invokeClass, string cmdName, NetworkWriter writer, int channelId, bool requireAuthority = true) Parameters Type Name Description Type invokeClass String cmdName NetworkWriter writer Int32 channelId Boolean requireAuthority Returns Type Description UniTask <T> Type Parameters Name Description T | Improve this Doc View Source SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) Declaration protected void SendTargetRpcInternal(INetworkConnection conn, Type invokeClass, string rpcName, NetworkWriter writer, int channelId) Parameters Type Name Description INetworkConnection conn Type invokeClass String rpcName NetworkWriter writer Int32 channelId | Improve this Doc View Source SerializeObjectsAll(NetworkWriter) Declaration public bool SerializeObjectsAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Returns Type Description Boolean | Improve this Doc View Source SerializeObjectsDelta(NetworkWriter) Declaration public bool SerializeObjectsDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Returns Type Description Boolean | Improve this Doc View Source SerializeSyncVars(NetworkWriter, Boolean) Declaration public virtual bool SerializeSyncVars(NetworkWriter writer, bool initialState) Parameters Type Name Description NetworkWriter writer Boolean initialState Returns Type Description Boolean | Improve this Doc View Source SetDirtyBit(UInt64) Used to set the behaviour as dirty, so that a network update will be sent for the object. these are masks, not bit numbers, ie. 0x004 not 2 Declaration public void SetDirtyBit(ulong dirtyBit) Parameters Type Name Description UInt64 dirtyBit Bit mask to set. | Improve this Doc View Source SetSyncVarHookGuard(UInt64, Boolean) Declaration protected void SetSyncVarHookGuard(ulong dirtyBit, bool value) Parameters Type Name Description UInt64 dirtyBit Boolean value | Improve this Doc View Source StillDirty() Declaration public bool StillDirty() Returns Type Description Boolean | Improve this Doc View Source SyncVarEqual<T>(T, T) Declaration protected bool SyncVarEqual<T>(T value, T fieldValue) Parameters Type Name Description T value T fieldValue Returns Type Description Boolean Type Parameters Name Description T"
  },
  "api/Mirage.NetworkClient.html": {
    "href": "api/Mirage.NetworkClient.html",
    "title": "Class NetworkClient",
    "keywords": "Class NetworkClient This is a network client class used by the networking system. It contains a NetworkConnection that is used to connect to a network server. The NetworkClient handle connection state, messages handlers, and connection configuration. There can be many NetworkClient instances in a process at a time, but only one that is connected to a game server ( NetworkServer ) that uses spawned objects. NetworkClient has an internal update function where it handles events from the transport layer. This includes asynchronous connect events, disconnect events and incoming data from a server. Inheritance Object NetworkClient Implements INetworkClient Namespace : Mirage Assembly : doc.dll Syntax public class NetworkClient : MonoBehaviour, INetworkClient Fields | Improve this Doc View Source authenticator Declaration public NetworkAuthenticator authenticator Field Value Type Description NetworkAuthenticator | Improve this Doc View Source Transport Declaration public Transport Transport Field Value Type Description Transport Properties | Improve this Doc View Source Active active is true while a client is connecting/connected (= while the network is active) Declaration public bool Active { get; } Property Value Type Description Boolean | Improve this Doc View Source Authenticated Declaration public NetworkConnectionEvent Authenticated { get; } Property Value Type Description NetworkConnectionEvent | Improve this Doc View Source Connected Declaration public NetworkConnectionEvent Connected { get; } Property Value Type Description NetworkConnectionEvent | Improve this Doc View Source Connection The NetworkConnection object this client is using. Declaration public INetworkConnection Connection { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source Disconnected Declaration public UnityEvent Disconnected { get; } Property Value Type Description UnityEvent | Improve this Doc View Source IsConnected This gives the current connection status of the client. Declaration public bool IsConnected { get; } Property Value Type Description Boolean | Improve this Doc View Source IsLocalClient NetworkClient can connect to local server in host mode too Declaration public bool IsLocalClient { get; } Property Value Type Description Boolean | Improve this Doc View Source Time Time kept in this client Declaration public NetworkTime Time { get; } Property Value Type Description NetworkTime Methods | Improve this Doc View Source ConnectAsync(String) Connect client to a NetworkServer instance. Declaration public UniTask ConnectAsync(string serverIp) Parameters Type Name Description String serverIp Address of the server to connect to Returns Type Description UniTask | Improve this Doc View Source ConnectAsync(String, UInt16) Connect client to a NetworkServer instance. Declaration public UniTask ConnectAsync(string serverIp, ushort port) Parameters Type Name Description String serverIp Address of the server to connect to UInt16 port The port of the server to connect to Returns Type Description UniTask | Improve this Doc View Source ConnectAsync(Uri) Connect client to a NetworkServer instance. Declaration public UniTask ConnectAsync(Uri uri) Parameters Type Name Description Uri uri Address of the server to connect to Returns Type Description UniTask | Improve this Doc View Source Disconnect() Disconnect from server. The disconnect message will be invoked. Declaration public void Disconnect() | Improve this Doc View Source GetNewConnection(IConnection) Creates a new INetworkConnection based on the provided IConnection. Declaration public virtual INetworkConnection GetNewConnection(IConnection connection) Parameters Type Name Description IConnection connection Returns Type Description INetworkConnection | Improve this Doc View Source Send<T>(T, Int32) Declaration public void Send<T>(T message, int channelId = null) Parameters Type Name Description T message Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SendAsync<T>(T, Int32) This sends a network message with a message Id to the server. This message is sent on channel zero, which by default is the reliable channel. The message must be an instance of a class derived from MessageBase. The message id passed to Send() is used to identify the handler function to invoke on the server when the message is received. Declaration public UniTask SendAsync<T>(T message, int channelId = null) Parameters Type Name Description T message Int32 channelId Returns Type Description UniTask True if message was sent. Type Parameters Name Description T The message type to unregister. Implements INetworkClient"
  },
  "api/Mirage.NetworkConnection.html": {
    "href": "api/Mirage.NetworkConnection.html",
    "title": "Class NetworkConnection",
    "keywords": "Class NetworkConnection A High level network connection. This is used for connections from client-to-server and for connection from server-to-client. Inheritance Object NetworkConnection Implements INetworkConnection IMessageHandler IVisibilityTracker IObjectOwner Namespace : Mirage Assembly : doc.dll Syntax public class NetworkConnection : object, INetworkConnection, IMessageHandler, IVisibilityTracker, IObjectOwner Remarks A NetworkConnection corresponds to a specific connection for a host in the transport layer. It has a connectionId that is assigned by the transport layer and passed to the Initialize function. A NetworkClient has one NetworkConnection. A NetworkServerSimple manages multiple NetworkConnections. The NetworkServer has multiple \"remote\" connections and a \"local\" connection for the local client. The NetworkConnection class provides message sending and handling facilities. For sending data over a network, there are methods to send message objects, byte arrays, and NetworkWriter objects. To handle data arriving from the network, handler functions can be registered for message Ids, byte arrays can be processed by HandleBytes(), and NetworkReader object can be processed by HandleReader(). NetworkConnection objects also act as observers for networked objects. When a connection is an observer of a networked object with a NetworkIdentity, then the object will be visible to corresponding client for the connection, and incremental state changes will be sent to the client. There are many virtual functions on NetworkConnection that allow its behaviour to be customized. NetworkClient and NetworkServer can both be made to instantiate custom classes derived from NetworkConnection by setting their networkConnectionClass member variable. Constructors | Improve this Doc View Source NetworkConnection(IConnection) Creates a new NetworkConnection with the specified address and connectionId Declaration public NetworkConnection(IConnection connection) Parameters Type Name Description IConnection connection Fields | Improve this Doc View Source NOTIFY_ACK_TIMEOUT Declaration public float NOTIFY_ACK_TIMEOUT Field Value Type Description Single Properties | Improve this Doc View Source Address The IP address / URL / FQDN associated with the connection. Can be useful for a game master to do IP Bans etc. Declaration public virtual EndPoint Address { get; } Property Value Type Description EndPoint | Improve this Doc View Source AuthenticationData General purpose object to hold authentication data, character selection, tokens, etc. associated with the connection for reference after Authentication completes. Declaration public object AuthenticationData { get; set; } Property Value Type Description Object | Improve this Doc View Source Identity The NetworkIdentity for this connection. Declaration public NetworkIdentity Identity { get; set; } Property Value Type Description NetworkIdentity | Improve this Doc View Source IsReady Flag that tells if the connection has been marked as \"ready\" by a client calling ClientScene.Ready(). This property is read-only. It is set by the system on the client when ClientScene.Ready() is called, and set by the system on the server when a ready message is received from a client. A client that is ready is sent spawned objects by the server and updates to the state of spawned objects. A client that is not ready is not sent spawned objects. Declaration public bool IsReady { get; set; } Property Value Type Description Boolean Methods | Improve this Doc View Source AddOwnedObject(NetworkIdentity) Declaration public void AddOwnedObject(NetworkIdentity networkIdentity) Parameters Type Name Description NetworkIdentity networkIdentity | Improve this Doc View Source AddToVisList(NetworkIdentity) Declaration public void AddToVisList(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity | Improve this Doc View Source ClearHandlers() Clear all registered callback handlers. Declaration public void ClearHandlers() | Improve this Doc View Source DestroyOwnedObjects() Declaration public void DestroyOwnedObjects() | Improve this Doc View Source Disconnect() Disconnects this connection. Declaration public virtual void Disconnect() | Improve this Doc View Source ProcessMessagesAsync() Declaration public UniTask ProcessMessagesAsync() Returns Type Description UniTask | Improve this Doc View Source RegisterHandler<T>(Action<T>) Register a handler for a particular message type. There are several system message types which you can add handlers for. You can also add your own message types. Declaration public void RegisterHandler<T>(Action<T> handler) Parameters Type Name Description Action <T> handler Function handler which will be invoked for when this message type is received. Type Parameters Name Description T Message type | Improve this Doc View Source RegisterHandler<T>(Action<INetworkConnection, T>) Register a handler for a particular message type. There are several system message types which you can add handlers for. You can also add your own message types. Declaration public void RegisterHandler<T>(Action<INetworkConnection, T> handler) Parameters Type Name Description Action < INetworkConnection , T> handler Function handler which will be invoked for when this message type is received. Type Parameters Name Description T Message type | Improve this Doc View Source RemoveFromVisList(NetworkIdentity) Declaration public void RemoveFromVisList(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity | Improve this Doc View Source RemoveObservers() Declaration public void RemoveObservers() | Improve this Doc View Source RemoveOwnedObject(NetworkIdentity) Declaration public void RemoveOwnedObject(NetworkIdentity networkIdentity) Parameters Type Name Description NetworkIdentity networkIdentity | Improve this Doc View Source Send<T>(T, Int32) This sends a network message to the connection. Declaration public virtual void Send<T>(T msg, int channelId = null) Parameters Type Name Description T msg The message to send Int32 channelId The transport layer channel to send on. Type Parameters Name Description T The message type | Improve this Doc View Source Send<T>(IEnumerable<INetworkConnection>, T, Int32) Declaration public static void Send<T>(IEnumerable<INetworkConnection> connections, T msg, int channelId = null) Parameters Type Name Description IEnumerable < INetworkConnection > connections T msg Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SendAsync(ArraySegment<Byte>, Int32) Declaration public UniTask SendAsync(ArraySegment<byte> segment, int channelId = null) Parameters Type Name Description ArraySegment < Byte > segment Int32 channelId Returns Type Description UniTask | Improve this Doc View Source SendAsync<T>(T, Int32) This sends a network message to the connection. You can await it to check for errors Declaration public virtual UniTask SendAsync<T>(T msg, int channelId = null) Parameters Type Name Description T msg The message to send. Int32 channelId The transport layer channel to send on. Returns Type Description UniTask Type Parameters Name Description T The message type | Improve this Doc View Source SendNotify<T>(T, Object, Int32) Sends a message, but notify when it is delivered or lost Declaration public void SendNotify<T>(T msg, object token, int channelId = null) Parameters Type Name Description T msg message to send Object token a arbitrary object that the sender will receive with their notification Int32 channelId Type Parameters Name Description T type of message to send | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description String | Improve this Doc View Source UnregisterHandler<T>() Unregisters a handler for a particular message type. Declaration public void UnregisterHandler<T>() Type Parameters Name Description T Message type Events | Improve this Doc View Source NotifyDelivered Raised when a message is delivered Declaration public event Action<INetworkConnection, object> NotifyDelivered Event Type Type Description Action < INetworkConnection , Object > | Improve this Doc View Source NotifyLost Raised when a message is lost Declaration public event Action<INetworkConnection, object> NotifyLost Event Type Type Description Action < INetworkConnection , Object > Implements INetworkConnection IMessageHandler IVisibilityTracker IObjectOwner"
  },
  "api/Mirage.NetworkConnectionEvent.html": {
    "href": "api/Mirage.NetworkConnectionEvent.html",
    "title": "Class NetworkConnectionEvent",
    "keywords": "Class NetworkConnectionEvent Event fires from a NetworkClient or NetworkServer during a new connection, a new authentication, or a disconnection. INetworkConnection - connection creating the event Inheritance Object NetworkConnectionEvent Namespace : Mirage Assembly : doc.dll Syntax public class NetworkConnectionEvent : UnityEvent<INetworkConnection>"
  },
  "api/Mirage.NetworkDiagnostics.html": {
    "href": "api/Mirage.NetworkDiagnostics.html",
    "title": "Class NetworkDiagnostics",
    "keywords": "Class NetworkDiagnostics Provides profiling information from mirror A profiler can subscribe to these events and present the data in a friendly way to the user Inheritance Object NetworkDiagnostics Namespace : Mirage Assembly : doc.dll Syntax public static class NetworkDiagnostics : object Events | Improve this Doc View Source InMessageEvent Event that gets raised when Mirage receives a message Subscribe to this if you want to profile the network Declaration public static event Action<NetworkDiagnostics.MessageInfo> InMessageEvent Event Type Type Description Action < NetworkDiagnostics.MessageInfo > | Improve this Doc View Source OutMessageEvent Event that gets raised when Mirage sends a message Subscribe to this if you want to diagnose the network Declaration public static event Action<NetworkDiagnostics.MessageInfo> OutMessageEvent Event Type Type Description Action < NetworkDiagnostics.MessageInfo >"
  },
  "api/Mirage.NetworkDiagnostics.MessageInfo.html": {
    "href": "api/Mirage.NetworkDiagnostics.MessageInfo.html",
    "title": "Struct NetworkDiagnostics.MessageInfo",
    "keywords": "Struct NetworkDiagnostics.MessageInfo Describes an outgoing message Namespace : Mirage Assembly : doc.dll Syntax public struct MessageInfo Fields | Improve this Doc View Source bytes how big was the message (does not include transport headers) Declaration public readonly int bytes Field Value Type Description Int32 | Improve this Doc View Source channel channel through which the message was sent Declaration public readonly int channel Field Value Type Description Int32 | Improve this Doc View Source count How many connections was the message sent to If an object has a lot of observers this count could be high Declaration public readonly int count Field Value Type Description Int32 | Improve this Doc View Source message The message being sent Declaration public readonly object message Field Value Type Description Object"
  },
  "api/Mirage.NetworkIdentity.ClientAuthorityCallback.html": {
    "href": "api/Mirage.NetworkIdentity.ClientAuthorityCallback.html",
    "title": "Delegate NetworkIdentity.ClientAuthorityCallback",
    "keywords": "Delegate NetworkIdentity.ClientAuthorityCallback The delegate type for the clientAuthorityCallback. Namespace : Mirage Assembly : doc.dll Syntax public delegate void ClientAuthorityCallback(INetworkConnection conn, NetworkIdentity identity, bool authorityState); Parameters Type Name Description INetworkConnection conn The network connection that is gaining or losing authority. NetworkIdentity identity The object whose client authority status is being changed. Boolean authorityState The new state of client authority of the object for the connection."
  },
  "api/Mirage.NetworkIdentity.html": {
    "href": "api/Mirage.NetworkIdentity.html",
    "title": "Class NetworkIdentity",
    "keywords": "Class NetworkIdentity The NetworkIdentity identifies objects across the network, between server and clients. Its primary data is a NetworkInstanceId which is allocated by the server and then set on clients. This is used in network communications to be able to lookup game objects on different machines. Inheritance Object NetworkIdentity Namespace : Mirage Assembly : doc.dll Syntax public sealed class NetworkIdentity : MonoBehaviour Remarks The NetworkIdentity is used to synchronize information in the object with the network. Only the server should create instances of objects which have NetworkIdentity as otherwise they will not be properly connected to the system. For complex objects with a hierarchy of subcomponents, the NetworkIdentity must be on the root of the hierarchy. It is not supported to have multiple NetworkIdentity components on subcomponents of a hierarchy. NetworkBehaviour scripts require a NetworkIdentity on the game object to be able to function. The NetworkIdentity manages the dirty state of the NetworkBehaviours of the object. When it discovers that NetworkBehaviours are dirty, it causes an update packet to be created and sent to clients. The flow for serialization updates managed by the NetworkIdentity is: On the client: Fields | Improve this Doc View Source ClientObjectManager The ClientObjectManager is present only for client instances. Declaration public ClientObjectManager ClientObjectManager Field Value Type Description ClientObjectManager | Improve this Doc View Source observers The set of network connections (players) that can see this object. Declaration public readonly HashSet<INetworkConnection> observers Field Value Type Description HashSet < INetworkConnection > | Improve this Doc View Source OnStartAuthority This is invoked on behaviours that have authority, based on context and HasAuthority . This is called after OnStartServer and before OnStartClient When AssignClientAuthority(INetworkConnection) is called on the server, this will be called on the client that owns the object. When an object is spawned with Spawn(GameObject, GameObject) with a NetworkConnection parameter included, this will be called on the client that owns the object. Declaration public UnityEvent OnStartAuthority Field Value Type Description UnityEvent | Improve this Doc View Source OnStartClient Called on every NetworkBehaviour when it is activated on a client. Objects on the host have this function called, as there is a local client on the host. The values of SyncVars on object are guaranteed to be initialized correctly with the latest state from the server when this function is called on the client. Declaration public UnityEvent OnStartClient Field Value Type Description UnityEvent | Improve this Doc View Source OnStartLocalPlayer Called when the local player object has been set up. This happens after OnStartClient(), as it is triggered by an ownership message from the server. This is an appropriate place to activate components or functionality that should only be active for the local player, such as cameras and input. Declaration public UnityEvent OnStartLocalPlayer Field Value Type Description UnityEvent | Improve this Doc View Source OnStartServer This is invoked for NetworkBehaviour objects when they become active on the server. This could be triggered by NetworkServer.Listen() for objects in the scene, or by NetworkServer.Spawn() for objects that are dynamically created. This will be called for objects on a \"host\" as well as for object on a dedicated server. Declaration public UnityEvent OnStartServer Field Value Type Description UnityEvent | Improve this Doc View Source OnStopAuthority This is invoked on behaviours when authority is removed. When NetworkIdentity.RemoveClientAuthority is called on the server, this will be called on the client that owns the object. Declaration public UnityEvent OnStopAuthority Field Value Type Description UnityEvent | Improve this Doc View Source OnStopClient This is invoked on clients when the server has caused this object to be destroyed. This can be used as a hook to invoke effects or do client specific cleanup. Declaration public UnityEvent OnStopClient Field Value Type Description UnityEvent | Improve this Doc View Source OnStopServer This is called on the server when the object is unspawned Declaration public UnityEvent OnStopServer Field Value Type Description UnityEvent Remarks Can be used as hook to save player information | Improve this Doc View Source sceneId A unique identifier for NetworkIdentity objects within a scene. This is used for spawning scene objects on clients. Declaration public ulong sceneId Field Value Type Description UInt64 | Improve this Doc View Source ServerObjectManager The ServerObjectManager is present only for server/host instances. Declaration public ServerObjectManager ServerObjectManager Field Value Type Description ServerObjectManager Properties | Improve this Doc View Source AssetId Declaration public Guid AssetId { get; } Property Value Type Description Guid Remarks The AssetId trick: The solution is to serialize the string internally here and then use the real 'Guid' type for everything else via .assetId | Improve this Doc View Source Client The NetworkClient associated with this NetworkIdentity. Declaration public NetworkClient Client { get; } Property Value Type Description NetworkClient | Improve this Doc View Source ConnectionToClient The NetworkConnection associated with this NetworkIdentity This is valid for player and other owned objects in the server. Use it to return details such as the connection's identity, IP address and ready status. Declaration public INetworkConnection ConnectionToClient { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source ConnectionToServer The NetworkConnection associated with this NetworkIdentity. This is only valid for player objects on a local client. Declaration public INetworkConnection ConnectionToServer { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source HasAuthority This returns true if this object is the authoritative player object on the client. This value is determined at runtime. For most objects, authority is held by the server. For objects that had their authority set by AssignClientAuthority on the server, this will be true on the client that owns the object. NOT on other clients. Declaration public bool HasAuthority { get; } Property Value Type Description Boolean | Improve this Doc View Source IsClient Returns true if running as a client and this object was spawned by a server. Declaration public bool IsClient { get; } Property Value Type Description Boolean | Improve this Doc View Source IsLocalClient Returns true if we're on host mode. Declaration public bool IsLocalClient { get; } Property Value Type Description Boolean | Improve this Doc View Source IsLocalPlayer This returns true if this object is the one that represents the player on the local machine. This is set when the server has spawned an object for this particular client. Declaration public bool IsLocalPlayer { get; } Property Value Type Description Boolean | Improve this Doc View Source IsServer Returns true if NetworkServer.active and server is not stopped. Declaration public bool IsServer { get; } Property Value Type Description Boolean | Improve this Doc View Source NetId Unique identifier for this particular object instance, used for tracking objects between networked clients and the server. This is a unique identifier for this particular GameObject instance. Use it to track GameObjects between networked clients and the server. Declaration public uint NetId { get; } Property Value Type Description UInt32 | Improve this Doc View Source NetworkBehaviours Array of NetworkBehaviours associated with this NetworkIdentity. Can be in child GameObjects. Declaration public NetworkBehaviour[] NetworkBehaviours { get; } Property Value Type Description NetworkBehaviour [] | Improve this Doc View Source Server The NetworkServer associated with this NetworkIdentity. Declaration public NetworkServer Server { get; } Property Value Type Description NetworkServer | Improve this Doc View Source SpawnedFromInstantiate Declaration public bool SpawnedFromInstantiate { get; } Property Value Type Description Boolean | Improve this Doc View Source Visibility Declaration public NetworkVisibility Visibility { get; } Property Value Type Description NetworkVisibility Methods | Improve this Doc View Source AssignClientAuthority(INetworkConnection) Assign control of an object to a client via the client's NetworkConnection This causes hasAuthority to be set on the client that owns the object, and NetworkBehaviour.OnStartAuthority will be called on that client. This object then will be in the NetworkConnection.clientOwnedObjects list for the connection. Authority can be removed with RemoveClientAuthority. Only one client can own an object at any time. This does not need to be called for player objects, as their authority is setup automatically. Declaration public void AssignClientAuthority(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn The connection of the client to assign authority to. | Improve this Doc View Source GetSceneIdentity(UInt64) Gets the NetworkIdentity from the sceneIds dictionary with the corresponding id Declaration public static NetworkIdentity GetSceneIdentity(ulong id) Parameters Type Name Description UInt64 id Returns Type Description NetworkIdentity NetworkIdentity from the sceneIds dictionary | Improve this Doc View Source RebuildObservers(Boolean) This causes the set of players that can see this object to be rebuild. The OnRebuildObservers callback function will be invoked on each NetworkBehaviour. Declaration public void RebuildObservers(bool initialize) Parameters Type Name Description Boolean initialize True if this is the first time. | Improve this Doc View Source RemoveClientAuthority() Removes ownership for an object. This applies to objects that had authority set by AssignClientAuthority, or Spawn(GameObject, GameObject) with a NetworkConnection parameter included. Authority cannot be removed for player objects. Declaration public void RemoveClientAuthority() Events | Improve this Doc View Source clientAuthorityCallback A callback that can be populated to be notified when the client-authority state of objects changes. Whenever an object is spawned with client authority, or the client authority status of an object is changed with AssignClientAuthority or RemoveClientAuthority, then this callback will be invoked. This callback is only invoked on the server. Declaration public static event NetworkIdentity.ClientAuthorityCallback clientAuthorityCallback Event Type Type Description NetworkIdentity.ClientAuthorityCallback"
  },
  "api/Mirage.NetworkIdentitySerializers.html": {
    "href": "api/Mirage.NetworkIdentitySerializers.html",
    "title": "Class NetworkIdentitySerializers",
    "keywords": "Class NetworkIdentitySerializers Inheritance Object NetworkIdentitySerializers Namespace : Mirage Assembly : doc.dll Syntax public static class NetworkIdentitySerializers : object Methods | Improve this Doc View Source ReadNetworkIdentitySyncVar(NetworkReader) Declaration public static NetworkIdentitySyncvar ReadNetworkIdentitySyncVar(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description NetworkIdentitySyncvar | Improve this Doc View Source WriteNetworkIdentitySyncVar(NetworkWriter, NetworkIdentitySyncvar) Declaration public static void WriteNetworkIdentitySyncVar(this NetworkWriter writer, NetworkIdentitySyncvar id) Parameters Type Name Description NetworkWriter writer NetworkIdentitySyncvar id"
  },
  "api/Mirage.NetworkIdentitySyncvar.html": {
    "href": "api/Mirage.NetworkIdentitySyncvar.html",
    "title": "Struct NetworkIdentitySyncvar",
    "keywords": "Struct NetworkIdentitySyncvar backing struct for a NetworkIdentity when used as a syncvar the weaver will replace the syncvar with this struct. Namespace : Mirage Assembly : doc.dll Syntax public struct NetworkIdentitySyncvar Properties | Improve this Doc View Source Value Declaration public NetworkIdentity Value { get; set; } Property Value Type Description NetworkIdentity"
  },
  "api/Mirage.NetworkManager.html": {
    "href": "api/Mirage.NetworkManager.html",
    "title": "Class NetworkManager",
    "keywords": "Class NetworkManager Inheritance Object NetworkManager Namespace : Mirage Assembly : doc.dll Syntax public class NetworkManager : MonoBehaviour Fields | Improve this Doc View Source Client Declaration public NetworkClient Client Field Value Type Description NetworkClient | Improve this Doc View Source ClientObjectManager Declaration public ClientObjectManager ClientObjectManager Field Value Type Description ClientObjectManager | Improve this Doc View Source SceneManager Declaration public NetworkSceneManager SceneManager Field Value Type Description NetworkSceneManager | Improve this Doc View Source Server Declaration public NetworkServer Server Field Value Type Description NetworkServer | Improve this Doc View Source ServerObjectManager Declaration public ServerObjectManager ServerObjectManager Field Value Type Description ServerObjectManager Properties | Improve this Doc View Source IsNetworkActive True if the server or client is started and running This is set True in StartServer / StartClient, and set False in StopServer / StopClient Declaration public bool IsNetworkActive { get; } Property Value Type Description Boolean"
  },
  "api/Mirage.NetworkManagerHud.html": {
    "href": "api/Mirage.NetworkManagerHud.html",
    "title": "Class NetworkManagerHud",
    "keywords": "Class NetworkManagerHud Inheritance Object NetworkManagerHud Namespace : Mirage Assembly : doc.dll Syntax public class NetworkManagerHud : MonoBehaviour Fields | Improve this Doc View Source NetworkAddress Declaration public string NetworkAddress Field Value Type Description String | Improve this Doc View Source NetworkAddressInput Declaration public InputField NetworkAddressInput Field Value Type Description InputField | Improve this Doc View Source NetworkManager Declaration public NetworkManager NetworkManager Field Value Type Description NetworkManager | Improve this Doc View Source OfflineGO Declaration public GameObject OfflineGO Field Value Type Description GameObject | Improve this Doc View Source OnlineGO Declaration public GameObject OnlineGO Field Value Type Description GameObject | Improve this Doc View Source StatusLabel Declaration public Text StatusLabel Field Value Type Description Text Methods | Improve this Doc View Source OnNetworkAddressInputUpdate() Declaration public void OnNetworkAddressInputUpdate() | Improve this Doc View Source StartClientButtonHandler() Declaration public void StartClientButtonHandler() | Improve this Doc View Source StartHostButtonHandler() Declaration public void StartHostButtonHandler() | Improve this Doc View Source StartServerOnlyButtonHandler() Declaration public void StartServerOnlyButtonHandler() | Improve this Doc View Source StopButtonHandler() Declaration public void StopButtonHandler()"
  },
  "api/Mirage.NetworkMatchChecker.html": {
    "href": "api/Mirage.NetworkMatchChecker.html",
    "title": "Class NetworkMatchChecker",
    "keywords": "Class NetworkMatchChecker Component that controls visibility of networked objects based on match id. Any object with this component on it will only be visible to other objects in the same match. This would be used to isolate players to their respective matches within a single game server instance. Inheritance Object NetworkBehaviour NetworkVisibility NetworkMatchChecker Inherited Members NetworkVisibility.OnSetHostVisibility(Boolean) NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage Assembly : doc.dll Syntax public class NetworkMatchChecker : NetworkVisibility Fields | Improve this Doc View Source currentMatchDebug Declaration public string currentMatchDebug Field Value Type Description String Properties | Improve this Doc View Source Identity Declaration public NetworkIdentity Identity { get; } Property Value Type Description NetworkIdentity | Improve this Doc View Source MatchId Set this to the same value on all networked objects that belong to a given match Declaration public Guid MatchId { get; set; } Property Value Type Description Guid Methods | Improve this Doc View Source Awake() Declaration public void Awake() | Improve this Doc View Source OnCheckObserver(INetworkConnection) Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration public override bool OnCheckObserver(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Network connection of a player. Returns Type Description Boolean True if the player can see this object. Overrides NetworkVisibility.OnCheckObserver(INetworkConnection) | Improve this Doc View Source OnRebuildObservers(HashSet<INetworkConnection>, Boolean) Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. Declaration public override void OnRebuildObservers(HashSet<INetworkConnection> observers, bool initialize) Parameters Type Name Description HashSet < INetworkConnection > observers The new set of observers for this object. Boolean initialize True if the set of observers is being built for the first time. Overrides NetworkVisibility.OnRebuildObservers(HashSet<INetworkConnection>, Boolean) | Improve this Doc View Source OnStartServer() Declaration public void OnStartServer()"
  },
  "api/Mirage.NetworkMessageAttribute.html": {
    "href": "api/Mirage.NetworkMessageAttribute.html",
    "title": "Class NetworkMessageAttribute",
    "keywords": "Class NetworkMessageAttribute Tell the weaver to generate reader and writer for a class Inheritance Object NetworkMessageAttribute Namespace : Mirage Assembly : doc.dll Syntax public class NetworkMessageAttribute : Attribute"
  },
  "api/Mirage.NetworkPingDisplay.html": {
    "href": "api/Mirage.NetworkPingDisplay.html",
    "title": "Class NetworkPingDisplay",
    "keywords": "Class NetworkPingDisplay Component that will display the clients ping in milliseconds Inheritance Object NetworkPingDisplay Namespace : Mirage Assembly : doc.dll Syntax public class NetworkPingDisplay : MonoBehaviour Fields | Improve this Doc View Source Client Declaration public NetworkClient Client Field Value Type Description NetworkClient | Improve this Doc View Source NetworkPingLabelText Declaration public Text NetworkPingLabelText Field Value Type Description Text"
  },
  "api/Mirage.NetworkPingMessage.html": {
    "href": "api/Mirage.NetworkPingMessage.html",
    "title": "Struct NetworkPingMessage",
    "keywords": "Struct NetworkPingMessage Namespace : Mirage Assembly : doc.dll Syntax public struct NetworkPingMessage Fields | Improve this Doc View Source clientTime Declaration public double clientTime Field Value Type Description Double"
  },
  "api/Mirage.NetworkPongMessage.html": {
    "href": "api/Mirage.NetworkPongMessage.html",
    "title": "Struct NetworkPongMessage",
    "keywords": "Struct NetworkPongMessage Namespace : Mirage Assembly : doc.dll Syntax public struct NetworkPongMessage Fields | Improve this Doc View Source clientTime Declaration public double clientTime Field Value Type Description Double | Improve this Doc View Source serverTime Declaration public double serverTime Field Value Type Description Double"
  },
  "api/Mirage.NetworkProximityChecker.html": {
    "href": "api/Mirage.NetworkProximityChecker.html",
    "title": "Class NetworkProximityChecker",
    "keywords": "Class NetworkProximityChecker Component that controls visibility of networked objects for players. Any object with this component on it will not be visible to players more than a (configurable) distance away. Inheritance Object NetworkBehaviour NetworkVisibility NetworkProximityChecker Inherited Members NetworkVisibility.OnSetHostVisibility(Boolean) NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage Assembly : doc.dll Syntax public class NetworkProximityChecker : NetworkVisibility Fields | Improve this Doc View Source ForceHidden Flag to force this object to be hidden for players. If this object is a player object, it will not be hidden for that player. Declaration public bool ForceHidden Field Value Type Description Boolean | Improve this Doc View Source VisibilityRange The maximim range that objects will be visible at. Declaration public int VisibilityRange Field Value Type Description Int32 | Improve this Doc View Source VisibilityUpdateInterval How often (in seconds) that this object should update the list of observers that can see it. Declaration public float VisibilityUpdateInterval Field Value Type Description Single Methods | Improve this Doc View Source OnCheckObserver(INetworkConnection) Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration public override bool OnCheckObserver(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Network connection of a player. Returns Type Description Boolean True if the player can see this object. Overrides NetworkVisibility.OnCheckObserver(INetworkConnection) | Improve this Doc View Source OnRebuildObservers(HashSet<INetworkConnection>, Boolean) Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. Declaration public override void OnRebuildObservers(HashSet<INetworkConnection> observers, bool initialize) Parameters Type Name Description HashSet < INetworkConnection > observers The new set of observers for this object. Boolean initialize True if the set of observers is being built for the first time. Overrides NetworkVisibility.OnRebuildObservers(HashSet<INetworkConnection>, Boolean) | Improve this Doc View Source Start() Declaration public void Start()"
  },
  "api/Mirage.NetworkReader.html": {
    "href": "api/Mirage.NetworkReader.html",
    "title": "Class NetworkReader",
    "keywords": "Class NetworkReader Binary stream Reader. Supports simple types, buffers, arrays, structs, and nested types Use GetReader(Byte[]) to reduce memory allocation Inheritance Object NetworkReader PooledNetworkReader Namespace : Mirage Assembly : doc.dll Syntax public class NetworkReader : object Constructors | Improve this Doc View Source NetworkReader(ArraySegment<Byte>) Declaration public NetworkReader(ArraySegment<byte> segment) Parameters Type Name Description ArraySegment < Byte > segment | Improve this Doc View Source NetworkReader(Byte[]) Declaration public NetworkReader(byte[] bytes) Parameters Type Name Description Byte [] bytes Fields | Improve this Doc View Source Position Declaration public int Position Field Value Type Description Int32 Properties | Improve this Doc View Source Length Declaration public int Length { get; } Property Value Type Description Int32 | Improve this Doc View Source ObjectLocator some service object that can find objects by net id Declaration public IObjectLocator ObjectLocator { get; } Property Value Type Description IObjectLocator Methods | Improve this Doc View Source Read<T>() Reads any data type that mirror supports Declaration public T Read<T>() Returns Type Description T Type Parameters Name Description T | Improve this Doc View Source ReadByte() Declaration public byte ReadByte() Returns Type Description Byte | Improve this Doc View Source ReadBytes(Byte[], Int32) Declaration public byte[] ReadBytes(byte[] bytes, int count) Parameters Type Name Description Byte [] bytes Int32 count Returns Type Description Byte [] | Improve this Doc View Source ReadBytesSegment(Int32) Declaration public ArraySegment<byte> ReadBytesSegment(int count) Parameters Type Name Description Int32 count Returns Type Description ArraySegment < Byte > | Improve this Doc View Source ReadInt32() Declaration public int ReadInt32() Returns Type Description Int32 | Improve this Doc View Source ReadInt64() Declaration public long ReadInt64() Returns Type Description Int64 | Improve this Doc View Source ReadUInt32() Declaration public uint ReadUInt32() Returns Type Description UInt32 | Improve this Doc View Source ReadUInt64() Declaration public ulong ReadUInt64() Returns Type Description UInt64 | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description String Extension Methods GameObjectSerializers.ReadGameObjectSyncVar(NetworkReader) NetworkBehaviorSerializers.ReadNetworkBehaviourSyncVar(NetworkReader) NetworkIdentitySerializers.ReadNetworkIdentitySyncVar(NetworkReader) NetworkReaderExtensions.ReadByte(NetworkReader) NetworkReaderExtensions.ReadSByte(NetworkReader) NetworkReaderExtensions.ReadChar(NetworkReader) NetworkReaderExtensions.ReadBoolean(NetworkReader) NetworkReaderExtensions.ReadInt16(NetworkReader) NetworkReaderExtensions.ReadUInt16(NetworkReader) NetworkReaderExtensions.ReadInt32(NetworkReader) NetworkReaderExtensions.ReadUInt32(NetworkReader) NetworkReaderExtensions.ReadInt64(NetworkReader) NetworkReaderExtensions.ReadUInt64(NetworkReader) NetworkReaderExtensions.ReadSingle(NetworkReader) NetworkReaderExtensions.ReadDouble(NetworkReader) NetworkReaderExtensions.ReadDecimal(NetworkReader) NetworkReaderExtensions.ReadString(NetworkReader) NetworkReaderExtensions.ReadBytesAndSize(NetworkReader) NetworkReaderExtensions.ReadBytesAndSizeSegment(NetworkReader) NetworkReaderExtensions.ReadPackedInt32(NetworkReader) NetworkReaderExtensions.ReadPackedUInt32(NetworkReader) NetworkReaderExtensions.ReadPackedInt64(NetworkReader) NetworkReaderExtensions.ReadPackedUInt64(NetworkReader) NetworkReaderExtensions.ReadVector2(NetworkReader) NetworkReaderExtensions.ReadVector3(NetworkReader) NetworkReaderExtensions.ReadVector4(NetworkReader) NetworkReaderExtensions.ReadVector2Int(NetworkReader) NetworkReaderExtensions.ReadVector3Int(NetworkReader) NetworkReaderExtensions.ReadColor(NetworkReader) NetworkReaderExtensions.ReadColor32(NetworkReader) NetworkReaderExtensions.ReadQuaternion(NetworkReader) NetworkReaderExtensions.ReadRect(NetworkReader) NetworkReaderExtensions.ReadPlane(NetworkReader) NetworkReaderExtensions.ReadRay(NetworkReader) NetworkReaderExtensions.ReadMatrix4x4(NetworkReader) NetworkReaderExtensions.ReadBytes(NetworkReader, Int32) NetworkReaderExtensions.ReadGuid(NetworkReader) NetworkReaderExtensions.ReadNetworkIdentity(NetworkReader) NetworkReaderExtensions.ReadList<T>(NetworkReader) NetworkReaderExtensions.ReadArray<T>(NetworkReader) NetworkReaderExtensions.ReadUri(NetworkReader) NetworkReaderExtensions.ReadNetworkBehaviour(NetworkReader) NetworkReaderExtensions.ReadNetworkBehaviour<T>(NetworkReader) NetworkReaderExtensions.ReadGameObject(NetworkReader) NotifyPacketSerializer.ReadNotifyPacket(NetworkReader)"
  },
  "api/Mirage.NetworkReaderExtensions.html": {
    "href": "api/Mirage.NetworkReaderExtensions.html",
    "title": "Class NetworkReaderExtensions",
    "keywords": "Class NetworkReaderExtensions Inheritance Object NetworkReaderExtensions Namespace : Mirage Assembly : doc.dll Syntax public static class NetworkReaderExtensions : object Methods | Improve this Doc View Source ReadArray<T>(NetworkReader) Declaration public static T[] ReadArray<T>(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description T[] Type Parameters Name Description T | Improve this Doc View Source ReadBoolean(NetworkReader) Declaration public static bool ReadBoolean(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Boolean | Improve this Doc View Source ReadByte(NetworkReader) Declaration public static byte ReadByte(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Byte | Improve this Doc View Source ReadBytes(NetworkReader, Int32) Declaration public static byte[] ReadBytes(this NetworkReader reader, int count) Parameters Type Name Description NetworkReader reader Int32 count Returns Type Description Byte [] | Improve this Doc View Source ReadBytesAndSize(NetworkReader) Declaration public static byte[] ReadBytesAndSize(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Byte [] | Improve this Doc View Source ReadBytesAndSizeSegment(NetworkReader) Declaration public static ArraySegment<byte> ReadBytesAndSizeSegment(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description ArraySegment < Byte > | Improve this Doc View Source ReadChar(NetworkReader) Declaration public static char ReadChar(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Char | Improve this Doc View Source ReadColor(NetworkReader) Declaration public static Color ReadColor(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Color | Improve this Doc View Source ReadColor32(NetworkReader) Declaration public static Color32 ReadColor32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Color32 | Improve this Doc View Source ReadDecimal(NetworkReader) Declaration public static decimal ReadDecimal(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Decimal | Improve this Doc View Source ReadDouble(NetworkReader) Declaration public static double ReadDouble(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Double | Improve this Doc View Source ReadGameObject(NetworkReader) Declaration public static GameObject ReadGameObject(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description GameObject | Improve this Doc View Source ReadGuid(NetworkReader) Declaration public static Guid ReadGuid(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Guid | Improve this Doc View Source ReadInt16(NetworkReader) Declaration public static short ReadInt16(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Int16 | Improve this Doc View Source ReadInt32(NetworkReader) Declaration public static int ReadInt32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Int32 | Improve this Doc View Source ReadInt64(NetworkReader) Declaration public static long ReadInt64(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Int64 | Improve this Doc View Source ReadList<T>(NetworkReader) Declaration public static List<T> ReadList<T>(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description List <T> Type Parameters Name Description T | Improve this Doc View Source ReadMatrix4x4(NetworkReader) Declaration public static Matrix4x4 ReadMatrix4x4(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Matrix4x4 | Improve this Doc View Source ReadNetworkBehaviour(NetworkReader) Declaration public static NetworkBehaviour ReadNetworkBehaviour(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description NetworkBehaviour | Improve this Doc View Source ReadNetworkBehaviour<T>(NetworkReader) Declaration public static T ReadNetworkBehaviour<T>(this NetworkReader reader) where T : NetworkBehaviour Parameters Type Name Description NetworkReader reader Returns Type Description T Type Parameters Name Description T | Improve this Doc View Source ReadNetworkIdentity(NetworkReader) Declaration public static NetworkIdentity ReadNetworkIdentity(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description NetworkIdentity | Improve this Doc View Source ReadPackedInt32(NetworkReader) Declaration public static int ReadPackedInt32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Int32 | Improve this Doc View Source ReadPackedInt64(NetworkReader) Declaration public static long ReadPackedInt64(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Int64 | Improve this Doc View Source ReadPackedUInt32(NetworkReader) Declaration public static uint ReadPackedUInt32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description UInt32 | Improve this Doc View Source ReadPackedUInt64(NetworkReader) Declaration public static ulong ReadPackedUInt64(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description UInt64 | Improve this Doc View Source ReadPlane(NetworkReader) Declaration public static Plane ReadPlane(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Plane | Improve this Doc View Source ReadQuaternion(NetworkReader) Declaration public static Quaternion ReadQuaternion(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Quaternion | Improve this Doc View Source ReadRay(NetworkReader) Declaration public static Ray ReadRay(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Ray | Improve this Doc View Source ReadRect(NetworkReader) Declaration public static Rect ReadRect(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Rect | Improve this Doc View Source ReadSByte(NetworkReader) Declaration public static sbyte ReadSByte(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description SByte | Improve this Doc View Source ReadSingle(NetworkReader) Declaration public static float ReadSingle(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Single | Improve this Doc View Source ReadString(NetworkReader) Declaration public static string ReadString(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description String | Improve this Doc View Source ReadUInt16(NetworkReader) Declaration public static ushort ReadUInt16(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description UInt16 | Improve this Doc View Source ReadUInt32(NetworkReader) Declaration public static uint ReadUInt32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description UInt32 | Improve this Doc View Source ReadUInt64(NetworkReader) Declaration public static ulong ReadUInt64(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description UInt64 | Improve this Doc View Source ReadUri(NetworkReader) Declaration public static Uri ReadUri(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Uri | Improve this Doc View Source ReadVector2(NetworkReader) Declaration public static Vector2 ReadVector2(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector2 | Improve this Doc View Source ReadVector2Int(NetworkReader) Declaration public static Vector2Int ReadVector2Int(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector2Int | Improve this Doc View Source ReadVector3(NetworkReader) Declaration public static Vector3 ReadVector3(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector3 | Improve this Doc View Source ReadVector3Int(NetworkReader) Declaration public static Vector3Int ReadVector3Int(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector3Int | Improve this Doc View Source ReadVector4(NetworkReader) Declaration public static Vector4 ReadVector4(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector4"
  },
  "api/Mirage.NetworkReaderPool.html": {
    "href": "api/Mirage.NetworkReaderPool.html",
    "title": "Class NetworkReaderPool",
    "keywords": "Class NetworkReaderPool Pool of NetworkReaders Use this pool instead of NetworkReader to reduce memory allocation Use Capacity to change size of pool Inheritance Object NetworkReaderPool Namespace : Mirage Assembly : doc.dll Syntax public static class NetworkReaderPool : object Properties | Improve this Doc View Source Capacity Size of the pool If pool is too small getting readers will causes memory allocation Default value: 100 Declaration public static int Capacity { get; set; } Property Value Type Description Int32 Methods | Improve this Doc View Source GetReader(ArraySegment<Byte>) Get the next reader in the pool If pool is empty, creates a new Reader Declaration public static PooledNetworkReader GetReader(ArraySegment<byte> segment) Parameters Type Name Description ArraySegment < Byte > segment Returns Type Description PooledNetworkReader | Improve this Doc View Source GetReader(Byte[]) Get the next reader in the pool If pool is empty, creates a new Reader Declaration public static PooledNetworkReader GetReader(byte[] bytes) Parameters Type Name Description Byte [] bytes Returns Type Description PooledNetworkReader | Improve this Doc View Source Recycle(PooledNetworkReader) Puts reader back into pool When pool is full, the extra reader is left for the GC Declaration public static void Recycle(PooledNetworkReader reader) Parameters Type Name Description PooledNetworkReader reader"
  },
  "api/Mirage.NetworkSceneChecker.html": {
    "href": "api/Mirage.NetworkSceneChecker.html",
    "title": "Class NetworkSceneChecker",
    "keywords": "Class NetworkSceneChecker Component that controls visibility of networked objects between scenes. Any object with this component on it will only be visible to other objects in the same scene This would be used when the server has multiple additive subscenes loaded to isolate players to their respective subscenes Inheritance Object NetworkBehaviour NetworkVisibility NetworkSceneChecker Inherited Members NetworkVisibility.OnSetHostVisibility(Boolean) NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage Assembly : doc.dll Syntax public class NetworkSceneChecker : NetworkVisibility Fields | Improve this Doc View Source forceHidden Flag to force this object to be hidden from all observers. If this object is a player object, it will not be hidden for that client. Declaration public bool forceHidden Field Value Type Description Boolean Methods | Improve this Doc View Source OnCheckObserver(INetworkConnection) Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration public override bool OnCheckObserver(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Network connection of a player. Returns Type Description Boolean True if the player can see this object. Overrides NetworkVisibility.OnCheckObserver(INetworkConnection) | Improve this Doc View Source OnRebuildObservers(HashSet<INetworkConnection>, Boolean) Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. Declaration public override void OnRebuildObservers(HashSet<INetworkConnection> observers, bool initialize) Parameters Type Name Description HashSet < INetworkConnection > observers The new set of observers for this object. Boolean initialize True if the set of observers is being built for the first time. Overrides NetworkVisibility.OnRebuildObservers(HashSet<INetworkConnection>, Boolean) | Improve this Doc View Source OnStartServer() Declaration public void OnStartServer()"
  },
  "api/Mirage.NetworkSceneManager.html": {
    "href": "api/Mirage.NetworkSceneManager.html",
    "title": "Class NetworkSceneManager",
    "keywords": "Class NetworkSceneManager Provides Scene Management to a NetworkServer and or NetworkClient. The NetworkClient loads scenes as instructed by the NetworkServer . The NetworkServer controls the currently active Scene and any additive Load/Unload. Inheritance Object NetworkSceneManager Implements INetworkSceneManager Namespace : Mirage Assembly : doc.dll Syntax public class NetworkSceneManager : MonoBehaviour, INetworkSceneManager Fields | Improve this Doc View Source Client Declaration public NetworkClient Client Field Value Type Description NetworkClient | Improve this Doc View Source DontDestroy Sets the NetworksSceneManagers GameObject to DontDestroyOnLoad. Default = true. Declaration public bool DontDestroy Field Value Type Description Boolean | Improve this Doc View Source Server Declaration public NetworkServer Server Field Value Type Description NetworkServer Properties | Improve this Doc View Source ClientChangeScene Event fires when the Client starts changing scene. Declaration public ClientSceneChangeEvent ClientChangeScene { get; } Property Value Type Description ClientSceneChangeEvent | Improve this Doc View Source ClientSceneChanged Event fires after the Client has completed its scene change. Declaration public ClientSceneChangeEvent ClientSceneChanged { get; } Property Value Type Description ClientSceneChangeEvent | Improve this Doc View Source NetworkScenePath The path of the current network scene. Declaration public string NetworkScenePath { get; } Property Value Type Description String Remarks New clients that connect to a server will automatically load this scene. This is used to make sure that all scene changes are initialized by Mirage. | Improve this Doc View Source ServerChangeScene Event fires before Server changes scene. Declaration public ClientSceneChangeEvent ServerChangeScene { get; } Property Value Type Description ClientSceneChangeEvent | Improve this Doc View Source ServerSceneChanged Event fires after Server has completed scene change. Declaration public ClientSceneChangeEvent ServerSceneChanged { get; } Property Value Type Description ClientSceneChangeEvent Methods | Improve this Doc View Source ChangeServerScene(String, SceneOperation) This causes the server to switch scenes and sets the NetworkScenePath. Clients that connect to this server will automatically switch to this scene. This automatically sets clients to be not-ready. The clients must call Ready() again to participate in the new scene. Declaration public void ChangeServerScene(string scenePath, SceneOperation sceneOperation = SceneOperation.Normal) Parameters Type Name Description String scenePath SceneOperation sceneOperation | Improve this Doc View Source SetClientReady() Signal that the client connection is ready to enter the game. This could be for example when a client enters an ongoing game and has finished loading the current scene. The server should respond to the message with an appropriate handler which instantiates the players object for example. Declaration public void SetClientReady() | Improve this Doc View Source Start() Declaration public void Start() Implements INetworkSceneManager"
  },
  "api/Mirage.NetworkServer.html": {
    "href": "api/Mirage.NetworkServer.html",
    "title": "Class NetworkServer",
    "keywords": "Class NetworkServer The NetworkServer. Inheritance Object NetworkServer Implements INetworkServer Namespace : Mirage Assembly : doc.dll Syntax public class NetworkServer : MonoBehaviour, INetworkServer Remarks NetworkServer handles remote connections from remote clients, and also has a local connection for a local client. Fields | Improve this Doc View Source authenticator Declaration public NetworkAuthenticator authenticator Field Value Type Description NetworkAuthenticator | Improve this Doc View Source connections A list of local connections on the server. Declaration public readonly HashSet<INetworkConnection> connections Field Value Type Description HashSet < INetworkConnection > | Improve this Doc View Source Listening If you disable this, the server will not listen for incoming connections on the regular network port. This can be used if the game is running in host mode and does not want external players to be able to connect - making it like a single-player game. Also this can be useful when using AddExternalConnection(). Declaration public bool Listening Field Value Type Description Boolean | Improve this Doc View Source MaxConnections The maximum number of concurrent network connections to support. This effects the memory usage of the network layer. Declaration public int MaxConnections Field Value Type Description Int32 | Improve this Doc View Source Transport Declaration public Transport Transport Field Value Type Description Transport Properties | Improve this Doc View Source Active Checks if the server has been started. This will be true after NetworkServer.Listen() has been called. Declaration public bool Active { get; } Property Value Type Description Boolean | Improve this Doc View Source Authenticated Declaration public NetworkConnectionEvent Authenticated { get; } Property Value Type Description NetworkConnectionEvent | Improve this Doc View Source Connected Declaration public NetworkConnectionEvent Connected { get; } Property Value Type Description NetworkConnectionEvent | Improve this Doc View Source Disconnected Declaration public NetworkConnectionEvent Disconnected { get; } Property Value Type Description NetworkConnectionEvent | Improve this Doc View Source LocalClient The host client for this server Declaration public NetworkClient LocalClient { get; } Property Value Type Description NetworkClient | Improve this Doc View Source LocalClientActive True if there is a local client connected to this server (host mode) Declaration public bool LocalClientActive { get; } Property Value Type Description Boolean | Improve this Doc View Source LocalConnection The connection to the host mode client (if any). Declaration public INetworkConnection LocalConnection { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source NumPlayers Number of active player objects across all connections on the server. This is only valid on the host / server. Declaration public int NumPlayers { get; } Property Value Type Description Int32 | Improve this Doc View Source OnStartHost Declaration public UnityEvent OnStartHost { get; } Property Value Type Description UnityEvent | Improve this Doc View Source OnStopHost Declaration public UnityEvent OnStopHost { get; } Property Value Type Description UnityEvent | Improve this Doc View Source Started Declaration public UnityEvent Started { get; } Property Value Type Description UnityEvent | Improve this Doc View Source Stopped Declaration public UnityEvent Stopped { get; } Property Value Type Description UnityEvent | Improve this Doc View Source Time Time kept in this server Declaration public NetworkTime Time { get; } Property Value Type Description NetworkTime Methods | Improve this Doc View Source AddConnection(INetworkConnection) This accepts a network connection and adds it to the server. This connection will use the callbacks registered with the server. Declaration public void AddConnection(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Network connection to add. | Improve this Doc View Source Disconnect() This shuts down the server and disconnects all clients. Declaration public void Disconnect() | Improve this Doc View Source GetNewConnection(IConnection) Creates a new INetworkConnection based on the provided IConnection. Declaration public virtual INetworkConnection GetNewConnection(IConnection connection) Parameters Type Name Description IConnection connection Returns Type Description INetworkConnection | Improve this Doc View Source ListenAsync() Start the server, setting the maximum number of connections. Declaration public UniTask ListenAsync() Returns Type Description UniTask | Improve this Doc View Source RemoveConnection(INetworkConnection) This removes an external connection added with AddExternalConnection(). Declaration public void RemoveConnection(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn | Improve this Doc View Source SendToAll<T>(T, Int32) Send a message to all connected clients. Declaration public void SendToAll<T>(T msg, int channelId = null) Parameters Type Name Description T msg Message Int32 channelId Transport channel to use Type Parameters Name Description T Message type | Improve this Doc View Source StartHost(NetworkClient) This starts a network \"host\" - a server and client in the same application. The client returned from StartHost() is a special \"local\" client that communicates to the in-process server using a message queue instead of the real network. But in almost all other cases, it can be treated as a normal client. Declaration public UniTask StartHost(NetworkClient client) Parameters Type Name Description NetworkClient client Returns Type Description UniTask | Improve this Doc View Source StopHost() This stops both the client and the server that the manager is using. Declaration public void StopHost() Implements INetworkServer"
  },
  "api/Mirage.NetworkTime.html": {
    "href": "api/Mirage.NetworkTime.html",
    "title": "Class NetworkTime",
    "keywords": "Class NetworkTime Synchronize time between the server and the clients Inheritance Object NetworkTime Namespace : Mirage Assembly : doc.dll Syntax public class NetworkTime : object Constructors | Improve this Doc View Source NetworkTime() Declaration public NetworkTime() Fields | Improve this Doc View Source PingFrequency how often are we sending ping messages used to calculate network time and RTT Declaration public float PingFrequency Field Value Type Description Single | Improve this Doc View Source PingWindowSize average out the last few results from Ping Declaration public int PingWindowSize Field Value Type Description Int32 Properties | Improve this Doc View Source Offset Clock difference in seconds between the client and the server Declaration public double Offset { get; } Property Value Type Description Double Remarks Note this value is always 0 at the server | Improve this Doc View Source Rtt how long in seconds does it take for a message to go to the server and come back Declaration public double Rtt { get; } Property Value Type Description Double | Improve this Doc View Source RttSd Measure the standard deviation of rtt the higher the number, the less accurate rtt is Declaration public double RttSd { get; } Property Value Type Description Double | Improve this Doc View Source RttVar measure variance of rtt the higher the number, the less accurate rtt is Declaration public double RttVar { get; } Property Value Type Description Double | Improve this Doc View Source Time The time in seconds since the server started. Declaration public double Time { get; } Property Value Type Description Double Remarks Note this value works in the client and the server the value is synchronized accross the network with high accuracy You should not cast this down to a float because the it loses too much accuracy when the server is up for a while I measured the accuracy of float and I got this: for the same day, accuracy is better than 1 ms after 1 day, accuracy goes down to 7 ms after 10 days, accuracy is 61 ms after 30 days , accuracy is 238 ms after 60 days, accuracy is 454 ms in other words, if the server is running for 2 months, and you cast down to float, then the time will jump in 0.4s intervals. | Improve this Doc View Source TimeSd standard deviation of time. The higher the variance, the less accurate the time is Declaration public double TimeSd { get; } Property Value Type Description Double | Improve this Doc View Source TimeVar Measurement of the variance of time. The higher the variance, the less accurate the time is Declaration public double TimeVar { get; } Property Value Type Description Double Methods | Improve this Doc View Source Reset() Declaration public void Reset()"
  },
  "api/Mirage.NetworkTransform.html": {
    "href": "api/Mirage.NetworkTransform.html",
    "title": "Class NetworkTransform",
    "keywords": "Class NetworkTransform Inheritance Object NetworkBehaviour NetworkTransformBase NetworkTransform Inherited Members NetworkTransformBase.ClientAuthority NetworkTransformBase.LocalPositionSensitivity NetworkTransformBase.LocalRotationSensitivity NetworkTransformBase.LocalScaleSensitivity NetworkTransformBase.SerializeIntoWriter(NetworkWriter, Vector3, Quaternion, Vector3) NetworkTransformBase.OnSerialize(NetworkWriter, Boolean) NetworkTransformBase.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage Assembly : doc.dll Syntax public class NetworkTransform : NetworkTransformBase Properties | Improve this Doc View Source TargetComponent Declaration protected override Transform TargetComponent { get; } Property Value Type Description Transform Overrides NetworkTransformBase.TargetComponent"
  },
  "api/Mirage.NetworkTransformBase.DataPoint.html": {
    "href": "api/Mirage.NetworkTransformBase.DataPoint.html",
    "title": "Class NetworkTransformBase.DataPoint",
    "keywords": "Class NetworkTransformBase.DataPoint Inheritance Object NetworkTransformBase.DataPoint Namespace : Mirage Assembly : doc.dll Syntax public class DataPoint : object Fields | Improve this Doc View Source LocalPosition Declaration public Vector3 LocalPosition Field Value Type Description Vector3 | Improve this Doc View Source LocalRotation Declaration public Quaternion LocalRotation Field Value Type Description Quaternion | Improve this Doc View Source LocalScale Declaration public Vector3 LocalScale Field Value Type Description Vector3 | Improve this Doc View Source MovementSpeed Declaration public float MovementSpeed Field Value Type Description Single | Improve this Doc View Source TimeStamp Declaration public float TimeStamp Field Value Type Description Single"
  },
  "api/Mirage.NetworkTransformBase.html": {
    "href": "api/Mirage.NetworkTransformBase.html",
    "title": "Class NetworkTransformBase",
    "keywords": "Class NetworkTransformBase Inheritance Object NetworkBehaviour NetworkTransformBase NetworkTransform NetworkTransformChild Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage Assembly : doc.dll Syntax public abstract class NetworkTransformBase : NetworkBehaviour Fields | Improve this Doc View Source ClientAuthority Declaration public bool ClientAuthority Field Value Type Description Boolean | Improve this Doc View Source LocalPositionSensitivity Declaration public float LocalPositionSensitivity Field Value Type Description Single | Improve this Doc View Source LocalRotationSensitivity Declaration public float LocalRotationSensitivity Field Value Type Description Single | Improve this Doc View Source LocalScaleSensitivity Declaration public float LocalScaleSensitivity Field Value Type Description Single Properties | Improve this Doc View Source TargetComponent Declaration protected abstract Transform TargetComponent { get; } Property Value Type Description Transform Methods | Improve this Doc View Source OnDeserialize(NetworkReader, Boolean) Declaration public override void OnDeserialize(NetworkReader reader, bool initialState) Parameters Type Name Description NetworkReader reader Boolean initialState Overrides NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) | Improve this Doc View Source OnSerialize(NetworkWriter, Boolean) Declaration public override bool OnSerialize(NetworkWriter writer, bool initialState) Parameters Type Name Description NetworkWriter writer Boolean initialState Returns Type Description Boolean Overrides NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) | Improve this Doc View Source SerializeIntoWriter(NetworkWriter, Vector3, Quaternion, Vector3) Declaration public static void SerializeIntoWriter(NetworkWriter writer, Vector3 position, Quaternion rotation, Vector3 scale) Parameters Type Name Description NetworkWriter writer Vector3 position Quaternion rotation Vector3 scale"
  },
  "api/Mirage.NetworkTransformChild.html": {
    "href": "api/Mirage.NetworkTransformChild.html",
    "title": "Class NetworkTransformChild",
    "keywords": "Class NetworkTransformChild A component to synchronize the position of child transforms of networked objects. There must be a NetworkTransform on the root object of the hierarchy. There can be multiple NetworkTransformChild components on an object. This does not use physics for synchronization, it simply synchronizes the localPosition and localRotation of the child transform and lerps towards the recieved values. Inheritance Object NetworkBehaviour NetworkTransformBase NetworkTransformChild Inherited Members NetworkTransformBase.ClientAuthority NetworkTransformBase.LocalPositionSensitivity NetworkTransformBase.LocalRotationSensitivity NetworkTransformBase.LocalScaleSensitivity NetworkTransformBase.SerializeIntoWriter(NetworkWriter, Vector3, Quaternion, Vector3) NetworkTransformBase.OnSerialize(NetworkWriter, Boolean) NetworkTransformBase.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage Assembly : doc.dll Syntax public class NetworkTransformChild : NetworkTransformBase Fields | Improve this Doc View Source Target Declaration public Transform Target Field Value Type Description Transform Properties | Improve this Doc View Source TargetComponent Declaration protected override Transform TargetComponent { get; } Property Value Type Description Transform Overrides NetworkTransformBase.TargetComponent"
  },
  "api/Mirage.NetworkVisibility.html": {
    "href": "api/Mirage.NetworkVisibility.html",
    "title": "Class NetworkVisibility",
    "keywords": "Class NetworkVisibility Inheritance Object NetworkBehaviour NetworkVisibility NetworkMatchChecker NetworkProximityChecker NetworkSceneChecker Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage Assembly : doc.dll Syntax public abstract class NetworkVisibility : NetworkBehaviour Methods | Improve this Doc View Source OnCheckObserver(INetworkConnection) Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration public abstract bool OnCheckObserver(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Network connection of a player. Returns Type Description Boolean True if the player can see this object. | Improve this Doc View Source OnRebuildObservers(HashSet<INetworkConnection>, Boolean) Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. Declaration public abstract void OnRebuildObservers(HashSet<INetworkConnection> observers, bool initialize) Parameters Type Name Description HashSet < INetworkConnection > observers The new set of observers for this object. Boolean initialize True if the set of observers is being built for the first time. | Improve this Doc View Source OnSetHostVisibility(Boolean) Callback used by the visibility system for objects on a host. Objects on a host (with a local client) cannot be disabled or destroyed when they are not visible to the local client. So this function is called to allow custom code to hide these objects. A typical implementation will disable renderer components on the object. This is only called on local clients on a host. Declaration public virtual void OnSetHostVisibility(bool visible) Parameters Type Name Description Boolean visible New visibility state."
  },
  "api/Mirage.NetworkWriter.html": {
    "href": "api/Mirage.NetworkWriter.html",
    "title": "Class NetworkWriter",
    "keywords": "Class NetworkWriter Binary stream Writer. Supports simple types, buffers, arrays, structs, and nested types Use GetWriter() to reduce memory allocation Inheritance Object NetworkWriter PooledNetworkWriter Namespace : Mirage Assembly : doc.dll Syntax public class NetworkWriter : object Fields | Improve this Doc View Source MaxStringLength Declaration public const int MaxStringLength = null Field Value Type Description Int32 Properties | Improve this Doc View Source Length Declaration public int Length { get; } Property Value Type Description Int32 | Improve this Doc View Source Position Declaration public int Position { get; set; } Property Value Type Description Int32 Methods | Improve this Doc View Source Reset() Reset both the position and length of the stream Declaration public void Reset() Remarks Leaves the capacity the same so that we can reuse this writer without extra allocations | Improve this Doc View Source SetLength(Int32) Sets length, moves position if it is greater than new length Declaration public void SetLength(int newLength) Parameters Type Name Description Int32 newLength Remarks Zeros out any extra length created by setlength | Improve this Doc View Source ToArray() Declaration public byte[] ToArray() Returns Type Description Byte [] | Improve this Doc View Source ToArraySegment() Declaration public ArraySegment<byte> ToArraySegment() Returns Type Description ArraySegment < Byte > | Improve this Doc View Source Write<T>(T) Writes any type that mirror supports Declaration public void Write<T>(T value) Parameters Type Name Description T value Type Parameters Name Description T | Improve this Doc View Source WriteByte(Byte) Declaration public void WriteByte(byte value) Parameters Type Name Description Byte value | Improve this Doc View Source WriteBytes(Byte[], Int32, Int32) Declaration public void WriteBytes(byte[] buffer, int offset, int count) Parameters Type Name Description Byte [] buffer Int32 offset Int32 count | Improve this Doc View Source WriteInt32(Int32) Declaration public void WriteInt32(int value) Parameters Type Name Description Int32 value | Improve this Doc View Source WriteInt64(Int64) Declaration public void WriteInt64(long value) Parameters Type Name Description Int64 value | Improve this Doc View Source WriteUInt32(UInt32) Declaration public void WriteUInt32(uint value) Parameters Type Name Description UInt32 value | Improve this Doc View Source WriteUInt64(UInt64) Declaration public void WriteUInt64(ulong value) Parameters Type Name Description UInt64 value Extension Methods GameObjectSerializers.WriteGameObjectSyncVar(NetworkWriter, GameObjectSyncvar) NetworkBehaviorSerializers.WriteNetworkBehaviorSyncVar(NetworkWriter, NetworkBehaviorSyncvar) NetworkIdentitySerializers.WriteNetworkIdentitySyncVar(NetworkWriter, NetworkIdentitySyncvar) NetworkWriterExtensions.WriteByte(NetworkWriter, Byte) NetworkWriterExtensions.WriteSByte(NetworkWriter, SByte) NetworkWriterExtensions.WriteChar(NetworkWriter, Char) NetworkWriterExtensions.WriteBoolean(NetworkWriter, Boolean) NetworkWriterExtensions.WriteUInt16(NetworkWriter, UInt16) NetworkWriterExtensions.WriteInt16(NetworkWriter, Int16) NetworkWriterExtensions.WriteSingle(NetworkWriter, Single) NetworkWriterExtensions.WriteDouble(NetworkWriter, Double) NetworkWriterExtensions.WriteDecimal(NetworkWriter, Decimal) NetworkWriterExtensions.WriteString(NetworkWriter, String) NetworkWriterExtensions.WriteBytesAndSize(NetworkWriter, Byte[], Int32, Int32) NetworkWriterExtensions.WriteBytesAndSize(NetworkWriter, Byte[]) NetworkWriterExtensions.WriteBytesAndSizeSegment(NetworkWriter, ArraySegment<Byte>) NetworkWriterExtensions.WritePackedInt32(NetworkWriter, Int32) NetworkWriterExtensions.WritePackedUInt32(NetworkWriter, UInt32) NetworkWriterExtensions.WritePackedInt64(NetworkWriter, Int64) NetworkWriterExtensions.WritePackedUInt64(NetworkWriter, UInt64) NetworkWriterExtensions.WriteVector2(NetworkWriter, Vector2) NetworkWriterExtensions.WriteVector3(NetworkWriter, Vector3) NetworkWriterExtensions.WriteVector4(NetworkWriter, Vector4) NetworkWriterExtensions.WriteVector2Int(NetworkWriter, Vector2Int) NetworkWriterExtensions.WriteVector3Int(NetworkWriter, Vector3Int) NetworkWriterExtensions.WriteColor(NetworkWriter, Color) NetworkWriterExtensions.WriteColor32(NetworkWriter, Color32) NetworkWriterExtensions.WriteQuaternion(NetworkWriter, Quaternion) NetworkWriterExtensions.WriteRect(NetworkWriter, Rect) NetworkWriterExtensions.WritePlane(NetworkWriter, Plane) NetworkWriterExtensions.WriteRay(NetworkWriter, Ray) NetworkWriterExtensions.WriteMatrix4X4(NetworkWriter, Matrix4x4) NetworkWriterExtensions.WriteGuid(NetworkWriter, Guid) NetworkWriterExtensions.WriteNetworkIdentity(NetworkWriter, NetworkIdentity) NetworkWriterExtensions.WriteUri(NetworkWriter, Uri) NetworkWriterExtensions.WriteList<T>(NetworkWriter, List<T>) NetworkWriterExtensions.WriteArray<T>(NetworkWriter, T[]) NetworkWriterExtensions.WriteArraySegment<T>(NetworkWriter, ArraySegment<T>) NetworkWriterExtensions.WriteNetworkBehaviour(NetworkWriter, NetworkBehaviour) NetworkWriterExtensions.WriteGameObject(NetworkWriter, GameObject) NotifyPacketSerializer.WriteNotifyPacket(NetworkWriter, NotifyPacket)"
  },
  "api/Mirage.NetworkWriterExtensions.html": {
    "href": "api/Mirage.NetworkWriterExtensions.html",
    "title": "Class NetworkWriterExtensions",
    "keywords": "Class NetworkWriterExtensions Inheritance Object NetworkWriterExtensions Namespace : Mirage Assembly : doc.dll Syntax public static class NetworkWriterExtensions : object Methods | Improve this Doc View Source WriteArray<T>(NetworkWriter, T[]) Declaration public static void WriteArray<T>(this NetworkWriter writer, T[] array) Parameters Type Name Description NetworkWriter writer T[] array Type Parameters Name Description T | Improve this Doc View Source WriteArraySegment<T>(NetworkWriter, ArraySegment<T>) Declaration public static void WriteArraySegment<T>(this NetworkWriter writer, ArraySegment<T> segment) Parameters Type Name Description NetworkWriter writer ArraySegment <T> segment Type Parameters Name Description T | Improve this Doc View Source WriteBoolean(NetworkWriter, Boolean) Declaration public static void WriteBoolean(this NetworkWriter writer, bool value) Parameters Type Name Description NetworkWriter writer Boolean value | Improve this Doc View Source WriteByte(NetworkWriter, Byte) Declaration public static void WriteByte(this NetworkWriter writer, byte value) Parameters Type Name Description NetworkWriter writer Byte value | Improve this Doc View Source WriteBytesAndSize(NetworkWriter, Byte[]) Declaration public static void WriteBytesAndSize(this NetworkWriter writer, byte[] buffer) Parameters Type Name Description NetworkWriter writer Byte [] buffer | Improve this Doc View Source WriteBytesAndSize(NetworkWriter, Byte[], Int32, Int32) Declaration public static void WriteBytesAndSize(this NetworkWriter writer, byte[] buffer, int offset, int count) Parameters Type Name Description NetworkWriter writer Byte [] buffer Int32 offset Int32 count | Improve this Doc View Source WriteBytesAndSizeSegment(NetworkWriter, ArraySegment<Byte>) Declaration public static void WriteBytesAndSizeSegment(this NetworkWriter writer, ArraySegment<byte> buffer) Parameters Type Name Description NetworkWriter writer ArraySegment < Byte > buffer | Improve this Doc View Source WriteChar(NetworkWriter, Char) Declaration public static void WriteChar(this NetworkWriter writer, char value) Parameters Type Name Description NetworkWriter writer Char value | Improve this Doc View Source WriteColor(NetworkWriter, Color) Declaration public static void WriteColor(this NetworkWriter writer, Color value) Parameters Type Name Description NetworkWriter writer Color value | Improve this Doc View Source WriteColor32(NetworkWriter, Color32) Declaration public static void WriteColor32(this NetworkWriter writer, Color32 value) Parameters Type Name Description NetworkWriter writer Color32 value | Improve this Doc View Source WriteDecimal(NetworkWriter, Decimal) Declaration public static void WriteDecimal(this NetworkWriter writer, decimal value) Parameters Type Name Description NetworkWriter writer Decimal value | Improve this Doc View Source WriteDouble(NetworkWriter, Double) Declaration public static void WriteDouble(this NetworkWriter writer, double value) Parameters Type Name Description NetworkWriter writer Double value | Improve this Doc View Source WriteGameObject(NetworkWriter, GameObject) Declaration public static void WriteGameObject(this NetworkWriter writer, GameObject value) Parameters Type Name Description NetworkWriter writer GameObject value | Improve this Doc View Source WriteGuid(NetworkWriter, Guid) Declaration public static void WriteGuid(this NetworkWriter writer, Guid value) Parameters Type Name Description NetworkWriter writer Guid value | Improve this Doc View Source WriteInt16(NetworkWriter, Int16) Declaration public static void WriteInt16(this NetworkWriter writer, short value) Parameters Type Name Description NetworkWriter writer Int16 value | Improve this Doc View Source WriteList<T>(NetworkWriter, List<T>) Declaration public static void WriteList<T>(this NetworkWriter writer, List<T> list) Parameters Type Name Description NetworkWriter writer List <T> list Type Parameters Name Description T | Improve this Doc View Source WriteMatrix4X4(NetworkWriter, Matrix4x4) Declaration public static void WriteMatrix4X4(this NetworkWriter writer, Matrix4x4 value) Parameters Type Name Description NetworkWriter writer Matrix4x4 value | Improve this Doc View Source WriteNetworkBehaviour(NetworkWriter, NetworkBehaviour) Declaration public static void WriteNetworkBehaviour(this NetworkWriter writer, NetworkBehaviour value) Parameters Type Name Description NetworkWriter writer NetworkBehaviour value | Improve this Doc View Source WriteNetworkIdentity(NetworkWriter, NetworkIdentity) Declaration public static void WriteNetworkIdentity(this NetworkWriter writer, NetworkIdentity value) Parameters Type Name Description NetworkWriter writer NetworkIdentity value | Improve this Doc View Source WritePackedInt32(NetworkWriter, Int32) Declaration public static void WritePackedInt32(this NetworkWriter writer, int i) Parameters Type Name Description NetworkWriter writer Int32 i | Improve this Doc View Source WritePackedInt64(NetworkWriter, Int64) Declaration public static void WritePackedInt64(this NetworkWriter writer, long i) Parameters Type Name Description NetworkWriter writer Int64 i | Improve this Doc View Source WritePackedUInt32(NetworkWriter, UInt32) Declaration public static void WritePackedUInt32(this NetworkWriter writer, uint value) Parameters Type Name Description NetworkWriter writer UInt32 value | Improve this Doc View Source WritePackedUInt64(NetworkWriter, UInt64) Declaration public static void WritePackedUInt64(this NetworkWriter writer, ulong value) Parameters Type Name Description NetworkWriter writer UInt64 value | Improve this Doc View Source WritePlane(NetworkWriter, Plane) Declaration public static void WritePlane(this NetworkWriter writer, Plane value) Parameters Type Name Description NetworkWriter writer Plane value | Improve this Doc View Source WriteQuaternion(NetworkWriter, Quaternion) Declaration public static void WriteQuaternion(this NetworkWriter writer, Quaternion value) Parameters Type Name Description NetworkWriter writer Quaternion value | Improve this Doc View Source WriteRay(NetworkWriter, Ray) Declaration public static void WriteRay(this NetworkWriter writer, Ray value) Parameters Type Name Description NetworkWriter writer Ray value | Improve this Doc View Source WriteRect(NetworkWriter, Rect) Declaration public static void WriteRect(this NetworkWriter writer, Rect value) Parameters Type Name Description NetworkWriter writer Rect value | Improve this Doc View Source WriteSByte(NetworkWriter, SByte) Declaration public static void WriteSByte(this NetworkWriter writer, sbyte value) Parameters Type Name Description NetworkWriter writer SByte value | Improve this Doc View Source WriteSingle(NetworkWriter, Single) Declaration public static void WriteSingle(this NetworkWriter writer, float value) Parameters Type Name Description NetworkWriter writer Single value | Improve this Doc View Source WriteString(NetworkWriter, String) Declaration public static void WriteString(this NetworkWriter writer, string value) Parameters Type Name Description NetworkWriter writer String value | Improve this Doc View Source WriteUInt16(NetworkWriter, UInt16) Declaration public static void WriteUInt16(this NetworkWriter writer, ushort value) Parameters Type Name Description NetworkWriter writer UInt16 value | Improve this Doc View Source WriteUri(NetworkWriter, Uri) Declaration public static void WriteUri(this NetworkWriter writer, Uri uri) Parameters Type Name Description NetworkWriter writer Uri uri | Improve this Doc View Source WriteVector2(NetworkWriter, Vector2) Declaration public static void WriteVector2(this NetworkWriter writer, Vector2 value) Parameters Type Name Description NetworkWriter writer Vector2 value | Improve this Doc View Source WriteVector2Int(NetworkWriter, Vector2Int) Declaration public static void WriteVector2Int(this NetworkWriter writer, Vector2Int value) Parameters Type Name Description NetworkWriter writer Vector2Int value | Improve this Doc View Source WriteVector3(NetworkWriter, Vector3) Declaration public static void WriteVector3(this NetworkWriter writer, Vector3 value) Parameters Type Name Description NetworkWriter writer Vector3 value | Improve this Doc View Source WriteVector3Int(NetworkWriter, Vector3Int) Declaration public static void WriteVector3Int(this NetworkWriter writer, Vector3Int value) Parameters Type Name Description NetworkWriter writer Vector3Int value | Improve this Doc View Source WriteVector4(NetworkWriter, Vector4) Declaration public static void WriteVector4(this NetworkWriter writer, Vector4 value) Parameters Type Name Description NetworkWriter writer Vector4 value"
  },
  "api/Mirage.NetworkWriterPool.html": {
    "href": "api/Mirage.NetworkWriterPool.html",
    "title": "Class NetworkWriterPool",
    "keywords": "Class NetworkWriterPool Pool of NetworkWriters Use this pool instead of NetworkWriter to reduce memory allocation Use Capacity to change size of pool Inheritance Object NetworkWriterPool Namespace : Mirage Assembly : doc.dll Syntax public static class NetworkWriterPool : object Properties | Improve this Doc View Source Capacity Size of the pool If pool is too small getting writers will causes memory allocation Default value: 100 Declaration public static int Capacity { get; set; } Property Value Type Description Int32 Methods | Improve this Doc View Source GetWriter() Get the next writer in the pool If pool is empty, creates a new Writer Declaration public static PooledNetworkWriter GetWriter() Returns Type Description PooledNetworkWriter | Improve this Doc View Source Recycle(PooledNetworkWriter) Puts writer back into pool When pool is full, the extra writer is left for the GC Declaration public static void Recycle(PooledNetworkWriter writer) Parameters Type Name Description PooledNetworkWriter writer"
  },
  "api/Mirage.NotifyAck.html": {
    "href": "api/Mirage.NotifyAck.html",
    "title": "Struct NotifyAck",
    "keywords": "Struct NotifyAck Namespace : Mirage Assembly : doc.dll Syntax public struct NotifyAck"
  },
  "api/Mirage.NotifyPacket.html": {
    "href": "api/Mirage.NotifyPacket.html",
    "title": "Struct NotifyPacket",
    "keywords": "Struct NotifyPacket Namespace : Mirage Assembly : doc.dll Syntax public struct NotifyPacket Fields | Improve this Doc View Source AckMask Declaration public ulong AckMask Field Value Type Description UInt64 | Improve this Doc View Source ReceiveSequence Declaration public ushort ReceiveSequence Field Value Type Description UInt16 | Improve this Doc View Source Sequence Declaration public ushort Sequence Field Value Type Description UInt16"
  },
  "api/Mirage.NotifyPacketSerializer.html": {
    "href": "api/Mirage.NotifyPacketSerializer.html",
    "title": "Class NotifyPacketSerializer",
    "keywords": "Class NotifyPacketSerializer Inheritance Object NotifyPacketSerializer Namespace : Mirage Assembly : doc.dll Syntax public static class NotifyPacketSerializer : object Methods | Improve this Doc View Source ReadNotifyPacket(NetworkReader) Declaration public static NotifyPacket ReadNotifyPacket(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description NotifyPacket | Improve this Doc View Source WriteNotifyPacket(NetworkWriter, NotifyPacket) Declaration public static void WriteNotifyPacket(this NetworkWriter writer, NotifyPacket packet) Parameters Type Name Description NetworkWriter writer NotifyPacket packet"
  },
  "api/Mirage.NotReadyMessage.html": {
    "href": "api/Mirage.NotReadyMessage.html",
    "title": "Struct NotReadyMessage",
    "keywords": "Struct NotReadyMessage Namespace : Mirage Assembly : doc.dll Syntax public struct NotReadyMessage"
  },
  "api/Mirage.ObjectDestroyMessage.html": {
    "href": "api/Mirage.ObjectDestroyMessage.html",
    "title": "Struct ObjectDestroyMessage",
    "keywords": "Struct ObjectDestroyMessage Namespace : Mirage Assembly : doc.dll Syntax public struct ObjectDestroyMessage Fields | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description UInt32"
  },
  "api/Mirage.ObjectHideMessage.html": {
    "href": "api/Mirage.ObjectHideMessage.html",
    "title": "Struct ObjectHideMessage",
    "keywords": "Struct ObjectHideMessage Namespace : Mirage Assembly : doc.dll Syntax public struct ObjectHideMessage Fields | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description UInt32"
  },
  "api/Mirage.ObjectReady.html": {
    "href": "api/Mirage.ObjectReady.html",
    "title": "Class ObjectReady",
    "keywords": "Class ObjectReady Inheritance Object NetworkBehaviour ObjectReady Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.ServerObjectManager NetworkBehaviour.Client NetworkBehaviour.ClientObjectManager NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendServerRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendServerRpcWithReturn<T>(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32, Boolean) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.IsDirty() NetworkBehaviour.StillDirty() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirage Assembly : doc.dll Syntax public class ObjectReady : NetworkBehaviour Fields | Improve this Doc View Source IsReady Declaration public bool IsReady Field Value Type Description Boolean Methods | Improve this Doc View Source Ready() Declaration public void Ready() | Improve this Doc View Source SetClientNotReady() Declaration public void SetClientNotReady() | Improve this Doc View Source SetClientReady() Declaration public void SetClientReady()"
  },
  "api/Mirage.OnlineOfflineScene.html": {
    "href": "api/Mirage.OnlineOfflineScene.html",
    "title": "Class OnlineOfflineScene",
    "keywords": "Class OnlineOfflineScene Inheritance Object OnlineOfflineScene Namespace : Mirage Assembly : doc.dll Syntax public class OnlineOfflineScene : MonoBehaviour Fields | Improve this Doc View Source Client Declaration public NetworkClient Client Field Value Type Description NetworkClient | Improve this Doc View Source OfflineScene Declaration public string OfflineScene Field Value Type Description String | Improve this Doc View Source OnlineScene Declaration public string OnlineScene Field Value Type Description String | Improve this Doc View Source Server Declaration public NetworkServer Server Field Value Type Description NetworkServer"
  },
  "api/Mirage.PipeConnection.html": {
    "href": "api/Mirage.PipeConnection.html",
    "title": "Class PipeConnection",
    "keywords": "Class PipeConnection A connection that is directly connected to another connection If you send data in one of them, you receive it on the other one Inheritance Object PipeConnection Implements IConnection Namespace : Mirage Assembly : doc.dll Syntax public class PipeConnection : object, IConnection Methods | Improve this Doc View Source CreatePipe() Declaration public static (IConnection, IConnection) CreatePipe() Returns Type Description ValueTuple < IConnection , IConnection > | Improve this Doc View Source Disconnect() Declaration public void Disconnect() | Improve this Doc View Source GetEndPointAddress() Declaration public EndPoint GetEndPointAddress() Returns Type Description EndPoint | Improve this Doc View Source ReceiveAsync(MemoryStream) Declaration public UniTask<int> ReceiveAsync(MemoryStream buffer) Parameters Type Name Description MemoryStream buffer Returns Type Description UniTask < Int32 > | Improve this Doc View Source SendAsync(ArraySegment<Byte>, Int32) Declaration public UniTask SendAsync(ArraySegment<byte> data, int channel = null) Parameters Type Name Description ArraySegment < Byte > data Int32 channel Returns Type Description UniTask Implements IConnection"
  },
  "api/Mirage.PlayerSpawner.html": {
    "href": "api/Mirage.PlayerSpawner.html",
    "title": "Class PlayerSpawner",
    "keywords": "Class PlayerSpawner Spawns a player as soon as the connection is authenticated Inheritance Object PlayerSpawner Namespace : Mirage Assembly : doc.dll Syntax public class PlayerSpawner : MonoBehaviour Fields | Improve this Doc View Source AutoSpawn Whether to span the player upon connection automatically Declaration public bool AutoSpawn Field Value Type Description Boolean | Improve this Doc View Source Client Declaration public NetworkClient Client Field Value Type Description NetworkClient | Improve this Doc View Source ClientObjectManager Declaration public ClientObjectManager ClientObjectManager Field Value Type Description ClientObjectManager | Improve this Doc View Source PlayerPrefab Declaration public NetworkIdentity PlayerPrefab Field Value Type Description NetworkIdentity | Improve this Doc View Source playerSpawnMethod The current method of spawning players used by the PlayerSpawner. Declaration public PlayerSpawner.PlayerSpawnMethod playerSpawnMethod Field Value Type Description PlayerSpawner.PlayerSpawnMethod | Improve this Doc View Source SceneManager Declaration public NetworkSceneManager SceneManager Field Value Type Description NetworkSceneManager | Improve this Doc View Source Server Declaration public NetworkServer Server Field Value Type Description NetworkServer | Improve this Doc View Source ServerObjectManager Declaration public ServerObjectManager ServerObjectManager Field Value Type Description ServerObjectManager | Improve this Doc View Source startPositionIndex Declaration public int startPositionIndex Field Value Type Description Int32 | Improve this Doc View Source startPositions List of transforms where players can be spawned Declaration public List<Transform> startPositions Field Value Type Description List < Transform > Methods | Improve this Doc View Source GetStartPosition() This finds a spawn position based on start position objects in the scene. This is used by the default implementation of OnServerAddPlayer. Declaration public virtual Transform GetStartPosition() Returns Type Description Transform Returns the transform to spawn a player at, or null. | Improve this Doc View Source OnServerAddPlayer(INetworkConnection) Called on the server when a client adds a new player with ClientScene.AddPlayer. The default implementation for this function creates a new player object from the playerPrefab. Declaration public virtual void OnServerAddPlayer(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Connection from client. | Improve this Doc View Source RequestServerSpawnPlayer() Declaration public virtual void RequestServerSpawnPlayer() | Improve this Doc View Source Start() Declaration public virtual void Start()"
  },
  "api/Mirage.PlayerSpawner.PlayerSpawnMethod.html": {
    "href": "api/Mirage.PlayerSpawner.PlayerSpawnMethod.html",
    "title": "Enum PlayerSpawner.PlayerSpawnMethod",
    "keywords": "Enum PlayerSpawner.PlayerSpawnMethod Enumeration of methods of where to spawn player objects in multiplayer games. Namespace : Mirage Assembly : doc.dll Syntax public enum PlayerSpawnMethod : int Fields Name Description Random RoundRobin"
  },
  "api/Mirage.PooledNetworkReader.html": {
    "href": "api/Mirage.PooledNetworkReader.html",
    "title": "Class PooledNetworkReader",
    "keywords": "Class PooledNetworkReader NetworkReader to be used with NetworkReaderPool Inheritance Object NetworkReader PooledNetworkReader Implements IDisposable Inherited Members NetworkReader.Position NetworkReader.Length NetworkReader.ObjectLocator NetworkReader.ReadByte() NetworkReader.ReadInt32() NetworkReader.ReadUInt32() NetworkReader.ReadInt64() NetworkReader.ReadUInt64() NetworkReader.ReadBytes(Byte[], Int32) NetworkReader.ReadBytesSegment(Int32) NetworkReader.ToString() NetworkReader.Read<T>() Namespace : Mirage Assembly : doc.dll Syntax public sealed class PooledNetworkReader : NetworkReader, IDisposable Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() Implements IDisposable Extension Methods GameObjectSerializers.ReadGameObjectSyncVar(NetworkReader) NetworkBehaviorSerializers.ReadNetworkBehaviourSyncVar(NetworkReader) NetworkIdentitySerializers.ReadNetworkIdentitySyncVar(NetworkReader) NetworkReaderExtensions.ReadByte(NetworkReader) NetworkReaderExtensions.ReadSByte(NetworkReader) NetworkReaderExtensions.ReadChar(NetworkReader) NetworkReaderExtensions.ReadBoolean(NetworkReader) NetworkReaderExtensions.ReadInt16(NetworkReader) NetworkReaderExtensions.ReadUInt16(NetworkReader) NetworkReaderExtensions.ReadInt32(NetworkReader) NetworkReaderExtensions.ReadUInt32(NetworkReader) NetworkReaderExtensions.ReadInt64(NetworkReader) NetworkReaderExtensions.ReadUInt64(NetworkReader) NetworkReaderExtensions.ReadSingle(NetworkReader) NetworkReaderExtensions.ReadDouble(NetworkReader) NetworkReaderExtensions.ReadDecimal(NetworkReader) NetworkReaderExtensions.ReadString(NetworkReader) NetworkReaderExtensions.ReadBytesAndSize(NetworkReader) NetworkReaderExtensions.ReadBytesAndSizeSegment(NetworkReader) NetworkReaderExtensions.ReadPackedInt32(NetworkReader) NetworkReaderExtensions.ReadPackedUInt32(NetworkReader) NetworkReaderExtensions.ReadPackedInt64(NetworkReader) NetworkReaderExtensions.ReadPackedUInt64(NetworkReader) NetworkReaderExtensions.ReadVector2(NetworkReader) NetworkReaderExtensions.ReadVector3(NetworkReader) NetworkReaderExtensions.ReadVector4(NetworkReader) NetworkReaderExtensions.ReadVector2Int(NetworkReader) NetworkReaderExtensions.ReadVector3Int(NetworkReader) NetworkReaderExtensions.ReadColor(NetworkReader) NetworkReaderExtensions.ReadColor32(NetworkReader) NetworkReaderExtensions.ReadQuaternion(NetworkReader) NetworkReaderExtensions.ReadRect(NetworkReader) NetworkReaderExtensions.ReadPlane(NetworkReader) NetworkReaderExtensions.ReadRay(NetworkReader) NetworkReaderExtensions.ReadMatrix4x4(NetworkReader) NetworkReaderExtensions.ReadBytes(NetworkReader, Int32) NetworkReaderExtensions.ReadGuid(NetworkReader) NetworkReaderExtensions.ReadNetworkIdentity(NetworkReader) NetworkReaderExtensions.ReadList<T>(NetworkReader) NetworkReaderExtensions.ReadArray<T>(NetworkReader) NetworkReaderExtensions.ReadUri(NetworkReader) NetworkReaderExtensions.ReadNetworkBehaviour(NetworkReader) NetworkReaderExtensions.ReadNetworkBehaviour<T>(NetworkReader) NetworkReaderExtensions.ReadGameObject(NetworkReader) NotifyPacketSerializer.ReadNotifyPacket(NetworkReader)"
  },
  "api/Mirage.PooledNetworkWriter.html": {
    "href": "api/Mirage.PooledNetworkWriter.html",
    "title": "Class PooledNetworkWriter",
    "keywords": "Class PooledNetworkWriter NetworkWriter to be used with NetworkWriterPool Inheritance Object NetworkWriter PooledNetworkWriter Implements IDisposable Inherited Members NetworkWriter.MaxStringLength NetworkWriter.Length NetworkWriter.Position NetworkWriter.Reset() NetworkWriter.SetLength(Int32) NetworkWriter.ToArray() NetworkWriter.ToArraySegment() NetworkWriter.WriteByte(Byte) NetworkWriter.WriteBytes(Byte[], Int32, Int32) NetworkWriter.WriteUInt32(UInt32) NetworkWriter.WriteInt32(Int32) NetworkWriter.WriteUInt64(UInt64) NetworkWriter.WriteInt64(Int64) NetworkWriter.Write<T>(T) Namespace : Mirage Assembly : doc.dll Syntax public sealed class PooledNetworkWriter : NetworkWriter, IDisposable Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() Implements IDisposable Extension Methods GameObjectSerializers.WriteGameObjectSyncVar(NetworkWriter, GameObjectSyncvar) NetworkBehaviorSerializers.WriteNetworkBehaviorSyncVar(NetworkWriter, NetworkBehaviorSyncvar) NetworkIdentitySerializers.WriteNetworkIdentitySyncVar(NetworkWriter, NetworkIdentitySyncvar) NetworkWriterExtensions.WriteByte(NetworkWriter, Byte) NetworkWriterExtensions.WriteSByte(NetworkWriter, SByte) NetworkWriterExtensions.WriteChar(NetworkWriter, Char) NetworkWriterExtensions.WriteBoolean(NetworkWriter, Boolean) NetworkWriterExtensions.WriteUInt16(NetworkWriter, UInt16) NetworkWriterExtensions.WriteInt16(NetworkWriter, Int16) NetworkWriterExtensions.WriteSingle(NetworkWriter, Single) NetworkWriterExtensions.WriteDouble(NetworkWriter, Double) NetworkWriterExtensions.WriteDecimal(NetworkWriter, Decimal) NetworkWriterExtensions.WriteString(NetworkWriter, String) NetworkWriterExtensions.WriteBytesAndSize(NetworkWriter, Byte[], Int32, Int32) NetworkWriterExtensions.WriteBytesAndSize(NetworkWriter, Byte[]) NetworkWriterExtensions.WriteBytesAndSizeSegment(NetworkWriter, ArraySegment<Byte>) NetworkWriterExtensions.WritePackedInt32(NetworkWriter, Int32) NetworkWriterExtensions.WritePackedUInt32(NetworkWriter, UInt32) NetworkWriterExtensions.WritePackedInt64(NetworkWriter, Int64) NetworkWriterExtensions.WritePackedUInt64(NetworkWriter, UInt64) NetworkWriterExtensions.WriteVector2(NetworkWriter, Vector2) NetworkWriterExtensions.WriteVector3(NetworkWriter, Vector3) NetworkWriterExtensions.WriteVector4(NetworkWriter, Vector4) NetworkWriterExtensions.WriteVector2Int(NetworkWriter, Vector2Int) NetworkWriterExtensions.WriteVector3Int(NetworkWriter, Vector3Int) NetworkWriterExtensions.WriteColor(NetworkWriter, Color) NetworkWriterExtensions.WriteColor32(NetworkWriter, Color32) NetworkWriterExtensions.WriteQuaternion(NetworkWriter, Quaternion) NetworkWriterExtensions.WriteRect(NetworkWriter, Rect) NetworkWriterExtensions.WritePlane(NetworkWriter, Plane) NetworkWriterExtensions.WriteRay(NetworkWriter, Ray) NetworkWriterExtensions.WriteMatrix4X4(NetworkWriter, Matrix4x4) NetworkWriterExtensions.WriteGuid(NetworkWriter, Guid) NetworkWriterExtensions.WriteNetworkIdentity(NetworkWriter, NetworkIdentity) NetworkWriterExtensions.WriteUri(NetworkWriter, Uri) NetworkWriterExtensions.WriteList<T>(NetworkWriter, List<T>) NetworkWriterExtensions.WriteArray<T>(NetworkWriter, T[]) NetworkWriterExtensions.WriteArraySegment<T>(NetworkWriter, ArraySegment<T>) NetworkWriterExtensions.WriteNetworkBehaviour(NetworkWriter, NetworkBehaviour) NetworkWriterExtensions.WriteGameObject(NetworkWriter, GameObject) NotifyPacketSerializer.WriteNotifyPacket(NetworkWriter, NotifyPacket)"
  },
  "api/Mirage.Reader-1.html": {
    "href": "api/Mirage.Reader-1.html",
    "title": "Class Reader<T>",
    "keywords": "Class Reader<T> a class that holds readers for the different types Note that c# creates a different static variable for each type This will be populated by the weaver Inheritance Object Reader<T> Namespace : Mirage Assembly : doc.dll Syntax public static class Reader<T> : object Type Parameters Name Description T Properties | Improve this Doc View Source Read Declaration public static Func<NetworkReader, T> Read { set; } Property Value Type Description Func < NetworkReader , T>"
  },
  "api/Mirage.ReadyMessage.html": {
    "href": "api/Mirage.ReadyMessage.html",
    "title": "Struct ReadyMessage",
    "keywords": "Struct ReadyMessage Namespace : Mirage Assembly : doc.dll Syntax public struct ReadyMessage"
  },
  "api/Mirage.RemoteCalls.CmdDelegate.html": {
    "href": "api/Mirage.RemoteCalls.CmdDelegate.html",
    "title": "Delegate CmdDelegate",
    "keywords": "Delegate CmdDelegate Delegate for ServerRpc functions. Namespace : Mirage.RemoteCalls Assembly : doc.dll Syntax public delegate void CmdDelegate(NetworkBehaviour obj, NetworkReader reader, INetworkConnection senderConnection, int replyId); Parameters Type Name Description NetworkBehaviour obj NetworkReader reader INetworkConnection senderConnection Int32 replyId"
  },
  "api/Mirage.RemoteCalls.html": {
    "href": "api/Mirage.RemoteCalls.html",
    "title": "Namespace Mirage.RemoteCalls",
    "keywords": "Namespace Mirage.RemoteCalls Classes RemoteCallHelper Used to help manage remote calls for NetworkBehaviours Delegates CmdDelegate Delegate for ServerRpc functions. RequestDelegate<T>"
  },
  "api/Mirage.RemoteCalls.RemoteCallHelper.html": {
    "href": "api/Mirage.RemoteCalls.RemoteCallHelper.html",
    "title": "Class RemoteCallHelper",
    "keywords": "Class RemoteCallHelper Used to help manage remote calls for NetworkBehaviours Inheritance Object RemoteCallHelper Namespace : Mirage.RemoteCalls Assembly : doc.dll Syntax public static class RemoteCallHelper : object Methods | Improve this Doc View Source GetDelegate(Int32) Gets the handler function for a given hash Can be used by profilers and debuggers Declaration public static CmdDelegate GetDelegate(int cmdHash) Parameters Type Name Description Int32 cmdHash rpc function hash Returns Type Description CmdDelegate The function delegate that will handle the ServerRpc | Improve this Doc View Source RegisterDelegate(Type, String, MirageInvokeType, CmdDelegate, Boolean) helper function register a ServerRpc/Rpc delegate Declaration public static int RegisterDelegate(Type invokeClass, string cmdName, MirageInvokeType invokerType, CmdDelegate func, bool cmdRequireAuthority = true) Parameters Type Name Description Type invokeClass String cmdName MirageInvokeType invokerType CmdDelegate func Boolean cmdRequireAuthority Returns Type Description Int32 remote function hash | Improve this Doc View Source RegisterRequestDelegate<T>(Type, String, RequestDelegate<T>, Boolean) Declaration public static void RegisterRequestDelegate<T>(Type invokeClass, string cmdName, RequestDelegate<T> func, bool cmdRequireAuthority = true) Parameters Type Name Description Type invokeClass String cmdName RequestDelegate <T> func Boolean cmdRequireAuthority Type Parameters Name Description T | Improve this Doc View Source RegisterRpcDelegate(Type, String, CmdDelegate) Declaration public static void RegisterRpcDelegate(Type invokeClass, string rpcName, CmdDelegate func) Parameters Type Name Description Type invokeClass String rpcName CmdDelegate func | Improve this Doc View Source RegisterServerRpcDelegate(Type, String, CmdDelegate, Boolean) Declaration public static void RegisterServerRpcDelegate(Type invokeClass, string cmdName, CmdDelegate func, bool requireAuthority) Parameters Type Name Description Type invokeClass String cmdName CmdDelegate func Boolean requireAuthority"
  },
  "api/Mirage.RemoteCalls.RequestDelegate-1.html": {
    "href": "api/Mirage.RemoteCalls.RequestDelegate-1.html",
    "title": "Delegate RequestDelegate<T>",
    "keywords": "Delegate RequestDelegate<T> Namespace : Mirage.RemoteCalls Assembly : doc.dll Syntax public delegate UniTask<T> RequestDelegate<T>(NetworkBehaviour obj, NetworkReader reader, INetworkConnection senderConnection, int replyId); Parameters Type Name Description NetworkBehaviour obj NetworkReader reader INetworkConnection senderConnection Int32 replyId Returns Type Description UniTask <T> Type Parameters Name Description T"
  },
  "api/Mirage.RpcMessage.html": {
    "href": "api/Mirage.RpcMessage.html",
    "title": "Struct RpcMessage",
    "keywords": "Struct RpcMessage Namespace : Mirage Assembly : doc.dll Syntax public struct RpcMessage Fields | Improve this Doc View Source componentIndex Declaration public int componentIndex Field Value Type Description Int32 | Improve this Doc View Source functionHash Declaration public int functionHash Field Value Type Description Int32 | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < Byte >"
  },
  "api/Mirage.SceneAttribute.html": {
    "href": "api/Mirage.SceneAttribute.html",
    "title": "Class SceneAttribute",
    "keywords": "Class SceneAttribute Converts a string property into a Scene property in the inspector Inheritance Object SceneAttribute Namespace : Mirage Assembly : doc.dll Syntax public class SceneAttribute : PropertyAttribute"
  },
  "api/Mirage.SceneMessage.html": {
    "href": "api/Mirage.SceneMessage.html",
    "title": "Struct SceneMessage",
    "keywords": "Struct SceneMessage Namespace : Mirage Assembly : doc.dll Syntax public struct SceneMessage Fields | Improve this Doc View Source additiveScenes Declaration public string[] additiveScenes Field Value Type Description String [] | Improve this Doc View Source sceneOperation Declaration public SceneOperation sceneOperation Field Value Type Description SceneOperation | Improve this Doc View Source scenePath Declaration public string scenePath Field Value Type Description String"
  },
  "api/Mirage.SceneOperation.html": {
    "href": "api/Mirage.SceneOperation.html",
    "title": "Enum SceneOperation",
    "keywords": "Enum SceneOperation Namespace : Mirage Assembly : doc.dll Syntax public enum SceneOperation : byte Fields Name Description LoadAdditive Normal UnloadAdditive"
  },
  "api/Mirage.SceneReadyMessage.html": {
    "href": "api/Mirage.SceneReadyMessage.html",
    "title": "Struct SceneReadyMessage",
    "keywords": "Struct SceneReadyMessage Namespace : Mirage Assembly : doc.dll Syntax public struct SceneReadyMessage"
  },
  "api/Mirage.Sequencer.html": {
    "href": "api/Mirage.Sequencer.html",
    "title": "Struct Sequencer",
    "keywords": "Struct Sequencer Namespace : Mirage Assembly : doc.dll Syntax public struct Sequencer Constructors | Improve this Doc View Source Sequencer(Int32) Declaration public Sequencer(int bits) Parameters Type Name Description Int32 bits Properties | Improve this Doc View Source Bits Declaration public int Bits { get; } Property Value Type Description Int32 Methods | Improve this Doc View Source Distance(UInt64, UInt64) Declaration public long Distance(ulong from, ulong to) Parameters Type Name Description UInt64 from UInt64 to Returns Type Description Int64 | Improve this Doc View Source Next() Declaration public ulong Next() Returns Type Description UInt64 | Improve this Doc View Source NextAfter(UInt64) Declaration public ulong NextAfter(ulong sequence) Parameters Type Name Description UInt64 sequence Returns Type Description UInt64"
  },
  "api/Mirage.ServerAttribute.html": {
    "href": "api/Mirage.ServerAttribute.html",
    "title": "Class ServerAttribute",
    "keywords": "Class ServerAttribute Prevents clients from running this method. Inheritance Object ServerAttribute Namespace : Mirage Assembly : doc.dll Syntax public class ServerAttribute : Attribute Fields | Improve this Doc View Source error If true, when the method is called from a client, it throws an error If false, no error is thrown, but the method won't execute useful for unity built in methods such as Await, Update, Start, etc. Declaration public bool error Field Value Type Description Boolean"
  },
  "api/Mirage.ServerObjectManager.html": {
    "href": "api/Mirage.ServerObjectManager.html",
    "title": "Class ServerObjectManager",
    "keywords": "Class ServerObjectManager The ServerObjectManager. Inheritance Object ServerObjectManager Implements IServerObjectManager IObjectLocator Namespace : Mirage Assembly : doc.dll Syntax public class ServerObjectManager : MonoBehaviour, IServerObjectManager, IObjectLocator Remarks The set of networked objects that have been spawned is managed by ServerObjectManager. Objects are spawned with ServerObjectManager.Spawn() which adds them to this set, and makes them be created on clients. Spawned objects are removed automatically when they are destroyed, or than they can be removed from the spawned set by calling ServerObjectManager.UnSpawn() - this does not destroy the object. Fields | Improve this Doc View Source DirtyObjects Declaration public readonly HashSet<NetworkIdentity> DirtyObjects Field Value Type Description HashSet < NetworkIdentity > | Improve this Doc View Source NetworkSceneManager Declaration public NetworkSceneManager NetworkSceneManager Field Value Type Description NetworkSceneManager | Improve this Doc View Source Server Declaration public NetworkServer Server Field Value Type Description NetworkServer | Improve this Doc View Source SpawnedObjects Declaration public readonly Dictionary<uint, NetworkIdentity> SpawnedObjects Field Value Type Description Dictionary < UInt32 , NetworkIdentity > Properties | Improve this Doc View Source Item[UInt32] Declaration public NetworkIdentity this[uint netId] { get; } Parameters Type Name Description UInt32 netId Property Value Type Description NetworkIdentity | Improve this Doc View Source Spawned Declaration public SpawnEvent Spawned { get; } Property Value Type Description SpawnEvent | Improve this Doc View Source UnSpawned Declaration public SpawnEvent UnSpawned { get; } Property Value Type Description SpawnEvent Methods | Improve this Doc View Source AddPlayerForConnection(INetworkConnection, GameObject) When an AddPlayer message handler has received a request from a player, the server calls this to associate the player object with the connection. When a player is added for a connection, the client for that connection is made ready automatically. The player object is automatically spawned, so you do not need to call NetworkServer.Spawn for that object. This function is used for \"adding\" a player, not for \"replacing\" the player on a connection. If there is already a player on this playerControllerId for this connection, this will fail. Declaration public bool AddPlayerForConnection(INetworkConnection conn, GameObject player) Parameters Type Name Description INetworkConnection conn Connection which is adding the player. GameObject player Player object spawned for the player. Returns Type Description Boolean | Improve this Doc View Source AddPlayerForConnection(INetworkConnection, GameObject, Guid) When an AddPlayer message handler has received a request from a player, the server calls this to associate the player object with the connection. When a player is added for a connection, the client for that connection is made ready automatically. The player object is automatically spawned, so you do not need to call NetworkServer.Spawn for that object. This function is used for \"adding\" a player, not for \"replacing\" the player on a connection. If there is already a player on this playerControllerId for this connection, this will fail. Declaration public bool AddPlayerForConnection(INetworkConnection conn, GameObject player, Guid assetId) Parameters Type Name Description INetworkConnection conn Connection which is adding the player. GameObject player Player object spawned for the player. Guid assetId Returns Type Description Boolean | Improve this Doc View Source Destroy(GameObject) Destroys this object and corresponding objects on all clients. In some cases it is useful to remove an object but not delete it on the server. For that, use NetworkServer.UnSpawn() instead of NetworkServer.Destroy(). Declaration public void Destroy(GameObject obj) Parameters Type Name Description GameObject obj Game object to destroy. | Improve this Doc View Source RemovePlayerForConnection(INetworkConnection, Boolean) Removes the player object from the connection Declaration public void RemovePlayerForConnection(INetworkConnection conn, bool destroyServerObject = false) Parameters Type Name Description INetworkConnection conn The connection of the client to remove from Boolean destroyServerObject Indicates whether the server object should be destroyed | Improve this Doc View Source ReplacePlayerForConnection(INetworkConnection, NetworkClient, GameObject, Guid, Boolean) This replaces the player object for a connection with a different player object. The old player object is not destroyed. If a connection already has a player object, this can be used to replace that object with a different player object. This does NOT change the ready state of the connection, so it can safely be used while changing scenes. Declaration public bool ReplacePlayerForConnection(INetworkConnection conn, NetworkClient client, GameObject player, Guid assetId, bool keepAuthority = false) Parameters Type Name Description INetworkConnection conn Connection which is adding the player. NetworkClient client Client associated to the player. GameObject player Player object spawned for the player. Guid assetId Boolean keepAuthority Does the previous player remain attached to this connection? Returns Type Description Boolean | Improve this Doc View Source ReplacePlayerForConnection(INetworkConnection, NetworkClient, GameObject, Boolean) This replaces the player object for a connection with a different player object. The old player object is not destroyed. If a connection already has a player object, this can be used to replace that object with a different player object. This does NOT change the ready state of the connection, so it can safely be used while changing scenes. Declaration public bool ReplacePlayerForConnection(INetworkConnection conn, NetworkClient client, GameObject player, bool keepAuthority = false) Parameters Type Name Description INetworkConnection conn Connection which is adding the player. NetworkClient client Client associated to the player. GameObject player Player object spawned for the player. Boolean keepAuthority Does the previous player remain attached to this connection? Returns Type Description Boolean | Improve this Doc View Source SetAllClientsNotReady() Marks all connected clients as no longer ready. All clients will no longer be sent state synchronization updates. The player's clients can call ClientManager.Ready() again to re-enter the ready state. This is useful when switching scenes. Declaration public void SetAllClientsNotReady() | Improve this Doc View Source SetClientNotReady(INetworkConnection) Sets the client of the connection to be not-ready. Clients that are not ready do not receive spawned objects or state synchronization updates. They client can be made ready again by calling SetClientReady(). Declaration public void SetClientNotReady(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn The connection of the client to make not ready. | Improve this Doc View Source SetClientReady(INetworkConnection) Sets the client to be ready. When a client has signaled that it is ready, this method tells the server that the client is ready to receive spawned objects and state synchronization updates. This is usually called in a handler for the SYSTEM_READY message. If there is not specific action a game needs to take for this message, relying on the default ready handler function is probably fine, so this call wont be needed. Declaration public void SetClientReady(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn The connection of the client to make ready. | Improve this Doc View Source Spawn(GameObject, GameObject) This spawns an object like NetworkServer.Spawn() but also assigns Client Authority to the specified client. This is the same as calling NetworkIdentity.AssignClientAuthority on the spawned object. Declaration public void Spawn(GameObject obj, GameObject ownerPlayer) Parameters Type Name Description GameObject obj The object to spawn. GameObject ownerPlayer The player object to set Client Authority to. | Improve this Doc View Source Spawn(GameObject, Guid, INetworkConnection) This spawns an object like NetworkServer.Spawn() but also assigns Client Authority to the specified client. This is the same as calling NetworkIdentity.AssignClientAuthority on the spawned object. Declaration public void Spawn(GameObject obj, Guid assetId, INetworkConnection ownerConnection = null) Parameters Type Name Description GameObject obj The object to spawn. Guid assetId The assetId of the object to spawn. Used for custom spawn handlers. INetworkConnection ownerConnection The connection that has authority over the object | Improve this Doc View Source Spawn(GameObject, INetworkConnection) Spawn the given game object on all clients which are ready. This will cause a new object to be instantiated from the registered prefab, or from a custom spawn function. Declaration public void Spawn(GameObject obj, INetworkConnection ownerConnection = null) Parameters Type Name Description GameObject obj Game object with NetworkIdentity to spawn. INetworkConnection ownerConnection The connection that has authority over the object | Improve this Doc View Source Spawn(NetworkIdentity) This spawns an object. Declaration public void Spawn(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity The identity to spawn. | Improve this Doc View Source SpawnObjects() This causes NetworkIdentity objects in a scene to be spawned on a server. NetworkIdentity objects in a scene are disabled by default. Calling SpawnObjects() causes these scene objects to be enabled and spawned. It is like calling NetworkServer.Spawn() for each of them. Declaration public bool SpawnObjects() Returns Type Description Boolean Success if objects where spawned. | Improve this Doc View Source Start() Declaration public void Start() | Improve this Doc View Source UnSpawn(GameObject) This takes an object that has been spawned and un-spawns it. The object will be removed from clients that it was spawned on, or the custom spawn handler function on the client will be called for the object. Unlike when calling NetworkServer.Destroy(), on the server the object will NOT be destroyed. This allows the server to re-use the object, even spawn it again later. Declaration public void UnSpawn(GameObject obj) Parameters Type Name Description GameObject obj The spawned object to be unspawned. Implements IServerObjectManager IObjectLocator"
  },
  "api/Mirage.ServerRpcAttribute.html": {
    "href": "api/Mirage.ServerRpcAttribute.html",
    "title": "Class ServerRpcAttribute",
    "keywords": "Class ServerRpcAttribute Call this from a client to run this function on the server. Make sure to validate input etc. It's not possible to call this from a server. Inheritance Object ServerRpcAttribute Namespace : Mirage Assembly : doc.dll Syntax public class ServerRpcAttribute : Attribute Fields | Improve this Doc View Source channel Declaration public int channel Field Value Type Description Int32 | Improve this Doc View Source requireAuthority Declaration public bool requireAuthority Field Value Type Description Boolean"
  },
  "api/Mirage.ServerRpcMessage.html": {
    "href": "api/Mirage.ServerRpcMessage.html",
    "title": "Struct ServerRpcMessage",
    "keywords": "Struct ServerRpcMessage Namespace : Mirage Assembly : doc.dll Syntax public struct ServerRpcMessage Fields | Improve this Doc View Source componentIndex Declaration public int componentIndex Field Value Type Description Int32 | Improve this Doc View Source functionHash Declaration public int functionHash Field Value Type Description Int32 | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < Byte > | Improve this Doc View Source replyId Declaration public int replyId Field Value Type Description Int32"
  },
  "api/Mirage.ServerRpcReply.html": {
    "href": "api/Mirage.ServerRpcReply.html",
    "title": "Struct ServerRpcReply",
    "keywords": "Struct ServerRpcReply Namespace : Mirage Assembly : doc.dll Syntax public struct ServerRpcReply Fields | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < Byte > | Improve this Doc View Source replyId Declaration public int replyId Field Value Type Description Int32"
  },
  "api/Mirage.ShowInInspectorAttribute.html": {
    "href": "api/Mirage.ShowInInspectorAttribute.html",
    "title": "Class ShowInInspectorAttribute",
    "keywords": "Class ShowInInspectorAttribute Used to show private SyncList in the inspector, Use instead of SerializeField for non Serializable types Inheritance Object ShowInInspectorAttribute Namespace : Mirage Assembly : doc.dll Syntax public class ShowInInspectorAttribute : Attribute"
  },
  "api/Mirage.SpawnEvent.html": {
    "href": "api/Mirage.SpawnEvent.html",
    "title": "Class SpawnEvent",
    "keywords": "Class SpawnEvent Inheritance Object SpawnEvent Namespace : Mirage Assembly : doc.dll Syntax public class SpawnEvent : UnityEvent<NetworkIdentity>"
  },
  "api/Mirage.SpawnHandlerDelegate.html": {
    "href": "api/Mirage.SpawnHandlerDelegate.html",
    "title": "Delegate SpawnHandlerDelegate",
    "keywords": "Delegate SpawnHandlerDelegate Namespace : Mirage Assembly : doc.dll Syntax public delegate NetworkIdentity SpawnHandlerDelegate(SpawnMessage msg); Parameters Type Name Description SpawnMessage msg Returns Type Description NetworkIdentity"
  },
  "api/Mirage.SpawnMessage.html": {
    "href": "api/Mirage.SpawnMessage.html",
    "title": "Struct SpawnMessage",
    "keywords": "Struct SpawnMessage Namespace : Mirage Assembly : doc.dll Syntax public struct SpawnMessage Fields | Improve this Doc View Source assetId The id of the prefab to spawn If sceneId != 0 then it is used instead of assetId Declaration public Guid assetId Field Value Type Description Guid | Improve this Doc View Source isLocalPlayer Is the spawning object the local player. Sets ClientScene.localPlayer Declaration public bool isLocalPlayer Field Value Type Description Boolean | Improve this Doc View Source isOwner Sets hasAuthority on the spawned object Declaration public bool isOwner Field Value Type Description Boolean | Improve this Doc View Source netId netId of new or existing object Declaration public uint netId Field Value Type Description UInt32 | Improve this Doc View Source payload The serialized component data ArraySegment to avoid unnecessary allocations Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < Byte > | Improve this Doc View Source position Local position Declaration public Vector3 position Field Value Type Description Vector3 | Improve this Doc View Source rotation Local rotation Declaration public Quaternion rotation Field Value Type Description Quaternion | Improve this Doc View Source scale Local scale Declaration public Vector3 scale Field Value Type Description Vector3 | Improve this Doc View Source sceneId The id of the scene object to spawn Declaration public ulong sceneId Field Value Type Description UInt64"
  },
  "api/Mirage.StringHash.html": {
    "href": "api/Mirage.StringHash.html",
    "title": "Class StringHash",
    "keywords": "Class StringHash Inheritance Object StringHash Namespace : Mirage Assembly : doc.dll Syntax public static class StringHash : object Methods | Improve this Doc View Source GetStableHashCode(String) Declaration public static int GetStableHashCode(this string text) Parameters Type Name Description String text Returns Type Description Int32"
  },
  "api/Mirage.SyncDictionary-2.html": {
    "href": "api/Mirage.SyncDictionary-2.html",
    "title": "Class SyncDictionary<TKey, TValue>",
    "keywords": "Class SyncDictionary<TKey, TValue> Inheritance Object SyncIDictionary <TKey, TValue> SyncDictionary<TKey, TValue> Implements ISyncObject IReadOnlyDictionary <TKey, TValue> Inherited Members SyncIDictionary<TKey, TValue>.objects SyncIDictionary<TKey, TValue>.Count SyncIDictionary<TKey, TValue>.IsReadOnly SyncIDictionary<TKey, TValue>.OnInsert SyncIDictionary<TKey, TValue>.OnClear SyncIDictionary<TKey, TValue>.OnRemove SyncIDictionary<TKey, TValue>.OnSet SyncIDictionary<TKey, TValue>.OnChange SyncIDictionary<TKey, TValue>.Reset() SyncIDictionary<TKey, TValue>.IsDirty SyncIDictionary<TKey, TValue>.Keys SyncIDictionary<TKey, TValue>.Values SyncIDictionary<TKey, TValue>.Flush() SyncIDictionary<TKey, TValue>.OnSerializeAll(NetworkWriter) SyncIDictionary<TKey, TValue>.OnSerializeDelta(NetworkWriter) SyncIDictionary<TKey, TValue>.OnDeserializeAll(NetworkReader) SyncIDictionary<TKey, TValue>.OnDeserializeDelta(NetworkReader) SyncIDictionary<TKey, TValue>.Clear() SyncIDictionary<TKey, TValue>.ContainsKey(TKey) SyncIDictionary<TKey, TValue>.Remove(TKey) SyncIDictionary<TKey, TValue>.Item[TKey] SyncIDictionary<TKey, TValue>.TryGetValue(TKey, TValue) SyncIDictionary<TKey, TValue>.Add(TKey, TValue) SyncIDictionary<TKey, TValue>.Add(KeyValuePair<TKey, TValue>) SyncIDictionary<TKey, TValue>.Contains(KeyValuePair<TKey, TValue>) SyncIDictionary<TKey, TValue>.CopyTo(KeyValuePair<TKey, TValue>[], Int32) SyncIDictionary<TKey, TValue>.Remove(KeyValuePair<TKey, TValue>) SyncIDictionary<TKey, TValue>.GetEnumerator() Namespace : Mirage Assembly : doc.dll Syntax public class SyncDictionary<TKey, TValue> : SyncIDictionary<TKey, TValue>, ISyncObject, IReadOnlyDictionary<TKey, TValue> Type Parameters Name Description TKey TValue Constructors | Improve this Doc View Source SyncDictionary() Declaration public SyncDictionary() | Improve this Doc View Source SyncDictionary(IEqualityComparer<TKey>) Declaration public SyncDictionary(IEqualityComparer<TKey> eq) Parameters Type Name Description IEqualityComparer <TKey> eq Properties | Improve this Doc View Source Keys Declaration public Dictionary<TKey, TValue>.KeyCollection Keys { get; } Property Value Type Description Dictionary.KeyCollection <> | Improve this Doc View Source Values Declaration public Dictionary<TKey, TValue>.ValueCollection Values { get; } Property Value Type Description Dictionary.ValueCollection <> Methods | Improve this Doc View Source GetEnumerator() Declaration public Dictionary<TKey, TValue>.Enumerator GetEnumerator() Returns Type Description Dictionary.Enumerator <> Implements ISyncObject IReadOnlyDictionary<, >"
  },
  "api/Mirage.SyncHashSet-1.html": {
    "href": "api/Mirage.SyncHashSet-1.html",
    "title": "Class SyncHashSet<T>",
    "keywords": "Class SyncHashSet<T> Inheritance Object SyncSet <T> SyncHashSet<T> Implements ISyncObject Inherited Members SyncSet<T>.objects SyncSet<T>.Count SyncSet<T>.IsReadOnly SyncSet<T>.OnAdd SyncSet<T>.OnClear SyncSet<T>.OnRemove SyncSet<T>.OnChange SyncSet<T>.Reset() SyncSet<T>.IsDirty SyncSet<T>.Flush() SyncSet<T>.OnSerializeAll(NetworkWriter) SyncSet<T>.OnSerializeDelta(NetworkWriter) SyncSet<T>.OnDeserializeAll(NetworkReader) SyncSet<T>.OnDeserializeDelta(NetworkReader) SyncSet<T>.Add(T) SyncSet<T>.Clear() SyncSet<T>.Contains(T) SyncSet<T>.CopyTo(T[], Int32) SyncSet<T>.Remove(T) SyncSet<T>.ExceptWith(IEnumerable<T>) SyncSet<T>.IntersectWith(IEnumerable<T>) SyncSet<T>.IsProperSubsetOf(IEnumerable<T>) SyncSet<T>.IsProperSupersetOf(IEnumerable<T>) SyncSet<T>.IsSubsetOf(IEnumerable<T>) SyncSet<T>.IsSupersetOf(IEnumerable<T>) SyncSet<T>.Overlaps(IEnumerable<T>) SyncSet<T>.SetEquals(IEnumerable<T>) SyncSet<T>.SymmetricExceptWith(IEnumerable<T>) SyncSet<T>.UnionWith(IEnumerable<T>) Namespace : Mirage Assembly : doc.dll Syntax public class SyncHashSet<T> : SyncSet<T>, ISyncObject Type Parameters Name Description T Constructors | Improve this Doc View Source SyncHashSet() Declaration public SyncHashSet() | Improve this Doc View Source SyncHashSet(IEqualityComparer<T>) Declaration public SyncHashSet(IEqualityComparer<T> comparer) Parameters Type Name Description IEqualityComparer <T> comparer Methods | Improve this Doc View Source GetEnumerator() Declaration public HashSet<T>.Enumerator GetEnumerator() Returns Type Description HashSet.Enumerator <> Implements ISyncObject"
  },
  "api/Mirage.SyncIDictionary-2.html": {
    "href": "api/Mirage.SyncIDictionary-2.html",
    "title": "Class SyncIDictionary<TKey, TValue>",
    "keywords": "Class SyncIDictionary<TKey, TValue> Inheritance Object SyncIDictionary<TKey, TValue> SyncDictionary<TKey, TValue> Implements ISyncObject IReadOnlyDictionary <TKey, TValue> Namespace : Mirage Assembly : doc.dll Syntax public class SyncIDictionary<TKey, TValue> : IDictionary<TKey, TValue>, ISyncObject, IReadOnlyDictionary<TKey, TValue> Type Parameters Name Description TKey TValue Constructors | Improve this Doc View Source SyncIDictionary(IDictionary<TKey, TValue>) Declaration public SyncIDictionary(IDictionary<TKey, TValue> objects) Parameters Type Name Description IDictionary <TKey, TValue> objects Fields | Improve this Doc View Source objects Declaration protected readonly IDictionary<TKey, TValue> objects Field Value Type Description IDictionary <TKey, TValue> Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description Int32 | Improve this Doc View Source IsDirty Declaration public bool IsDirty { get; } Property Value Type Description Boolean | Improve this Doc View Source IsReadOnly Declaration public bool IsReadOnly { get; } Property Value Type Description Boolean | Improve this Doc View Source Item[TKey] Declaration public TValue this[TKey i] { get; set; } Parameters Type Name Description TKey i Property Value Type Description TValue | Improve this Doc View Source Keys Declaration public ICollection<TKey> Keys { get; } Property Value Type Description ICollection <TKey> | Improve this Doc View Source Values Declaration public ICollection<TValue> Values { get; } Property Value Type Description ICollection <TValue> Methods | Improve this Doc View Source Add(TKey, TValue) Declaration public void Add(TKey key, TValue value) Parameters Type Name Description TKey key TValue value | Improve this Doc View Source Add(KeyValuePair<TKey, TValue>) Declaration public void Add(KeyValuePair<TKey, TValue> item) Parameters Type Name Description KeyValuePair <TKey, TValue> item | Improve this Doc View Source Clear() Declaration public void Clear() | Improve this Doc View Source Contains(KeyValuePair<TKey, TValue>) Declaration public bool Contains(KeyValuePair<TKey, TValue> item) Parameters Type Name Description KeyValuePair <TKey, TValue> item Returns Type Description Boolean | Improve this Doc View Source ContainsKey(TKey) Declaration public bool ContainsKey(TKey key) Parameters Type Name Description TKey key Returns Type Description Boolean | Improve this Doc View Source CopyTo(KeyValuePair<TKey, TValue>[], Int32) Declaration public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex) Parameters Type Name Description KeyValuePair <TKey, TValue>[] array Int32 arrayIndex | Improve this Doc View Source Flush() Declaration public void Flush() | Improve this Doc View Source GetEnumerator() Declaration public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() Returns Type Description IEnumerator < KeyValuePair <TKey, TValue>> | Improve this Doc View Source OnDeserializeAll(NetworkReader) Declaration public void OnDeserializeAll(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnDeserializeDelta(NetworkReader) Declaration public void OnDeserializeDelta(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnSerializeAll(NetworkWriter) Declaration public void OnSerializeAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source OnSerializeDelta(NetworkWriter) Declaration public void OnSerializeDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source Remove(TKey) Declaration public bool Remove(TKey key) Parameters Type Name Description TKey key Returns Type Description Boolean | Improve this Doc View Source Remove(KeyValuePair<TKey, TValue>) Declaration public bool Remove(KeyValuePair<TKey, TValue> item) Parameters Type Name Description KeyValuePair <TKey, TValue> item Returns Type Description Boolean | Improve this Doc View Source Reset() Declaration public void Reset() | Improve this Doc View Source TryGetValue(TKey, out TValue) Declaration public bool TryGetValue(TKey key, out TValue value) Parameters Type Name Description TKey key TValue value Returns Type Description Boolean Events | Improve this Doc View Source OnChange Raised after the dictionary has been updated Note that if there are multiple changes this event is only raised once. Declaration public event Action OnChange Event Type Type Description Action | Improve this Doc View Source OnClear Raised when the dictionary is cleared Declaration public event Action OnClear Event Type Type Description Action | Improve this Doc View Source OnInsert Raised when an element is added to the dictionary. Receives the key and value of the new item Declaration public event Action<TKey, TValue> OnInsert Event Type Type Description Action <TKey, TValue> | Improve this Doc View Source OnRemove Raised when an item is removed from the dictionary receives the key and value of the old item Declaration public event Action<TKey, TValue> OnRemove Event Type Type Description Action <TKey, TValue> | Improve this Doc View Source OnSet Raised when an item is changed in a dictionary Receives key, the old value and the new value Declaration public event Action<TKey, TValue, TValue> OnSet Event Type Type Description Action <TKey, TValue, TValue> Implements ISyncObject IReadOnlyDictionary<, >"
  },
  "api/Mirage.SyncList-1.Enumerator.html": {
    "href": "api/Mirage.SyncList-1.Enumerator.html",
    "title": "Struct SyncList<T>.Enumerator",
    "keywords": "Struct SyncList<T>.Enumerator Implements IEnumerator <T> Namespace : Mirage Assembly : doc.dll Syntax public struct Enumerator : IEnumerator<T> Constructors | Improve this Doc View Source Enumerator(SyncList<T>) Declaration public Enumerator(SyncList<T> list) Parameters Type Name Description SyncList <T> list Properties | Improve this Doc View Source Current Declaration public T Current { get; } Property Value Type Description T Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() | Improve this Doc View Source MoveNext() Declaration public bool MoveNext() Returns Type Description Boolean | Improve this Doc View Source Reset() Declaration public void Reset() Implements IEnumerator<>"
  },
  "api/Mirage.SyncList-1.html": {
    "href": "api/Mirage.SyncList-1.html",
    "title": "Class SyncList<T>",
    "keywords": "Class SyncList<T> Inheritance Object SyncList<T> Implements IReadOnlyList <T> ISyncObject Namespace : Mirage Assembly : doc.dll Syntax public class SyncList<T> : IList<T>, IReadOnlyList<T>, ISyncObject Type Parameters Name Description T Constructors | Improve this Doc View Source SyncList() Declaration public SyncList() | Improve this Doc View Source SyncList(IEqualityComparer<T>) Declaration public SyncList(IEqualityComparer<T> comparer) Parameters Type Name Description IEqualityComparer <T> comparer | Improve this Doc View Source SyncList(IList<T>, IEqualityComparer<T>) Declaration public SyncList(IList<T> objects, IEqualityComparer<T> comparer = null) Parameters Type Name Description IList <T> objects IEqualityComparer <T> comparer Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description Int32 | Improve this Doc View Source IsDirty Declaration public bool IsDirty { get; } Property Value Type Description Boolean | Improve this Doc View Source IsReadOnly Declaration public bool IsReadOnly { get; } Property Value Type Description Boolean | Improve this Doc View Source Item[Int32] Declaration public T this[int i] { get; set; } Parameters Type Name Description Int32 i Property Value Type Description T Methods | Improve this Doc View Source Add(T) Declaration public void Add(T item) Parameters Type Name Description T item | Improve this Doc View Source AddRange(IEnumerable<T>) Declaration public void AddRange(IEnumerable<T> range) Parameters Type Name Description IEnumerable <T> range | Improve this Doc View Source Clear() Declaration public void Clear() | Improve this Doc View Source Contains(T) Declaration public bool Contains(T item) Parameters Type Name Description T item Returns Type Description Boolean | Improve this Doc View Source CopyTo(T[], Int32) Declaration public void CopyTo(T[] array, int arrayIndex) Parameters Type Name Description T[] array Int32 arrayIndex | Improve this Doc View Source Find(Predicate<T>) Declaration public T Find(Predicate<T> match) Parameters Type Name Description Predicate <T> match Returns Type Description T | Improve this Doc View Source FindAll(Predicate<T>) Declaration public List<T> FindAll(Predicate<T> match) Parameters Type Name Description Predicate <T> match Returns Type Description List <T> | Improve this Doc View Source FindIndex(Predicate<T>) Declaration public int FindIndex(Predicate<T> match) Parameters Type Name Description Predicate <T> match Returns Type Description Int32 | Improve this Doc View Source Flush() Declaration public void Flush() | Improve this Doc View Source GetEnumerator() Declaration public SyncList<T>.Enumerator GetEnumerator() Returns Type Description SyncList.Enumerator <> | Improve this Doc View Source IndexOf(T) Declaration public int IndexOf(T item) Parameters Type Name Description T item Returns Type Description Int32 | Improve this Doc View Source Insert(Int32, T) Declaration public void Insert(int index, T item) Parameters Type Name Description Int32 index T item | Improve this Doc View Source InsertRange(Int32, IEnumerable<T>) Declaration public void InsertRange(int index, IEnumerable<T> range) Parameters Type Name Description Int32 index IEnumerable <T> range | Improve this Doc View Source OnDeserializeAll(NetworkReader) Declaration public void OnDeserializeAll(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnDeserializeDelta(NetworkReader) Declaration public void OnDeserializeDelta(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnSerializeAll(NetworkWriter) Declaration public void OnSerializeAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source OnSerializeDelta(NetworkWriter) Declaration public void OnSerializeDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source Remove(T) Declaration public bool Remove(T item) Parameters Type Name Description T item Returns Type Description Boolean | Improve this Doc View Source RemoveAll(Predicate<T>) Declaration public int RemoveAll(Predicate<T> match) Parameters Type Name Description Predicate <T> match Returns Type Description Int32 | Improve this Doc View Source RemoveAt(Int32) Declaration public void RemoveAt(int index) Parameters Type Name Description Int32 index | Improve this Doc View Source Reset() Declaration public void Reset() Events | Improve this Doc View Source OnChange Raised after the list has been updated Note that if there are multiple changes this event is only raised once. Declaration public event Action OnChange Event Type Type Description Action | Improve this Doc View Source OnClear Raised when the list is cleared Declaration public event Action OnClear Event Type Type Description Action | Improve this Doc View Source OnInsert Raised when an element is added to the list. Receives index and new item Declaration public event Action<int, T> OnInsert Event Type Type Description Action < Int32 , T> | Improve this Doc View Source OnRemove Raised when an item is removed from the list receives the index and the old item Declaration public event Action<int, T> OnRemove Event Type Type Description Action < Int32 , T> | Improve this Doc View Source OnSet Raised when an item is changed in a list Receives index, old item and new item Declaration public event Action<int, T, T> OnSet Event Type Type Description Action < Int32 , T, T> Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirage.SyncMode.html": {
    "href": "api/Mirage.SyncMode.html",
    "title": "Enum SyncMode",
    "keywords": "Enum SyncMode Sync to everyone, or only to owner. Namespace : Mirage Assembly : doc.dll Syntax public enum SyncMode : int Fields Name Description Observers Owner"
  },
  "api/Mirage.SyncSet-1.html": {
    "href": "api/Mirage.SyncSet-1.html",
    "title": "Class SyncSet<T>",
    "keywords": "Class SyncSet<T> Inheritance Object SyncSet<T> SyncHashSet<T> SyncSortedSet<T> Implements ISyncObject Namespace : Mirage Assembly : doc.dll Syntax public class SyncSet<T> : ISet<T>, ISyncObject Type Parameters Name Description T Constructors | Improve this Doc View Source SyncSet(ISet<T>) Declaration public SyncSet(ISet<T> objects) Parameters Type Name Description ISet <T> objects Fields | Improve this Doc View Source objects Declaration protected readonly ISet<T> objects Field Value Type Description ISet <T> Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description Int32 | Improve this Doc View Source IsDirty Declaration public bool IsDirty { get; } Property Value Type Description Boolean | Improve this Doc View Source IsReadOnly Declaration public bool IsReadOnly { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source Add(T) Declaration public bool Add(T item) Parameters Type Name Description T item Returns Type Description Boolean | Improve this Doc View Source Clear() Declaration public void Clear() | Improve this Doc View Source Contains(T) Declaration public bool Contains(T item) Parameters Type Name Description T item Returns Type Description Boolean | Improve this Doc View Source CopyTo(T[], Int32) Declaration public void CopyTo(T[] array, int arrayIndex) Parameters Type Name Description T[] array Int32 arrayIndex | Improve this Doc View Source ExceptWith(IEnumerable<T>) Declaration public void ExceptWith(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other | Improve this Doc View Source Flush() Declaration public void Flush() | Improve this Doc View Source GetEnumerator() Declaration public IEnumerator<T> GetEnumerator() Returns Type Description IEnumerator <T> | Improve this Doc View Source IntersectWith(IEnumerable<T>) Declaration public void IntersectWith(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other | Improve this Doc View Source IsProperSubsetOf(IEnumerable<T>) Declaration public bool IsProperSubsetOf(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description Boolean | Improve this Doc View Source IsProperSupersetOf(IEnumerable<T>) Declaration public bool IsProperSupersetOf(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description Boolean | Improve this Doc View Source IsSubsetOf(IEnumerable<T>) Declaration public bool IsSubsetOf(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description Boolean | Improve this Doc View Source IsSupersetOf(IEnumerable<T>) Declaration public bool IsSupersetOf(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description Boolean | Improve this Doc View Source OnDeserializeAll(NetworkReader) Declaration public void OnDeserializeAll(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnDeserializeDelta(NetworkReader) Declaration public void OnDeserializeDelta(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnSerializeAll(NetworkWriter) Declaration public void OnSerializeAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source OnSerializeDelta(NetworkWriter) Declaration public void OnSerializeDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source Overlaps(IEnumerable<T>) Declaration public bool Overlaps(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description Boolean | Improve this Doc View Source Remove(T) Declaration public bool Remove(T item) Parameters Type Name Description T item Returns Type Description Boolean | Improve this Doc View Source Reset() Declaration public void Reset() | Improve this Doc View Source SetEquals(IEnumerable<T>) Declaration public bool SetEquals(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description Boolean | Improve this Doc View Source SymmetricExceptWith(IEnumerable<T>) Declaration public void SymmetricExceptWith(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other | Improve this Doc View Source UnionWith(IEnumerable<T>) Declaration public void UnionWith(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Events | Improve this Doc View Source OnAdd Raised when an element is added to the list. Receives the new item Declaration public event Action<T> OnAdd Event Type Type Description Action <T> | Improve this Doc View Source OnChange Raised after the set has been updated Note that if there are multiple changes this event is only raised once. Declaration public event Action OnChange Event Type Type Description Action | Improve this Doc View Source OnClear Raised when the set is cleared Declaration public event Action OnClear Event Type Type Description Action | Improve this Doc View Source OnRemove Raised when an item is removed from the set receives the old item Declaration public event Action<T> OnRemove Event Type Type Description Action <T> Implements ISyncObject"
  },
  "api/Mirage.SyncSortedSet-1.html": {
    "href": "api/Mirage.SyncSortedSet-1.html",
    "title": "Class SyncSortedSet<T>",
    "keywords": "Class SyncSortedSet<T> Inheritance Object SyncSet <T> SyncSortedSet<T> Implements ISyncObject Inherited Members SyncSet<T>.objects SyncSet<T>.Count SyncSet<T>.IsReadOnly SyncSet<T>.OnAdd SyncSet<T>.OnClear SyncSet<T>.OnRemove SyncSet<T>.OnChange SyncSet<T>.Reset() SyncSet<T>.IsDirty SyncSet<T>.Flush() SyncSet<T>.OnSerializeAll(NetworkWriter) SyncSet<T>.OnSerializeDelta(NetworkWriter) SyncSet<T>.OnDeserializeAll(NetworkReader) SyncSet<T>.OnDeserializeDelta(NetworkReader) SyncSet<T>.Add(T) SyncSet<T>.Clear() SyncSet<T>.Contains(T) SyncSet<T>.CopyTo(T[], Int32) SyncSet<T>.Remove(T) SyncSet<T>.ExceptWith(IEnumerable<T>) SyncSet<T>.IntersectWith(IEnumerable<T>) SyncSet<T>.IsProperSubsetOf(IEnumerable<T>) SyncSet<T>.IsProperSupersetOf(IEnumerable<T>) SyncSet<T>.IsSubsetOf(IEnumerable<T>) SyncSet<T>.IsSupersetOf(IEnumerable<T>) SyncSet<T>.Overlaps(IEnumerable<T>) SyncSet<T>.SetEquals(IEnumerable<T>) SyncSet<T>.SymmetricExceptWith(IEnumerable<T>) SyncSet<T>.UnionWith(IEnumerable<T>) Namespace : Mirage Assembly : doc.dll Syntax public class SyncSortedSet<T> : SyncSet<T>, ISyncObject Type Parameters Name Description T Constructors | Improve this Doc View Source SyncSortedSet() Declaration public SyncSortedSet() | Improve this Doc View Source SyncSortedSet(IComparer<T>) Declaration public SyncSortedSet(IComparer<T> comparer) Parameters Type Name Description IComparer <T> comparer Methods | Improve this Doc View Source GetEnumerator() Declaration public SortedSet<T>.Enumerator GetEnumerator() Returns Type Description SortedSet.Enumerator <> Implements ISyncObject"
  },
  "api/Mirage.SyncVarAttribute.html": {
    "href": "api/Mirage.SyncVarAttribute.html",
    "title": "Class SyncVarAttribute",
    "keywords": "Class SyncVarAttribute SyncVars are used to synchronize a variable from the server to all clients automatically. Value must be changed on server, not directly by clients. Hook parameter allows you to define a client-side method to be invoked when the client gets an update from the server. Inheritance Object SyncVarAttribute Namespace : Mirage Assembly : doc.dll Syntax public class SyncVarAttribute : PropertyAttribute Fields | Improve this Doc View Source hook A function that should be called on the client when the value changes. Declaration public string hook Field Value Type Description String"
  },
  "api/Mirage.Transport.ConnectEvent.html": {
    "href": "api/Mirage.Transport.ConnectEvent.html",
    "title": "Class Transport.ConnectEvent",
    "keywords": "Class Transport.ConnectEvent Inheritance Object Transport.ConnectEvent Namespace : Mirage Assembly : doc.dll Syntax public class ConnectEvent : UnityEvent<IConnection>"
  },
  "api/Mirage.Transport.html": {
    "href": "api/Mirage.Transport.html",
    "title": "Class Transport",
    "keywords": "Class Transport Base transport class, any transport should implement this class and it's abstract methods Inheritance Object Transport KcpTransport MultiplexTransport Namespace : Mirage Assembly : doc.dll Syntax public abstract class Transport : MonoBehaviour Fields | Improve this Doc View Source Connected Event that gets fired when a client is accepted by the transport Declaration public Transport.ConnectEvent Connected Field Value Type Description Transport.ConnectEvent | Improve this Doc View Source Started Raised when the transport starts Declaration public UnityEvent Started Field Value Type Description UnityEvent Properties | Improve this Doc View Source ReceivedBytes Gets the total amount of received data Declaration public virtual long ReceivedBytes { get; } Property Value Type Description Int64 | Improve this Doc View Source Scheme Declaration public abstract IEnumerable<string> Scheme { get; } Property Value Type Description IEnumerable < String > | Improve this Doc View Source SentBytes Gets the total amount of sent data Declaration public virtual long SentBytes { get; } Property Value Type Description Int64 | Improve this Doc View Source Supported Determines if this transport is supported in the current platform Declaration public abstract bool Supported { get; } Property Value Type Description Boolean true if the transport works in this platform Methods | Improve this Doc View Source ConnectAsync(Uri) Connect to a server located at a provided uri Declaration public abstract UniTask<IConnection> ConnectAsync(Uri uri) Parameters Type Name Description Uri uri address of the server to connect to Returns Type Description UniTask < IConnection > The connection to the server | Improve this Doc View Source Disconnect() Stop listening to the port Declaration public abstract void Disconnect() | Improve this Doc View Source ListenAsync() Open up the port and listen for connections Use in servers. Note the task ends when we stop listening Declaration public abstract UniTask ListenAsync() Returns Type Description UniTask | Improve this Doc View Source ServerUri() Retrieves the address of this server. Useful for network discovery Declaration public abstract IEnumerable<Uri> ServerUri() Returns Type Description IEnumerable < Uri > the url at which this server can be reached"
  },
  "api/Mirage.UnSpawnDelegate.html": {
    "href": "api/Mirage.UnSpawnDelegate.html",
    "title": "Delegate UnSpawnDelegate",
    "keywords": "Delegate UnSpawnDelegate Namespace : Mirage Assembly : doc.dll Syntax public delegate void UnSpawnDelegate(NetworkIdentity spawned); Parameters Type Name Description NetworkIdentity spawned"
  },
  "api/Mirage.UpdateVarsMessage.html": {
    "href": "api/Mirage.UpdateVarsMessage.html",
    "title": "Struct UpdateVarsMessage",
    "keywords": "Struct UpdateVarsMessage Namespace : Mirage Assembly : doc.dll Syntax public struct UpdateVarsMessage Fields | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < Byte >"
  },
  "api/Mirage.Version.html": {
    "href": "api/Mirage.Version.html",
    "title": "Enum Version",
    "keywords": "Enum Version Namespace : Mirage Assembly : doc.dll Syntax public enum Version : int Fields Name Description Current"
  },
  "api/Mirage.Writer-1.html": {
    "href": "api/Mirage.Writer-1.html",
    "title": "Class Writer<T>",
    "keywords": "Class Writer<T> a class that holds writers for the different types Note that c# creates a different static variable for each type This will be populated by the weaver Inheritance Object Writer<T> Namespace : Mirage Assembly : doc.dll Syntax public static class Writer<T> : object Type Parameters Name Description T Properties | Improve this Doc View Source Write Declaration public static Action<NetworkWriter, T> Write { set; } Property Value Type Description Action < NetworkWriter , T>"
  },
  "Articles/Components/Authenticators/Basic.html": {
    "href": "Articles/Components/Authenticators/Basic.html",
    "title": "Basic Authenticator",
    "keywords": "Basic Authenticator Mirage includes a Basic Authenticator in the Mirage / Authenticators folder which just uses a simple username and password. Drag the Basic Authenticator script to the inspector of the object in your scene that has Network Manager The Basic Authenticator component will automatically be assigned to the Authenticator field in Network Manager When you're done, it should look like this: Note: You don't need to assign anything to the event lists unless you want to subscribe to the events in your own code for your own purposes. Mirage has internal listeners for both events."
  },
  "Articles/Components/Authenticators/index.html": {
    "href": "Articles/Components/Authenticators/index.html",
    "title": "Authentication",
    "keywords": "Authentication When you have a multiplayer game, often you need to store information about your player for later games, keep game stats or communicate with your friends. For all these use cases, you often need a way to uniquely identify a user. Being able to tell users apart is called authentication. There are several methods available, some examples include: Ask the user for username and password Use a third party OAuth2 or OpenID identity provider, such as Facebook, Twitter, Google Use a third party service such as PlayFab, GameLift or Steam Use the device id, very popular method in mobile Use Google Play in Android Use Game Center in IOS Use a web service in your website Encryption Notice By default Mirage uses Kcp, which is not encrypted, so if you want to do authentication through Mirage, we highly recommend you use a transport that supports encryption. Basic Authenticator Basic Authenticator Mirage includes a Basic Authenticator in the Mirage / Authenticators folder which just uses a simple username and password. Custom Authenticators Authenticators are derived from an Authenticator abstract class that allows you to implement any authentication scheme you need. From the Assets menu, click Create > Mirage > Network Authenticator to make your own custom Authenticator from our Script Templates , and just fill in the messages and validation code to suit your needs. When a client is successfully authenticated, call base.OnServerAuthenticated.Invoke(conn) on the server and base.OnClientAuthenticated.Invoke(conn) on the client. Mirage is listening for these events to proceed with the connection sequence. Subscribe to OnServerAuthenticated and OnClientAuthenticated events if you wish to perform additional steps after authentication. Message Registration By default all messages registered to NetworkServer and NetworkClient require authentication unless explicitly indicated otherwise. To register messages to bypass authentication, you need to specify false for a bool parameter to the RegisterMessage method: NetworkServer.RegisterHandler<AuthenticationRequest>(OnAuthRequestMessage, false); Certain internal messages already have been set to bypass authentication: Server ConnectMessage DisconnectMessage ErrorMessage NetworkPingMessage Client ConnectMessage DisconnectMessage ErrorMessage SceneMessage NetworkPongMessage Tips Register handlers for messages in OnStartServer and OnStartClient . They're called from StartServer/StartHost, and StartClient, respectively. Send a message to the client if authentication fails, especially if there's some issue they can resolve. Call the Disconnect() method of the NetworkConnection on the server and client when authentication fails. If you want to give the user a few tries to get their credentials right, you certainly can, but Mirage will not do the disconnect for you. Remember to put a small delay on the Disconnect call on the server if you send a failure message so that it has a chance to be delivered before the connection is dropped. NetworkConnection has an authenticationData object where you can drop any data you need to persist on the server related to the authentication, such as account id's, tokens, character selection, etc. Now that you have the foundation of a custom Authenticator component, the rest is up to you. You can exchange any number of custom messages between the server and client as necessary to complete your authentication process before approving the client. Authentication can also be extended to character selection and customization, just by crafting additional messages and exchanging them with the client before completing the authentication process. This means this process takes place before the client player actually enters the game or changes to the Online scene. If you write a good authenticator, consider sharing it with other users or donating it to the Mirage project."
  },
  "Articles/Components/index.html": {
    "href": "Articles/Components/index.html",
    "title": "Components Overview",
    "keywords": "Components Overview These core components are included in Mirage: Network Animator The Network Animator component allows you to synchronize animation states for networked objects. It synchronizes state and parameters from an Animator Controller. Network Authenticator Network Authenticators facilitate integration of user accounts and credentials into your application. Network Discovery Network Discovery uses a UDP broadcast on the LAN enabling clients to find the running server and connect to it. Network Identity The Network Identity component is at the heart of the Mirage networking high-level API. It controls a game objects unique identity on the network, and it uses that identity to make the networking system aware of the game object. It offers two different options for configuration and they are mutually exclusive, which means either one of the options or none can be checked. Network LogSettings Adds logging levels per class for Mirror components Network Manager The Network Manager is a component for managing the networking aspects of a multiplayer game. Network Manager HUD The Network Manager HUD is a quick-start tool to help you start building your multiplayer game straight away, without first having to build a user interface for game creation/connection/joining. It allows you to jump straight into your gameplay programming, and means you can build your own version of these controls later in your development schedule. Network Match Checker The Network Match Checker component controls visibility of networked objects based on match id. Network Ping Display Network Ping Display shows the Ping time for clients using OnGUI Network Proximity Checker The Network Proximity Checker component controls the visibility of game objects for network clients, based on proximity to players. Network Rigidbody The Network Rigidbody synchronizes velocity and other properties of a rigidbody across the network. Network Room Manager The Network Room Manager is an extension component of Network Manager that provides a basic functional room. Network Room Player The Network Room Player is a component that's required on Player prefabs used in the Room Scene with the Network Room Manager above. Network Scene Checker The Network Scene Checker component controls visibility of networked objects between scenes. Network Start Position Network Start Position is used by the Network Manager when creating player objects. The position and rotation of the Network Start Position are used to place the newly created player object. Network Transform The Network Transform component synchronizes the movement and rotation of game objects across the network. Note that the network Transform component only synchronizes spawned networked game objects. Network Transform Child The Network Transform Child component synchronizes the position and rotation of the child game object of a game object with a Network Transform component."
  },
  "Articles/Components/NetworkAnimator.html": {
    "href": "Articles/Components/NetworkAnimator.html",
    "title": "Network Animator",
    "keywords": "Network Animator The Network Animator component allows you to synchronize animation states for networked objects. It synchronizes state and parameters from an Animator Controller. Note that if you create a Network Animator component on an empty game object, Mirage also creates a Network Identity component and an Animator component on that game object. Client Authority Enable this to have changes to animation parameters sent from client to server. Animator Use this field to define the Animator component you want the Network Animator to synchronize with. Normally, changes are sent to all observers of the object this component is on. Setting Sync Mode to Owner Only makes the changes private between the server and the client owner of the object. You can use the Sync Interval to specify how often it syncs (in seconds). Details The Network Animator ensures the synchronization of game object animation across the network, meaning that all players see the animation happen at the same. There are two kinds of authority for networked animation (see documentation on network authority ): NOTE: Animator Triggers are not synced directly. Call NetworkAnimator.SetTrigger instead. A game object with authority can use the SetTrigger function to fire an animation trigger on other clients. If the game object has authority on the client, you should animate it locally on the client that owns the game object. That client sends the animation state information to the server, which broadcasts it to all the other clients. For example, this may be suitable for player characters with client authority. If the game object has authority on the server, then you should animate it on the server. The server then sends state information to all clients. This is common for animated game objects that are not related to a specific client, such as scene objects and non-player characters, or server-authoritative clients."
  },
  "Articles/Components/NetworkDiscovery.html": {
    "href": "Articles/Components/NetworkDiscovery.html",
    "title": "Network Discovery",
    "keywords": "Network Discovery Suppose your are next to a friend. He starts a game in host mode and you want to join him. How will your phone locate his? Finding out his IP address is not exactly intuitive or something kids can do. To solve this problem you can use Network Discovery. When your game starts, it sends a message in your current network asking \"Is there any server available?\". Any server within the same network will reply and provide information about how to connect to it. Mirage comes with a simple implementation of Network Discovery you can simply use in your game. It also provides a way for you to extend it so that you can pass additional data during the discovery phase. NetworkDiscovery and NetworkDiscoveryHUD components are included, or you can make your own from a ScriptTemplate . Network Discovery uses a UDP broadcast on the LAN enabling clients to find the running server and connect to it. When a server is started, it listens on the UDP Broadcast Listen Port for requests from clients and returns a connection URI that clients apply to their transport. You can adjust how often the clients send their requests out to find a server in seconds with the Active Discovery Interval. The Server Found event must be assigned to a handler method, e.g. the OnDiscoveredServer method of NetworkDiscoveryHUD. In the NetworkDiscoveryHUD, the NetworkDiscovery component should be assigned automatically. Quick Start To use Network Discovery follow these steps: Create a gameobject with a NetworkManager if you have not done so already Do not add a NetworkManagerHUD. Discovery has a different UI component. Add a NetworkDiscoveryHUD component to the NetworkManager gameobject. A NetworkDiscovery component will be automatically added and wired up to your HUD. Add a player to the NetworkManager if you have not done so. Build and run a standalone version Click on Start Host Start play mode in the editor and click on Find Servers The editor should find the standalone version and display a button Click on the button to connect to it. The NetworkDiscoveryHUD is provided as a simple and quick way to get started, but you will probably want to replace it with your own user interface. Custom Network Discovery You can completely replace the user interface by adding your own interface (typically Unity UI based) instead of the default NetworkDiscoveryHUD. You do still need the NetworkDiscovery component to do the heavy lifting. Sometimes you want to provide more information in the discovery messages. Some use cases could include: The client can show if the server is in PvP or PvE mode The client can show how full the servers are. The client can show the ping to each server so the player can chose the fastest server The client can show the language The client can show if the server is password protected To do this, we've provided a Template , so from the Assets menu, click Create > Mirage > Network Discovery. This will create a script in your project with 2 empty message classes and a custom NetworkDiscovery class that inherits from NetworkDiscoveryBase and has all the override methods included and documented for you. The message classes define what is sent between the client and server. As long as you keep your messages simple using the data types that Mirage can serialize, you won't need to write custom serializers for them. public class DiscoveryRequest { public string language=\"en\"; // Add properties for whatever information you want sent by clients // in their broadcast messages that servers will consume. } public class DiscoveryResponse { enum GameMode {PvP, PvE}; // you probably want uri so clients know how to connect to the server public Uri uri; public GameMode GameMode; public int TotalPlayers; public int HostPlayerName; // Add properties for whatever information you want the server to return to // clients for them to display or consume for establishing a connection. } The custom NetworkDiscovery class contains the overrides for handling the messages above. You may want to refer to the NetworkDiscovery.cs script in the Components/Discovery folder to see how these should be implemented. public class NewNetworkDiscovery: NetworkDiscoveryBase<DiscoveryRequest, DiscoveryResponse> { #region Server protected override void ProcessClientRequest(DiscoveryRequest request, IPEndPoint endpoint) { base.ProcessClientRequest(request, endpoint); } protected override DiscoveryResponse ProcessRequest(DiscoveryRequest request, IPEndPoint endpoint) { // TODO: Create your response and return it return new DiscoveryResponse(); } #endregion #region Client protected override DiscoveryRequest GetRequest() { return new DiscoveryRequest(); } protected override void ProcessResponse(DiscoveryResponse response, IPEndPoint endpoint) { // TODO: a server replied, do something with the response such as invoking a unityevent } #endregion }"
  },
  "Articles/Components/NetworkIdentity.html": {
    "href": "Articles/Components/NetworkIdentity.html",
    "title": "Network Identity",
    "keywords": "Network Identity See also NetworkIdentity in the API Reference. The Network Identity component is at the heart of the Unity networking high-level API. It controls a game objects unique identity on the network, and it uses that identity to make the networking system aware of the game object. It offers two different options for configuration and they are mutually exclusive, which means either one of the options or none can be checked. Server Only Tick this checkbox to ensure that Unity only spawns the game object on the server, and not on clients. Instantiated Network Game Objects With the Mirages server-authoritative networking system, the server must spawn networked game objects with network identities, using NetworkServer.Spawn . This automatically creates them on clients that are connected to the server, and assigns them a netId . You must put a Network Identity component on any Prefabs that spawn at runtime for the network system to use them. See Object Spawning for more information. Scene-based Network Game Objects You can also network game objects that are saved as part of your Scene (for example, environmental props). Networking game objects makes them behave slightly differently, because you need to have them spawn across the network. When building your game, Unity disables all Scene-based game objects with Network Identity components. When a client connects to the server, the server sends spawn messages to tell the client which Scene game objects to enable and what their most up-to-date state information is. This ensures the clients game does not contain game objects at incorrect locations when they start playing, or that Unity does not spawn and immediately destroy game objects on connection (for example, if an event removed the game object before that client connected). See Networked Scene Game Objects for more information. Preview Pane Information This component contains network tracking information, and displays that information in the preview pane. For example, the scene ID, network ID and asset ID the object has been assigned. This allows you to inspect the information which can be useful for investigation and debugging. At runtime there is more information to display here (a disabled NetworkBehaviour is displayed non-bold):"
  },
  "Articles/Components/NetworkLerpRigidbody.html": {
    "href": "Articles/Components/NetworkLerpRigidbody.html",
    "title": "Network Lerp Rigidbody",
    "keywords": "Network Lerp Rigidbody The Network Lerp Rigidbody classed as \"Experimental\" for now so please share any problems or bugs you find with it and use at your own risk if production builds. The Network Lerp Rigidbody component synchronizes position and velocity of a rigidbody across the network. This component is useful when you have a non-kinematic rigidbody that have constant forces applied to them, like gravity, but also want to apply forces or change velocity to that rigidbody or server or client with authority. For example, objects that move and jump using rigidbody using gravity. A game object with a Network Rigidbody component must also have a Network Identity component. When you add a Network Rigidbody component to a game object, Mirage also adds a Network Identity component on that game object if it does not already have one. When using the Network Lerp Rigidbody you should have NetworkTransform on the same object as the Network Lerp Rigidbody will handle syncing the position By default, Network Lerp Rigidbody is server-authoritative unless you check the box for Client Authority . Client Authority applies to player objects as well as non-player objects that have been specifically assigned to a client, but only for this component. With this enabled, value changes are send from the client to the server. Normally, changes are sent to all observers of the object this component is on. Setting Sync Mode to Owner Only makes the changes private between the server and the client owner of the object. You can use the Sync Interval to specify how often it syncs (in seconds). This applies both to Client Authority and Server Authority."
  },
  "Articles/Components/NetworkLogSettings.html": {
    "href": "Articles/Components/NetworkLogSettings.html",
    "title": "Network Log Settings",
    "keywords": "Network Log Settings See also LogFactory in the API Reference. Network Log Settings component The Network Log Settings component allows you to configure logging levels and load the settings in a build. When you first add NetworkLogSettings you will have to Create a new LogSettings asset that will store the settings. Note: If a LogSettings asset already exists the NetworkLogSettings component will set the Settings field when it is added to a game object. Log Settings When you first set up LogSettings the list of components may be empty or incomplete. Running the game will cause Mirage scripts to add their respective loggers to the list so their logging levels can be changed. Log settings can also be changed using the \"Mirage Log Level\" window, which can be opened from the editor menu: Window > Analysis > Mirage Log Levels. To change settings at runtime please see LogFactory . Issues Mirrors Logging api is currently work in progress. If there is a bug or a feature you want added please make an issue here ."
  },
  "Articles/Components/NetworkManager.html": {
    "href": "Articles/Components/NetworkManager.html",
    "title": "Network Manager",
    "keywords": "Network Manager NetworkManager is a helper class with instance references to the other major parts of the Mirage network. It provides quick access to: NetworkServer NetworkClient NetworkSceneManager ServerObjectManager ClientObjectManager"
  },
  "Articles/Components/NetworkManagerHUD.html": {
    "href": "Articles/Components/NetworkManagerHUD.html",
    "title": "Network Manager HUD",
    "keywords": "Network Manager HUD The Network Manager HUD (heads-up display) is a quick-start tool to help you start building your multiplayer game straight away, without first having to build a user interface for game creation/connection/joining. It allows you to jump straight into your game play programming, and means you can build your own version of these controls later in your development schedule. It is not, however, intended to be included in finished games. The idea is that these controls are useful to get you started, but you should create your own UI later on, to allow your players to find and join games in a way that suits your game. For example, you might want to stylize the design of the screens, buttons and list of available games to match the overall style of your game. To start using the Network Manager HUD, TODO: This is now a canvas based prefab but currently only in the examples. The Network Manager HUD provides the basic functions so that people playing your game can start hosting a networked game, or find and join an existing networked game. Unity displays the Network Manager HUD as a collection of simple UI buttons in the Game view. Using the HUD The Network Manager HUD allows you to start in Host, Server or Client only modes and input of a network address. Host (Server + Client) Click the Host (Server + Client) button to start a game as a host on the local network. This client is both the host and one of the players in the game. It uses the information from the Network Info section in the inspector to host the game. When you have started a game as a host, other players of the game can then connect to the host to join the game. Click the Stop button to disconnect from the host. Clicking Stop also returns to the main HUD menu. Client To connect to a host or standalone server on the internet use the text field to specify the address of the host. The default host address is localhost, which means the client looks on its own computer for the game host. In addition to localhost , you can specify an IPv4 address, and IPv6 address, or a fully-qualified domain name (FQDN), e.g. game.example.com , and the transport with resolve the name using DNS. Click Client to attempt to connect to the host address you have specified. Use the default localhost in this field if you are running multiple instances of your game on one computer, to test multiplayer interactivity. To do this, you can create a standalone build of your game, and then launch it multiple times on your computer. This is a common way to quickly test that your networked game interactions are functioning as you expect, without you needing to deploy your game to multiple computers or devices. When you want to test your game on multiple machines you need to put the address of the computer acting as host into the address text field. The computer acting as the host needs to tell their IP address to everyone running clients, so that you can type this into the box. For local clients on a LAN, that's the local IP address. For remote clients, that's the WAN IP address of the router of the host. Firewall rules and port-forwarding are generally required for a computer to act as host and accept connections from other computers, whether they're on the LAN or the internet. Enter the IP address (or leave it as localhost if you are testing it on your own machine), then click Client to attempt to connect to the host. When the client is attempting to connect, the HUD displays a Cancel Connection Attempt button. Click this if you want to stop trying to connect to the host. If the connection is successful, the HUD displays the Stop button. Click this if you want to stop the game on the client and disconnect from the host: Server Only Click Server Only to start a game which acts as a server that other clients can connect to, but which does not act as a client to the game itself. This type of game is often called a dedicated server. A user cannot play the game on this particular instance of your game. All players must connect as clients, and nobody plays on the instance that is running as the server. A dedicated server results in better performance for all connected players, because the server doesnt need to process a local players game play in addition to acting as server. You might also choose this option if you want to host a game that can be played over the internet (rather than just within a local network), but want to maintain control of the server yourself - for example, to prevent cheating by one of the clients, because only the server has authority over the game. To do this, you would need to run the game in Server Only mode on a computer with a public IP address."
  },
  "Articles/Components/NetworkMatchChecker.html": {
    "href": "Articles/Components/NetworkMatchChecker.html",
    "title": "Network Match Checker",
    "keywords": "Network Match Checker The Network Match Checker component controls visibility of networked objects based on match id. Any object with this component on it will only be visible to other objects in the same match. This would be used to isolate players to their respective matches within a single game server instance. When you create a match, generate and store, in a List for example, a new match id with System.Guid.NewGuid(); and assign the same match id to the Network Match Checker via GetComponent<NetworkMatchChecker>().matchId . Mirage's built-in Observers system will isolate SyncVar's and ClientRpc's on networked objects to only send updates to clients with the same match id."
  },
  "Articles/Components/NetworkPingDisplay.html": {
    "href": "Articles/Components/NetworkPingDisplay.html",
    "title": "Network Ping Display",
    "keywords": "Network Ping Display Network Ping Display shows the Ping time for clients using OnGUI. The Ping time is the moving average of the (RTT) Round-trip delay time. RTT is calculated by the PingMessage/PongMessage between the client and server. See Clock Synchronization for more info."
  },
  "Articles/Components/NetworkProximityChecker.html": {
    "href": "Articles/Components/NetworkProximityChecker.html",
    "title": "Network Proximity Checker",
    "keywords": "Network Proximity Checker The Network Proximity Checker component controls the visibility of game objects for network clients, based on proximity to players. Vis Range Define the range that the game object should be visible to observers. Vis Update Interval Define how often (in seconds) the game object should check for observers entering its visible range. Check Method Define which type of physics (2D or 3D) to use for proximity checking. Force Hidden Tick this checkbox to hide this object from all players. With the Network Proximity Checker, a game running on a client doesnt have information about game objects that are not visible. This has two main benefits: it reduces the amount of data sent across the network, and it makes your game more secure against hacking. This component relies on physics to calculate visibility, so observer game objects must also have a collider component on it. A game object with a Network Proximity Checker component must also have a Network Identity component. When you create a Network Proximity Checker component on a game object, Mirage also creates a Network Identity component on that game object if it does not already have one. Scene objects with a Network Proximity Checker component are disabled when they're out of range, and spawned objects are destroyed when they're out of range."
  },
  "Articles/Components/NetworkRigidbody.html": {
    "href": "Articles/Components/NetworkRigidbody.html",
    "title": "Network Rigidbody",
    "keywords": "Network Rigidbody The Network Rigidbody classed as \"Experimental\" for now so please share any problems or bugs you find with it and use at your own risk if production builds. The Network Rigidbody component synchronizes velocity and other properties of a rigidbody across the network. This component is useful when you have a non-kinematic rigidbody that have constant forces applied to them, like gravity, but also want to apply forces or change velocity to that rigidbody or server or client with authority. For example, objects that move and jump using rigidbody using gravity. A game object with a Network Rigidbody component must also have a Network Identity component. When you add a Network Rigidbody component to a game object, Mirage also adds a Network Identity component on that game object if it does not already have one. Network Rigidbody works best when there is also a NetworkTransform for the object to keep position as well as velocity in sync. By default, Network Rigidbody is server-authoritative unless you check the box for Client Authority . Client Authority applies to player objects as well as non-player objects that have been specifically assigned to a client, but only for this component. With this enabled, value changes are send from the client to the server. The Sensitivity options allow you to set a minimum thresholds before values are send over network. This helps minimize network traffic for very small changes. For some object you may not want them to rotate but don't need to sync the Angular Velocity. The Clear Angular Velocity will set the Angular Velocity to zero each frame causing the minimizing when objects rotation. If Sync Angular Velocity is enabled then clear is ignored. The same can apply to Clear Velocity . Normally, changes are sent to all observers of the object this component is on. Setting Sync Mode to Owner Only makes the changes private between the server and the client owner of the object. You can use the Sync Interval to specify how often it syncs (in seconds). This applies both to Client Authority and Server Authority."
  },
  "Articles/Components/NetworkRoomManager.html": {
    "href": "Articles/Components/NetworkRoomManager.html",
    "title": "Network Room Manager",
    "keywords": "Network Room Manager **Please see the Room example in the Examples folder in your Mirage folder The Network Room Manager is a specialized type of Network Manager that provides a multiplayer room before entering the main play scene of the game. It allows you to set up a network with: A maximum player limit Automatic start when all players are ready Option to prevent players from joining a game in progress Customizable ways for players to choose options while in room There are two types of player objects with the Network Room Manager: Room Player Prefab One for each player Created when client connects, or player is added Persists until client disconnects Holds ready flag and configuration data Handles commands in the room Must use the Network Room Player component Player Prefab One for each player Created when game scene is started Destroyed when leaving game scene Handles commands in the game Properties Show Room GUI Show the default OnGUI controls for the room. Min Players Minimum number of players needed to start a game. Room Player Prefab The prefab to create for players when they enter the room (requires Network Room Player component). Room Scene The scene to use for the room. Gameplay Scene The scene to use for main game play. pendingPlayers List<PendingPlayer> that holds players that are ready to start playing. roomSlots List<NetworkRoomPlayer> that manages the slots for connected clients in the room. allPlayersReady Bool indicating if all players are ready to start playing. This value changes as players invoke CmdChangeReadyState indicating true or false, and will be set false when a new client connects. Methods Server Virtual Methods public virtual void OnRoomStartHost() {} public virtual void OnRoomStopHost() {} public virtual void OnRoomStartServer() {} public virtual void OnRoomServerConnect(NetworkConnection conn) {} public virtual void OnRoomServerDisconnect(NetworkConnection conn) {} public virtual void OnRoomServerSceneChanged(string sceneName) {} public virtual GameObject OnRoomServerCreateRoomPlayer(NetworkConnection conn) { return null; } public virtual GameObject OnRoomServerCreateGamePlayer(NetworkConnection conn) { return null; } public virtual bool OnRoomServerSceneLoadedForPlayer(GameObject roomPlayer, GameObject gamePlayer) { return true; } public virtual void OnRoomServerPlayersReady() { ServerChangeScene(GameplayScene); } Client Virtual Methods public virtual void OnRoomClientEnter() {} public virtual void OnRoomClientExit() {} public virtual void OnRoomClientConnect(NetworkConnection conn) {} public virtual void OnRoomClientDisconnect(NetworkConnection conn) {} public virtual void OnRoomStartClient() {} public virtual void OnRoomStopClient() {} public virtual void OnRoomClientSceneChanged(NetworkConnection conn) {} public virtual void OnRoomClientAddPlayerFailed() {}"
  },
  "Articles/Components/NetworkRoomPlayer.html": {
    "href": "Articles/Components/NetworkRoomPlayer.html",
    "title": "Network Room Player",
    "keywords": "Network Room Player The Network Room Player stores per-player state for the Network Room Manager while in the room. When using this component, you need to write a script which allows players to indicate they are ready to begin playing, which sets the ReadyToBegin property. A game object with a Network Room Player component must also have a Network Identity component. When you create a Network Room Player component on a game object, Unity also creates a Network Identity component on that game object if it does not already have one. Show Room GUI Enable this to show the developer GUI for players in the room. This UI is only intended to be used for ease of development. This is enabled by default. Ready To Begin Diagnostic indicator that a player is Ready. Index Diagnostic index of the player, e.g. Player 1, Player 2, etc. Network Sync Interval The rate at which information is sent from the Network Room Player to the server. Methods Client Virtual Methods public virtual void OnClientEnterRoom() {} public virtual void OnClientExitRoom() {} public virtual void OnClientReady(bool readyState) {}"
  },
  "Articles/Components/NetworkSceneChecker.html": {
    "href": "Articles/Components/NetworkSceneChecker.html",
    "title": "Network Scene Checker",
    "keywords": "Network Scene Checker The Network Scene Checker component controls the visibility of game objects for network clients, based on which scene they're in. Force Hidden Tick this checkbox to hide this object from all players. With the Network Scene Checker, a game running on a client doesnt have information about game objects that are not visible. This has two main benefits: it reduces the amount of data sent across the network, and it makes your game more secure against hacking. This component would typically be used when the server has several subscenes loaded and needs to isolate networked objects to the subscene they're in. A game object with a Network Scene Checker component must also have a Network Identity component. When you create a Network Scene Checker component on a game object, Mirage also creates a Network Identity component on that game object if it does not already have one. Scene objects with a Network Scene Checker component are disabled when they're not in the same scene, and spawned objects are destroyed when they're not in the same scene. Use with Additive Scenes In Mirage, the Server and connected Clients are always on the same main scene, however the server and clients can have various combinations of smaller subscenes loaded additively. The server may load all subscenes at start, or it may dynamically load and unload subscenes where players or other activity is going on as needed. All player objects are always first spawned in the main scene, which may or may not have visual content, networked objects, etc. With this component attached to all networked objects, whenever the player object is moved to a subscene (from the main or from another subscene), the observers lists for objects in both the new scene and the prior scene are updated accordingly. Loading the subscene(s) on the server is through the normal process with SceneManager : SceneManager.LoadSceneAsync(subScene, LoadSceneMode.Additive); Next, you will send a SceneMessage to the client telling it to load a subscene additively: SceneMessage msg = new SceneMessage { sceneName = subScene, sceneOperation = SceneOperation.LoadAdditive }; connectionToClient.Send(msg); Then, on the server only, you just move the player object to the subscene: // Position the player object in world space first // This assumes it has a NetworkTransform component that will update clients player.transform.position = new Vector3(100, 1, 100); // Then move the player object to the subscene SceneManager.MoveGameObjectToScene(player, subScene); Optionally you can send another SceneMessage to the client with SceneOperation.UnloadAdditive to remove any previous additive scene the client no longer needs. This would apply to a game that has levels after a level change. A short delay may be necessary before removal to allow the client to get fully synced. Depending on the complexity of your game, you may find it helpful when switching a player between subscenes to move the player object to the main scene first, yield 100 ms, re-position it, and finally move it to the new subscene."
  },
  "Articles/Components/NetworkSceneManager.html": {
    "href": "Articles/Components/NetworkSceneManager.html",
    "title": "Network Scene Manager",
    "keywords": "Network Scene Manager The Network Scene Manager component controls the Unity Scenes running over the network. Client Change Scene Event that fires before the client changes scenes. Client Changed Scene Event that fires after the client changes scenes. Server Change Scene Event that fires before the server changes scenes. Server Changed Scene Event that fires after the server changes scenes. The Network Scene Maanger allows the user to change network scenes during runtime. There are three types of scene changes broadly supported by Mirage: Normal, Additive Load, and Additive Unload. Normal: In a Normal scene change all currently loaded assets are unspawned and unloaded. The new scene is loaded and set active. Then all of the scene or instance netwrok objects can be spawned. Under this operation the client waits for the server to finish before spawning starts to prevent any race conditions. Additive Load: The specified scene will be loaded on the Server and Client in addition to the currently active network scene. Additive Unload: Unload a previously loaded additive scene from the Server and Client. How does it work When the NetworkServer starts it assumes the initial scene is the one you plan on running the network on. If this is not correct you can either change scenes before starting the network or after. The order on the server will likely only matter to you if you are running in Host mode. Once a NetworkClient connects and passes authentication the NetworkServer will send a message notifying them of the current active scene and any additive scenes they should load. Once that task is complete then the server will start spawning network objects on the NetworkClient. How do I change scenes If the scene change involves network objects then it is strongly reccomended to make any scene changes via the NetworkSceneManager. Doing so via Unity's SceneManager directly may function but give undesired results with network objects. To do a network scene change you initiate the process via the server NetworkSceneManager via: sceneManager.ChangeServerScene(\"Assets/Mirror/Tests/Runtime/testScene.unity\"); Note: You dont have to provide the full scene path when initiating a scene change. But the 'NetworkSceneName' will be saved as the full path."
  },
  "Articles/Components/NetworkStartPosition.html": {
    "href": "Articles/Components/NetworkStartPosition.html",
    "title": "Network Start Position",
    "keywords": "Network Start Position To control where players are spawned, you can use the Network Start Position component. To use these, attach a Network Start Position component to a game object in the scene, and position the game object where you would like one of the players to start. You can add as many start positions to your Scene as you like. The Network Manager detects all start positions in your Scene, and when it spawns each player instance, it uses the position and orientation of one of them. The Network Manager will spawn players at (0, 0, 0) by default. Adding this component to a game object will automatically register/unregister its game object's transform to the Network Manager as an available spawning position. Depending on the Network Manager Player Spawn Method setting the spawning is either Random (possible that the same spawn position will be used by two or more players) or Round Robin (use every available position, until there are more clients than spawn points)."
  },
  "Articles/Components/NetworkTransform.html": {
    "href": "Articles/Components/NetworkTransform.html",
    "title": "Network Transform",
    "keywords": "Network Transform The Network Transform component synchronizes the position, rotation, and scale of networked game objects across the network. A game object with a Network Transform component must also have a Network Identity component. When you add a Network Transform component to a game object, Mirage also adds a Network Identity component on that game object if it does not already have one. By default, Network Transform is server-authoritative unless you check the box for Client Authority . Client Authority applies to player objects as well as non-player objects that have been specifically assigned to a client, but only for this component. With this enabled, position changes are send from the client to the server. Under Sensitivity , you can set the minimum thresholds of change to the transform values in order for network messages to be generated. This helps minimize network \"noise\" for minor twitch and jitter. Normally, changes are sent to all observers of the object this component is on. Setting Sync Mode to Owner Only makes the changes private between the server and the client owner of the object. You can use the Sync Interval to specify how often it syncs (in seconds)."
  },
  "Articles/Components/NetworkTransformChild.html": {
    "href": "Articles/Components/NetworkTransformChild.html",
    "title": "Network Transform Child",
    "keywords": "Network Transform Child The Network Transform Child component synchronizes the position and rotation of the child game object of a game object with a Network Transform component. You should use this component in situations where you need to synchronize an independently-moving child object of a Networked game object. To use the Network Transform Child component, attach it to the same parent game object as the Network Transform, and use the Target field to define which child game object to apply the component settings to. You can have multiple Network Transform Child components on one parent game object . You can modify Compress Rotation to save some bandwidth when synchronizing the rotation. You can use the Network Sync Interval to specify how often it syncs (in seconds). This component takes authority into account, so local player game objects (which have local authority) synchronize their position from the client to server, then out to other clients. Other game objects (with server authority) synchronize their position from the server to clients."
  },
  "Articles/Examples/AdditiveScenes/index.html": {
    "href": "Articles/Examples/AdditiveScenes/index.html",
    "title": "Additive Scenes Example",
    "keywords": "Additive Scenes Example IMPORTANT: Make sure you have a layer in project settings called Player for this example to work well. In Build Settings, remove all scenes and add all of the scenes from the Scenes folder in the following order: MainScene SubScene Open the MainScene in the Editor and make sure the Sub Scenes list in the Network Manager component on the Network scene object contains the SubScene scene. This is already setup by default, but if the MainScene was opened and saved before putting the scenes in the Build Settings list, the Sub Scenes list may be cleared accidentally. File -> Build and Run Start up to 3 built instances: These will all be client players. Press Play in the Editor and click Host (Server + Client) in the HUD This will be the host and the 1st player of up to 4. You can also use Server Only if you prefer. Click Client in the built instances. WASDQE keys to move & turn your player capsule. There are objects in the corners of the scene hidden by Proximity Checkers. The big area in the middle is where the subscene will be loaded when you get near the shelter. There are also networked objects inside the subscene, also with Proximity Checkers. Since subscenes are only loaded for individual clients, other clients that are outside the middle Zone won't see what those in the subscene can see. If you play a built instance as Host or Server and play as client in the editor, you'll see the subscene content load and unload in the hierarchy as you move in and out of the middle Zone."
  },
  "Articles/Examples/Basic/index.html": {
    "href": "Articles/Examples/Basic/index.html",
    "title": "Basic",
    "keywords": "Basic General description of Basic example."
  },
  "Articles/Examples/ChangeScene/index.html": {
    "href": "Articles/Examples/ChangeScene/index.html",
    "title": "ChangeScene",
    "keywords": "ChangeScene"
  },
  "Articles/Examples/Chat/index.html": {
    "href": "Articles/Examples/Chat/index.html",
    "title": "Chat",
    "keywords": "Chat"
  },
  "Articles/Examples/index.html": {
    "href": "Articles/Examples/index.html",
    "title": "Samples Overview",
    "keywords": "Samples Overview Mirage includes several small examples to help you learn how to use various features and how to set things up so they work together. Additive Scenes The Additive Scenes example demonstrates a server additively loading a sub-scene into a main scene at startup, and having a server-only trigger that generates a message to any client whose player enters the trigger zone to also load the sub-scene, and subsequently unload it when they leave the trigger zone. Only players inside the trigger zone can see the objects in the sub-scene. Network Proximity Checker components are key to making this scenario work. Basic Basic is what it sounds like...the most rudimentary baseline of a networked game. Features SyncVars updating random UI data for each player. Chat A simple text chat for multiple networked clients. ChangeScene Provides examples for Normal and Additive network scene changing. Pong A simple example for \"How to build a multiplayer game with Mirage\" is Pong. It illustrates the usage of NetworkManager , NetworkManagerHUD , NetworkBehaviour, NetworkIdentity, NetworkTransform , NetworkStartPosition and various Attributes. Tanks This is a simple scene with animated tanks, networked rigidbody projectiles, and NavMesh movement"
  },
  "Articles/Examples/MultipleAdditiveScenes/index.html": {
    "href": "Articles/Examples/MultipleAdditiveScenes/index.html",
    "title": "Multiple Additive Scenes Example",
    "keywords": "Multiple Additive Scenes Example In Build Settings, remove all scenes and add both of the scenes from the Scenes folder in the following order: Main Game Open the Main scene in the Editor and make sure the Game Scene field in the MultiScene Network Manager on the Network scene object contains the Game scene. This is already setup by default, but if the Main scene was opened and saved before putting the scenes in the Build Settings list, the Game Scene field may be cleared accidentally. MultiScene Network Manager The MultiScene Network Manager is derived from the base Network Manager and is responsible for additively loading the subscene instances and placing the players in their respective subscene instances and initializing player SyncVars. It has a Game Scene field where the Game subscene is assigned, and an Instances field to set how many instances are loaded on the server. In this example, the subscene instances are additively loaded on the server with localPhysicsMode = LocalPhysicsMode.Physics3D . Physics subscenes do not auto-simulate, so each scene has a game object with a generic PhysicsSimulator script on it. This script does nothing on the client, only on the server. Clients only ever have one instance of the subscene additively loaded (without localPhysicsMode ), while server has them all. All networked objects have a NetworkSceneChecker component which is what isolates them to their specific subscene. Playing in the Instances File -> Build and Run Start at least 3 built instances: These will all be client players. Press Play in the Editor and click Host (Server + Client) in the HUD - This will be the host and the 1st player. You can also use Server Only if you prefer. Click Client in the built instances. WASDQE keys to move & turn your player capsule, Space to jump. Colliding with the small colored spheres scores points base on their color. Colliding with the larger tumblers sends them rolling around...they're server-side non-kinematic rigidbodies. Only scores for the players in the same subscene are shown at the top of the game window."
  },
  "Articles/Examples/Pong/index.html": {
    "href": "Articles/Examples/Pong/index.html",
    "title": "Pong",
    "keywords": "Pong A simple example for \"How to built a multiplayer game with Mirage\" is Pong, which is included in the AssetStore package of Mirage. It illustrates the usage of NetworkManager, NetworkManagerHUD, NetworkBehaviour, NetworkIdentity, NetworkTransform, NetworkStartPosition and NetworkingAttributes. Setting the number of players First of all, let's have a look at the NetworkManager object in the main scene. When adding the NetworkManager component to a gameobject, a few default settings are already set ( Don't destroy on Load , Run in Background , ...) For playing Pong the maximum number of players is 2, so the setting Network Info/Max connections will also be 2. As there are no other scenes (room, online or offline scene) in this sample the properties for Offline Scene and Online Scene will stay empty. Creating the player Furthermore every player needs a racket to play with. Each player who joins the game will have his own controllable object, which represents him within the game. This gameobject is called PlayerObject . For spawning the PlayerObject a prefab has to be created, containing at least a NetworkIdentity component with Local Player Authority checked. The Local Player Authority allows the player to control and modify the gameobjects properties (e.g. for movement). The NetworkManager needs a reference to this prefab, which is located in Spawn Info/Player Prefab . To have the player movement synchronized over the network, the player prefab also contains a NetworkTransform. Player start position The main scene contains 2 gameobjects with only a NetworkStartPosition component (gameobjects RacketSpawnLeft, RacketSpawnRight in the scene). These transforms will be automatically registered by the NetworkManager as spawning positions. Setting up the network A very convenient component for establish/testing connections is the NetworkManagerHUD. It provides basic functionality for start a game as Client, Server, or Host (Client and Server at the same time). It requires the NetworkManager component. The ball of Pong The ball is the main focus of Pong, as this is the object needed to score points. Its NetworkIdentity component has neither Server Only nor Local Player Authority checked, as it's moved by the server physics engine and can be influenced by the players. As with the PlayerObject the position is synchronized via NetworkTransform. When having multiple scenes, the ball can be spawned by the NetworkManager, but to keep this sample simple, it's placed directly within the main scene."
  },
  "Articles/Examples/Room/index.html": {
    "href": "Articles/Examples/Room/index.html",
    "title": "Room",
    "keywords": "Room General description of Room example."
  },
  "Articles/Examples/Tanks/index.html": {
    "href": "Articles/Examples/Tanks/index.html",
    "title": "Tanks",
    "keywords": "Tanks General description of Tanks example."
  },
  "Articles/General/index.html": {
    "href": "Articles/General/index.html",
    "title": "General Overview",
    "keywords": "General Overview Mirages multiplayer High Level API (HLAPI) is a system for building multiplayer capabilities for Unity games. It is built on top of the lower level transport real-time communication layer, and handles many of the common tasks that are required for multiplayer games. While the transport layer supports any kind of network topology, the HLAPI is a server authoritative system; although it allows one of the participants to be a client and the server at the same time, so no dedicated server process is required. Working in conjunction with the internet services, this allows multiplayer games to be played over the internet with little work from developers. The HLAPI is focused on ease of use and iterative development and provides useful functionality for multiplayer games, such as: Message handlers General purpose high performance serialization Distributed object management State synchronization Network classes: Server, Client, Connection, etc The HLAPI is built from a series of layers that add functionality: Server and Host In Mirages High Level API (HLAPI) system, multiplayer games include: Server A server is an instance of the game which all other players connect to when they want to play together. A server often manages various aspects of the game, such as keeping score, and transmit that data back to the client. Clients Clients are instances of the game that usually connect from different computers to the server. Clients can connect over a local network, or online. A client is an instance of the game that connects to the server, so that the person playing it can play the game with other people, who connect on their own clients. The server might be either a dedicated server, or a host server. Dedicated server This is an instance of the game that only runs to act as a server. Host server When there is no dedicated server, one of the clients also plays the role of the server. This client is the host server. The host server creates a single instance of the game (called the host), which acts as both server and client. The diagram below represents three players in a multiplayer game. In this game, one client is also acting as host, which means the client itself is the local client. The local client connects to the host server, and both run on the same computer. The other two players are remote clients - that is, they are on different computers, connected to the host server. The host is a single instance of your game, acting as both server and client at the same time. The host uses a special kind of internal client for local client communication, while other clients are remote clients. The local client communicates with the server through direct function calls and message queues, because it is in the same process. It actually shares the Scene with the server. Remote clients communicate with the server over a regular network connection. When you use Mirages HLAPI, this is all handled automatically for you. One of the aims of the multiplayer system is for the code for local clients and remote clients to be the same, so that you only have to think about one type of client most of the time when developing your game. In most cases, Mirage handles this difference automatically, so you should rarely need to think about the difference between your code running on a local client or a remote client. Instantiate and Spawn When you make a single player game In Unity, you usually use the GameObject.Instantiate method to create new game objects at runtime. However, with a multiplayer system, the server itself must spawn game objects in order for them to be active within the networked game. When the server spawns game objects, it triggers the creation of game objects on connected clients. The spawning system manages the lifecycle of the game object, and synchronizes the state of the game object based on how you set the game object up. For more details about networked instantiating and spawning, see documentation on Spawning game objects . Players and Local Players Mirages multiplayer HLAPI system handles player game objects differently to non-player game objects. When a new player joins the game (when a new client connects to the server), that players game object becomes a local player game object on the client of that player, and Mirage associates the players connection with the players game object. Mirage associates one player game object for each person playing the game, and routes networking commands to that individual game object. A player cannot invoke a command on another players game object, only their own. For more details, see documentation on Player game objects . Authority Servers and clients can both manage a game objects behavior. The concept of authority refers to how and where a game object is managed. Mirages HLAPI is based around server authority as the default state, where the Server has authority over all game objects. Player game objects are a special case and treated as having local authority. You may want to build your game using a different system of authority - for more details, see Network Authority ."
  },
  "Articles/General/Integrations/index.html": {
    "href": "Articles/General/Integrations/index.html",
    "title": "Integrations",
    "keywords": "Integrations Here we will maintain a list of assets known to be compatible with Mirage. If you know of others, please have the publisher contact us directly in our Discord . SmoothSync Weather Maker Noble Connect Free Dissonance Voice Chat RTS Engine Rucksack Steamworks Networking Master Audio Multiplayer"
  },
  "Articles/General/PlayerControllerToIdentity.html": {
    "href": "Articles/General/PlayerControllerToIdentity.html",
    "title": "Changing playerController to identity",
    "keywords": "Changing playerController to identity If you need to fix up a project after NetworkConnection.playerController was changed to identity these instructions should be helpful. Open your Unity project and look for Assets/Mirage/Runtime/ NetworkConnection : Open this file in Visual Studio or Visual Code from Unity and look for these lines: The line numbers could be off a bit if minor file changes happen above them after this document was written. Comment the last line shown: // public NetworkIdentity identity { get; internal set; } Double-click and then right-click playerController and select Rename: Change playerController to identity and click Apply: Visual Studio will now have applied the change throughout your project, but you're not done yet! Without using the replace feature this time, simply retype the name back to playerController and un-comment the last line in the code image that you commented out in step 3. Your code should now look like the code image again. Save your work!"
  },
  "Articles/General/ScriptTemplates.html": {
    "href": "Articles/General/ScriptTemplates.html",
    "title": "Script Templates",
    "keywords": "Script Templates We've added Script Templates to make it easier to create derived class scripts that inherit from our base classes. All possible overrides are already made for you and organized They're all fully commented as to what they all do Base method calls are all in place where needed so you can see what they already do. Each has links at the top to their doc page(s) After importing Mirage and restarting Unity, the Mirage section will appear under the Assets > Create menu, as well as the context menu that comes up when you right-click on any folder in your project. You'll be prompted for the file name like any other asset creation. Hopefully these templates will be helpful to new users of Mirage to learn what methods are available in various classes, as well as just being more convenient for everyone."
  },
  "Articles/General/Showcase.html": {
    "href": "Articles/General/Showcase.html",
    "title": "Showcase",
    "keywords": "Showcase [!Video https://www.youtube.com/embed/D_f_MntrLVE] Cubica | The multiplayer version of Block Story Alteros Online | Science-Fantasy Post Apo 3D MMORPG"
  },
  "Articles/General/Start.html": {
    "href": "Articles/General/Start.html",
    "title": "Getting Started",
    "keywords": "Getting Started This document describes steps to creating a multiplayer game with Mirage. The process described here is a simplified, higher level version of the actual process for a real game; it doesnt always work exactly like this, but it provides a basic recipe for the process. Video tutorials Check out these awesome videos showing you how to get started with mirror. Courtesy of First Gear Games also known as Punfish in discord. Script Templates Create new Network Behaviours and other common scripts faster See Script Templates . Networking set-up Right click in the Scene, select Network > NetworkManager . This will create a new GameObject with all the neccessary networking components set up for you. Add the NetworkManagerHUD component to the game object. This provides the default UI for managing the network game state. See Using the NetworkManager . Player Prefab Find the Prefab for the player game object in the game, or create a Prefab from the player game object Add the NetworkIdentity component to the player Prefab Set the playerPrefab field on the PlayerSpawner component to the player Prefab. You can find this component on the GameObject you created in the first setup. Remove the player game object instance from the Scene if it exists in the Scene See Player Objects for more information. Player movement Add a NetworkTransform component to the player Prefab Check the Client Authority checkbox on the component. Update input and control scripts to respect IsLocalPlayer Subscribe to NetIdentity.OnStartLocalPlayer event to take control of the Main Camera in the scene for the player. For example, this script only processes input for the local player: using UnityEngine; using Mirror; public class Controls : NetworkBehaviour { void Update() { if (!IsLocalPlayer) { // exit from update if this is not the local player return; } // handle player input for movement } } Basic player game state Make scripts that contain important data into NetworkBehaviours instead of MonoBehaviours Make important member variables into SyncVars See State Synchronization . Networked actions Make scripts that perform important actions into NetworkBehaviours instead of MonoBehaviours Update functions that perform important player actions to be ServerRpc s See Networked Actions . Non-player game objects Fix non-player prefabs such as enemies: Add the NetworkIdentify component Add the NetworkTransform component Register spawnable Prefabs with the ClientObjectManager Update scripts with game state and actions Spawners Potentially change spawner scripts to be NetworkBehaviours Modify spawners to only run on the server (use IsServer property or the OnStartServer callback) Call ServerObjectManager.Spawn() for created game objects Spawn positions for players Add a new game object and place it at players start location Add this GameObject to the PlayerSpawner 's Positions list."
  },
  "Articles/General/Support.html": {
    "href": "Articles/General/Support.html",
    "title": "Support",
    "keywords": "Support Discord You can find us on Discord . GitHub You can create an issue in GitHub You can also contribute with Pull Requests...see Contributing"
  },
  "Articles/General/Troubleshooting.html": {
    "href": "Articles/General/Troubleshooting.html",
    "title": "Troubleshooting",
    "keywords": "Troubleshooting No Writer found for X Mirage normally generates readers and writers for any Data Type In order to do so, it needs to know what types you want to read or write. You are getting this error because Mirage did not know you wanted to read or write this type. Mirage scans your code looking for calls to Send, ReceiveHandler, Write or Read. It will also recognize syncvars and parameters to rpc methods. If it does not find one, it assumes you are not trying to serialize the type so it does not generate the reader and writer. For example, you might get this error with this code when trying to sync the synclist. struct MyCustomType { public int id; public string name; } class MyBehaviour : NetworkBehaviour { SyncList<MyCustomType> mylist = new SyncList<MyCustomType>(); } In this case there is no direct invocation to send or receive. So Mirage does not know about it. There is a simple workaround: add a call to NetworkWriter.Write<MyCustomType> anywhere in your code. For example: struct MyCustomType { public int id; public string name; } class MyBehaviour : NetworkBehaviour { SyncList<MyCustomType> mylist = new SyncList<MyCustomType>(); // This is a dummy method that is never called. // When Mirage builds your app, it will look at this code // and realize that you do want to read and write MyCustomType // so it will generate the reader and writer for it void DummyWrite(NetworkWriter writer) { writer.Write(new MyCustomType()); } }"
  },
  "Articles/Guides/Attributes.html": {
    "href": "Articles/Guides/Attributes.html",
    "title": "Attributes Overview",
    "keywords": "Attributes Overview Networking attributes are added to member functions of NetworkBehaviour scripts, to make them run on either the client or server. These attributes can be used for Unity game loop methods like Start or Update, as well as other implemented methods. NOTE : when using abstract or virtual methods the Attributes need to be applied to the override methods too. ServerAttribute Only a server can call the method (throws an error when called on a client unless you specify error = false). ClientAttribute Only a Client can call the method (throws an error when called on the server unless you specify error = false). ClientRpcAttribute The server uses a Remote Procedure Call (RPC) to run that function on clients. It has a target option allowing you to specify in which clients it should be executed, along with a channel option. See also: Remote Actions ServerRpcAttribute Call this from a client to run this function on the server. Make sure to validate input etc. It's not possible to call this from a server. Use this as a wrapper around another function, if you want to call it from the server too. Note that you can return value from it. See also Remote Actions The allowed argument types are: Basic type (byte, int, float, string, UInt64, etc) Built-in Unity math type (Vector3, Quaternion, etc), Arrays of basic types Structs containing allowable types NetworkIdentity SyncVar SyncVars are used to synchronize a variable from the server to all clients automatically. Don't assign them from a client, it's pointless. Don't let them be null, you will get errors. You can use int, long, float, string, Vector3 etc. (all simple types) and NetworkIdentity. You can use hooks ."
  },
  "Articles/Guides/Authority.html": {
    "href": "Articles/Guides/Authority.html",
    "title": "Network Authority",
    "keywords": "Network Authority Authority is a way of deciding who owns an object and has control over it. Server Authority Server authority means that the server has control of an object. Server has authority over an object by default. This means the server would manage and control of all collectible items, moving platforms, NPCs, and any other networked objects that aren't the player. Client Authority Client authority means that the client has control of an object. When a client has authority over an object it means that they can call ServerRpc and that the object will automatically be destroyed when the client disconnects. Even if a client has authority over an object the server still controls SyncVar and control other serialization features. A component will need to use a ServerRpc to update the state on the server in order for it to sync to other clients. How to give authority By default the server has Authority over all objects. The server can give authority to objects that a client needs to control, like the player object. If you spawn a player object using NetworkServer.AddPlayerForConnection then it will automatically be given authority. Using NetworkServer.Spawn You can give authority to a client when an object is spawned. This is done by passing in the connection to the spawn message GameObject go = Instantiate(prefab); NetworkServer.Spawn(go, connectionToClient); Using identity.AssignClientAuthority You can give authority to a client any time using AssignClientAuthority . This can be done by calling AssignClientAuthority on the object you want to give authority too identity.AssignClientAuthority(conn); You may want to do this when a player picks up an item // Command on player object [ServerRpc] void PickupItem(NetworkIdentity item) { item.AssignClientAuthority(connectionToClient); } How to remove authority You can use identity.RemoveClientAuthority to remove client authority from an object. identity.RemoveClientAuthority(); Authority can't be removed from the player object. Instead you will have to replace the player object using NetworkServer.ReplacePlayerForConnection . On Authority When authority is given to or removed from an object a message will be sent to that client to notify them. This will cause the OnStartAuthority or OnStopAuthority functions to be called. Check Authority Client Side The identity.hasAuthority property can be used to check if the local player has authority over an object. Server Side The identity.connectionToClient property can be check to see which client has authority over an object. If it is null then the server has authority."
  },
  "Articles/Guides/BestPractices.html": {
    "href": "Articles/Guides/BestPractices.html",
    "title": "Best Practices",
    "keywords": "Best Practices work in progress Custom Messages If you send custom message regularly then the message should be a struct so that there is no GC/allocations struct CreateVisualEffect { public Vector3 position; public Guid prefabId; }"
  },
  "Articles/Guides/ClockSync.html": {
    "href": "Articles/Guides/ClockSync.html",
    "title": "Clock Synchronization",
    "keywords": "Clock Synchronization For many algorithms you need the clock to be synchronized between the client and the server. Mirage does that automatically for you. To get the current time use this code: double now = NetworkTime.time; It will return the same value in the client and the servers. It starts at 0 when the server starts. Note the time is a double and should never be casted to a float. Casting this down to a float means the clock will lose precision after some time: after 1 day, accuracy goes down to 8 ms after 10 days, accuracy is 62 ms after 30 days , accuracy is 250 ms after 60 days, accuracy is 500 ms Mirage will also calculate the RTT time as seen by the application: double rtt = NetworkTime.rtt; You can measure accuracy. double time_standard_deviation = NetworkTime.timeSd; for example, if this returns 0.2, it means the time measurements swing up and down roughly 0.2 s Network hiccups are compensated against by smoothing out the values using EMA. You can configure how often you want the the ping to be sent: NetworkTime.PingFrequency = 2.0f; You can also configure how many ping results are used in the calculation: NetworkTime.PingWindowSize = 10;"
  },
  "Articles/Guides/Communications/index.html": {
    "href": "Articles/Guides/Communications/index.html",
    "title": "Actions and Communication",
    "keywords": "Actions and Communication When you are making a multiplayer game, In addition to synchronizing the properties of networked game objects, you are likely to need to send, receive, and react to other pieces of information - such as when the match starts, when a player joins or leaves the match, or other information specific to your type of game, for example a notification to all players that a flag has been captured in a capture-the-flag style game. Within the Mirage networking High-Level API there are three main ways to communicate this type of information. Remote Actions Remote actions allow you to call a method in your script across the network. You can make the server call methods on all clients or individual clients specifically. You can also make clients call methods on the server. Using remote actions, you can pass data as parameters to your methods in a very similar way to how you call methods in local (non-multiplayer) projects. Networking Callbacks Networking callbacks allow you to hook into built-in Mirage events which occur during the course of the game, such as when players join or leave, when game objects are created or destroyed, or when a new Scene is loaded. There are two types of networking callbacks that you can implement: Network manager callbacks, for callbacks relating to the network manager itself (such as when clients connect or disconnect) Network behaviour callbacks, for callbacks relating to individual networked game objects (such as when its Start function is called, or what this particular game object should do if a new player joins the game) Network Messages Network messages are a lower level approach to sending messages (although they are still classed as part of the networking High level API). They allow you to send data directly between clients and the server using scripting. You can send basic types of data (int, string, etc) as well as most common Unity types (such as Vector3). Since you implement this yourself, these messages are not associated directly with any particular game objects or Unity events - it is up to you do decide their purpose and implement them!"
  },
  "Articles/Guides/Communications/NetworkBehaviourCallbacks.html": {
    "href": "Articles/Guides/Communications/NetworkBehaviourCallbacks.html",
    "title": "NetworkBehaviour Callbacks",
    "keywords": "NetworkBehaviour Callbacks See also NetworkBehaviour in the API Reference. There are a number of events relating to network behaviours that can occur over the course of a normal multiplayer game. These include events such as the host starting up, a player joining, or a player leaving. Each of these possible events has an associated callback that you can implement in your own code to take action when the event occurs. When you create a script which inherits from NetworkBehaviour , you can write your own implementation of what should happen when these events occur. To do this, you override the virtual methods on the NetworkBehaviour class with your own implementation of what should happen when the given event occurs. This is a full list of virtual methods (callbacks) that you can implement on NetworkBehaviour , and where they are called Server Only OnStartServer called when behaviour is spawned on server OnStopServer called when behaviour is destroyed or unspawned on server OnSerialize called when behaviour is serialize before it is sent to client, when overriding make sure to call base.OnSerialize Client only OnStartClient called when behaviour is spawned on client OnStartAuthority called when behaviour has authority when it is spawned (eg local player) called when behaviour is given authority by the sever OnStartLocalPlayer called when the behaviour is on the local player object OnStopAuthority called when authority is taken from the object (eg local player is replaced but not destroyed) OnStopClient called when object is destroyed on client by the ObjectDestroyMessage or ObjectHideMessage messages Example flows Below is some example call order for different modes NOTE: Start is called by unity before the first frame, while normally this happens after Mirage's callbacks. But if you dont call NetworkServer.Spawn the same frame as instantiate then start may be called first Note: OnRebuildObservers and OnSetHostVisibility is now on NetworkVisibility instead of NetworkBehaviour Server mode When a NetworkServer.Spawn is called (eg when new client connections and a player is created) OnStartServer OnRebuildObservers Start Client mode When local player is spawned for client OnStartAuthority OnStartClient OnStartLocalPlayer Start Host mode These are only called on the Player Game Objects when a client connects: OnStartServer OnRebuildObservers OnStartAuthority OnStartClient OnSetHostVisibility OnStartLocalPlayer Start"
  },
  "Articles/Guides/Communications/NetworkManager.html": {
    "href": "Articles/Guides/Communications/NetworkManager.html",
    "title": "Network Manager Callbacks",
    "keywords": "Network Manager Callbacks See also NetworkManager in the API Reference. NetworkManager is a helper class with instance references to the other major parts of the Mirage network."
  },
  "Articles/Guides/Communications/NetworkMessages.html": {
    "href": "Articles/Guides/Communications/NetworkMessages.html",
    "title": "Network Messages",
    "keywords": "Network Messages For the most part we recommend the high level RPC calls and SyncVar , but you can also send low level network messages. This can be useful if you want clients to send messages that are not tied to game objects, such as logging, analytics or profiling information. You can send any supported Mirage type as a message, use the Send() method on the NetworkClient, NetworkServer, and INetworkConnection classes which work the same way. The code below demonstrates how to send and handle a message: To declare a custom network message class and use it: using UnityEngine; using Mirage; public class Scores : MonoBehaviour { // attach these in the inspector public NetworkServer Server; public NetworkClient Client; public class ScoreMessage { public int score; public Vector3 scorePos; public int lives; } public void SendScore(int score, Vector3 scorePos, int lives) { ScoreMessage msg = new ScoreMessage() { score = score, scorePos = scorePos, lives = lives }; NetworkServer.SendToAll(msg); } public void Start() { Client.Connected.AddListener(OnConnected); } public void OnConnected(INetworkConnection connection) { connection.RegisterHandler<ScoreMessage>(OnScore); } public void OnScore(NetworkConnection conn, ScoreMessage msg) { Debug.Log(\"OnScoreMessage \" + msg.score); } } Note that there is no serialization code for the ScoreMessage class in this source code example. Mirage will generate a reader and writer for ScoreMessage when it sees that it is being sent."
  },
  "Articles/Guides/Communications/RemoteActions.html": {
    "href": "Articles/Guides/Communications/RemoteActions.html",
    "title": "Remote Actions",
    "keywords": "Remote Actions The network system has ways to perform actions across the network. These type of actions are sometimes called Remote Procedure Calls. There are two types of RPCs in the network system, ServerRpc - which are called from the client and run on the server; and ClientRpc calls - which are called on the server and run on clients. The diagram below shows the directions that remote actions take: Server RPC Calls Server RPC Calls are sent from player objects on the client to player objects on the server. For security, Server RPC Calls can only be sent from YOUR player object by default, so you cannot control the objects of other players. You can bypass the authority check using [ServerRpc(requireAuthority = false)] . To make a function into a Server RPC Calls, add the [ServerRpc] custom attribute to it. This function will now be run on the server when it is called on the client. Any parameters of allowed data type will be automatically passed to the server with the Server RPC Call. Server RPC Calls functions cannot be static. public class Player : NetworkBehaviour { void Update() { if (!isLocalPlayer) return; if (Input.GetKey(KeyCode.X)) DropCube(); } // assigned in inspector public GameObject cubePrefab; [ServerRpc] void DropCube() { if (cubePrefab != null) { Vector3 spawnPos = transform.position + transform.forward * 2; Quaternion spawnRot = transform.rotation; GameObject cube = Instantiate(cubePrefab, spawnPos, spawnRot); NetworkServer.Spawn(cube); } } } Be careful of sending ServerRpcs from the client every frame! This can cause a lot of network traffic. Returning values ServerRpcs can return values. It can take a long time for the server to reply, so they must return a UniTask which the client can await. To return a value, add a return value using UniTask<MyReturnType> where MyReturnType is any supported Mirage type . In the server you can make your method async, or you can use UniTask.FromResult(myresult); . For example: public class Shop: NetworkBehavior { [ServerRpc] public UniTask<int> GetPrice(string item) { switch (item) { case \"turnip\": return UniTask.FromResult(10); case \"apple\": return UniTask.FromResult(3); default: return UniTask.FromResult(int.MaxValue); } } [Client] public async UniTaskVoid DisplayTurnipPrice() { // call the RPC and wait for the response without blocking the main thread int price = await GetPrice(\"turnip\"); Debug.Log($\"Turnips price {price}\"); } } ServerRpc and Authority It is possible to invoke ServerRpcs on non-player objects if any of the following are true: The object was spawned with client authority The object has client authority set with NetworkIdentity.AssignClientAuthority the Server RPC Call has the requireAuthority option set false. You can include an optional NetworkConnectionToClient sender = null parameter in the Server RPC Call method signature and Mirage will fill in the sending client for you. Do not try to set a value for this optional parameter...it will be ignored. Server RPC Calls sent from these object are run on the server instance of the object, not on the associated player object for the client. public enum DoorState : byte { Open, Closed } public class Door : NetworkBehaviour { [SyncVar] public DoorState doorState; [ServerRpc(requireAuthority = false)] public void CmdSetDoorState(DoorState newDoorState, NetworkConnectionToClient sender = null) { if (sender.identity.GetComponent<Player>().hasDoorKey) doorState = newDoorState; } } ClientRpc Calls ClientRpc calls are sent from objects on the server to objects on clients. They can be sent from any server object with a NetworkIdentity that has been spawned. Since the server has authority, then there no security issues with server objects being able to send these calls. To make a function into a ClientRpc call, add the [ClientRpc] custom attribute to it. This function will now be run on clients when it is called on the server. Any parameters of allowed data type will automatically be passed to the clients with the ClientRpc call.. ClientRpc functions cannot be static. They must return void ClientRpc messages are only sent to observers of an object according to its Network Visibility . Player objects are always obeservers of themselves. In some cases, you may want to exclude the owner client when calling a ClientRpc. This is done with the excludeOwner option: [ClientRpc(excludeOwner = true)] . public class Player : NetworkBehaviour { int health; public void TakeDamage(int amount) { if (!isServer) return; health -= amount; Damage(amount); } [ClientRpc] void Damage(int amount) { Debug.Log(\"Took damage:\" + amount); } } When running a game as a host with a local client, ClientRpc calls will be invoked on the local client even though it is in the same process as the server. So the behaviours of local and remote clients are the same for ClientRpc calls. You can also specify which client gets the call with the target parameter. If you only want the client that owns the object to be called, use [ClientRpc(target = Client.Owner)] or you can specify which client gets the message by using [ClientRpc(target = Client.Connection)] and passing the connection as a parameter. For example: public class Player : NetworkBehaviour { int health; [Server] void Magic(GameObject target, int damage) { target.GetComponent<Player>().health -= damage; NetworkIdentity opponentIdentity = target.GetComponent<NetworkIdentity>(); DoMagic(opponentIdentity.connectionToClient, damage); } [ClientRpc(target = Client.Connection)] public void DoMagic(NetworkConnection target, int damage) { // This will appear on the opponent's client, not the attacking player's Debug.Log($\"Magic Damage = {damage}\"); } [Server] void HealMe() { health += 10; Healed(10); } [ClientRpc(target = Client.Owner)] public void Healed(int amount) { // No NetworkConnection parameter, so it goes to owner Debug.Log($\"Health increased by {amount}\"); } } Arguments to Remote Actions The arguments passed to ServerRpc and ClientRpc calls are serialized and sent over the network. You can use any supported Mirage type . Arguments to remote actions cannot be sub-components of game objects, such as script instances or Transforms."
  },
  "Articles/Guides/CommunityGuides/index.html": {
    "href": "Articles/Guides/CommunityGuides/index.html",
    "title": "Community Guides",
    "keywords": "Community Guides This section contains guides written by the community rather than by the developers themselves Mirage Quick Start Guide by StephenAllenGames.co.uk If you want to submit a guide either create a Pull request or ask in the discord"
  },
  "Articles/Guides/CommunityGuides/MirageQuickStartGuide/index.html": {
    "href": "Articles/Guides/CommunityGuides/MirageQuickStartGuide/index.html",
    "title": "Mirage Quick Start Guide",
    "keywords": "Mirage Quick Start Guide This guide currently shows you: Basic scene setup Player movement Names and colours Scene script with canvas buttons Weapon switching It is best to first make a mini practice game before converting your single player game, or creating your ideal brand new multiplayer. The Pre-made Mirage examples are great for using as reference, it is recommend to use them regarding connection setup, with ports and firewalls. This can be a huge topic that changes from person to person, and is not covered in this guide, here we will use localHost (multiple games on same PC). Part 1 Blank Project, import UniTask and Mirage using Unity package manager. Part 2 Create new scene, save it, and add it to build settings Create a new GameObject, name it NetworkManager in the scene, and add these 3 components NetworkManager KcpTransport NetworkManagerHUD On the NetworkManager component, drag your Offline and Online scene into the slots, we have only one scene for now, so put your scene in both The scene must be in the build settings before dragging it to the field Part 3 Setup the scene Add a simple Plane floor with: positions (0, -1, 0) scale (2, 2, 2) (optional) add a material to this, I added one called dirt that is used one of mirrors examples Next we add a GameObject, name does not matter Add NetworkStartPosition component to this GameObject Duplicate the GameObject a few times, and scatter around your scene floor so that you have multiple spawn points. I did 4, one near each corner Part 4 Creating the player Create a capsule using the menus as shown in the image Attached a NetworkTransform component, this will auto add a Network Identity Tick Client Authority on the NetworkTransform Rename that object Player Add an empty PlayerScript Drag into Project to create a prefab Then delete Player from scene Drag your player prefab into Network manager, Set spawn method to Round Robin. Part 5 Add the following to your PlayerScript. using Mirage; using UnityEngine; namespace QuickStart { public class PlayerScript : NetworkBehaviour { public override void OnStartLocalPlayer() { Camera.main.transform.SetParent(transform); Camera.main.transform.localPosition = new Vector3(0, 0, 0); } void Update() { if (!isLocalPlayer) { return; } float moveX = Input.GetAxis(\"Horizontal\") * Time.deltaTime * 110.0f; float moveZ = Input.GetAxis(\"Vertical\") * Time.deltaTime * 4f; transform.Rotate(0, moveX, 0); transform.Translate(0, 0, moveZ); } } } Part 6 Press play in Unity editor, and then Host (server + client) button in the game window. You should be able to move around with a first person view capsule. Part 7 Build and run your scene, open it, host on one, and press the Client button on the other. Congrats you made a mini multiplayer game! Part 8 Player name above heads Inside your player Prefab, create an empty GameObject name it something like FloatingInfo position Y to 1.5 scale X to -1 Inside that FloatingInfo , create a 3D text using Unity menu (GameObject - 3D Object - 3D Text), Set it up as shown in the picture below Part 9 Update your PlayerScript.cs with this: using Mirage; using UnityEngine; namespace QuickStart { public class PlayerScript : NetworkBehaviour { public TextMesh playerNameText; public GameObject floatingInfo; private Material playerMaterialClone; [SyncVar(hook = nameof(OnNameChanged))] public string playerName; [SyncVar(hook = nameof(OnColorChanged))] public Color playerColor = Color.white; void OnNameChanged(string _Old, string _New) { playerNameText.text = playerName; } void OnColorChanged(Color _Old, Color _New) { playerNameText.color = _New; playerMaterialClone = new Material(GetComponent<Renderer>().material); playerMaterialClone.color = _New; GetComponent<Renderer>().material = playerMaterialClone; } public override void OnStartLocalPlayer() { Camera.main.transform.SetParent(transform); Camera.main.transform.localPosition = new Vector3(0, 0, 0); floatingInfo.transform.localPosition = new Vector3(0, -0.3f, 0.6f); floatingInfo.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f); string name = \"Player\" + Random.Range(100, 999); Color color = new Color(Random.Range(0f, 1f), Random.Range(0f, 1f), Random.Range(0f, 1f)) CmdSetupPlayer(name, color); } [Command] public void CmdSetupPlayer(string _name, Color _col) { // player info sent to server, then server updates sync vars which handles it on all clients playerName = _name; playerColor = _col; } void Update() { if (!isLocalPlayer) { // make non-local players run this floatingInfo.transform.LookAt(Camera.main.transform); return; } float moveX = Input.GetAxis(\"Horizontal\") * Time.deltaTime * 110.0f; float moveZ = Input.GetAxis(\"Vertical\") * Time.deltaTime * 4f; transform.Rotate(0, moveX, 0); transform.Translate(0, 0, moveZ); } } } Part 10 Add the PlayerNameText and FloatingInfo objects into the script on the player prefab, as shown below. Now if you build and run, host on one, join on the other, you will see player names and colors synced across the network! Well done, 5 stars to you! Part 11 A scene networked object all can access and adjust. Create a SceneScript.cs, add it onto an empty GameObject in the scene called SceneScript. Then create a Canvas with text and button, similar to below. Add the sceneScript variable, Awake function, and CmdSendPlayerMessage to PlayerScript.cs Also add the new playerName joined line to CmdSetupPlayer(); private SceneScript sceneScript; void Awake() { //allow all players to run this sceneScript = GameObject.FindObjectOfType<SceneScript>(); } [Command] public void CmdSendPlayerMessage() { if (sceneScript) { sceneScript.statusText = $\"{playerName} says hello {Random.Range(10, 99)}\"; } } [Command] public void CmdSetupPlayer(string _name, Color _col) { //player info sent to server, then server updates sync vars which handles it on all clients playerName = _name; playerColor = _col; sceneScript.statusText = $\"{playerName} joined.\"; } public override void OnStartLocalPlayer() { sceneScript.playerScript = this; //. . . . ^ new line to add here Add this code to SceneScript.cs using Mirage; using UnityEngine; using UnityEngine.UI; namespace QuickStart { public class SceneScript : NetworkBehaviour { public Text canvasStatusText; public PlayerScript playerScript; [SyncVar(hook = nameof(OnStatusTextChanged))] public string statusText; void OnStatusTextChanged(string _Old, string _New) { //called from sync var hook, to update info on screen for all players canvasStatusText.text = statusText; } public void ButtonSendMessage() { if (playerScript != null) { playerScript.CmdSendPlayerMessage(); } } } } Attach the ButtonSendMessage function to your Canvas Button. Attach Canvas Scene Text to SceneScript variable. ignore SceneScripts, playerScript variable, it automatically sets this! Now if you build and run, host and join, you can send messages, and have a text log for actions! Wahooo! Experiment and adjust, have fun! Part 12 Weapon switching! The code bits. Add the following to your PlayerScript.cs private int selectedWeaponLocal = 1; public GameObject[] weaponArray; [SyncVar(hook = nameof(OnWeaponChanged))] public int activeWeaponSynced; void OnWeaponChanged(int _Old, int _New) { // disable old weapon // in range and not null if (0 < _Old && _Old < weaponArray.Length && weaponArray[_Old] != null) { weaponArray[_Old].SetActive(false); } // enable new weapon // in range and not null if (0 < _New && _New < weaponArray.Length && weaponArray[_New] != null) { weaponArray[_New].SetActive(true); } } [Command] public void CmdChangeActiveWeapon(int newIndex) { activeWeaponSynced = newIndex; } void Awake() { // disable all weapons foreach (var item in weaponArray) { if (item != null) { item.SetActive(false); } } } Add the weapon switch button in update. Only local player switches its own weapon, so it goes below the !isLocalPlayer check. void Update() { if (!isLocalPlayer) { // make non-local players run this floatingInfo.transform.LookAt(Camera.main.transform); return; } float moveX = Input.GetAxis(\"Horizontal\") * Time.deltaTime * 110.0f; float moveZ = Input.GetAxis(\"Vertical\") * Time.deltaTime * 4f; transform.Rotate(0, moveX, 0); transform.Translate(0, 0, moveZ); if (Input.GetButtonDown(\"Fire2\")) //Fire2 is mouse 2nd click and left alt { selectedWeaponLocal += 1; if (selectedWeaponLocal > weaponArray.Length) { selectedWeaponLocal = 1; } CmdChangeActiveWeapon(selectedWeaponLocal); } } Part 13 Weapon models Add the basic cube weapons first, change these later. Double click your player prefab to enter it Add a \"WeaponsHolder\" empty GameObject, with position and rotation at 0,0,0. Inside that GameObject, create a cube from unity menu, (GameObject, 3D object, cube)- Remove the box colliders. Rename this Weapon1 , change position and scale to match the below pictures. Duplicate weapon 1 for a Weapon 2, and change its scale and position, now you should have 2 different looking weapons! Part 14 Weapon switch finale. Add these 2 GameObjects to your PlayerScript.cs weapons array. Disable weapon 2, so only weapon 1 shows when spawning. Build and run! You should see each player switching weapons, and whatever your player has equipped, will auto show on new joining players (sync var and hook magic!)"
  },
  "Articles/Guides/DataTypes.html": {
    "href": "Articles/Guides/DataTypes.html",
    "title": "Data types",
    "keywords": "Data types The client and server can pass data to each other via Remote methods , State Synchronization or via Network Messages Mirage supports a number of data types you can use with these, including: Basic c# types (byte, int, char, uint, UInt64, float, string, etc) Built-in Unity math type (Vector3, Quaternion, Rect, Plane, Vector3Int, etc) URI NetworkIdentity Game object with a NetworkIdentity component attached See important details in Game Objects section below. Structures with any of the above It's recommended to implement IEquatable<T> to avoid boxing, and to have the struct readonly because modifying one of fields doesn't cause a resync Classes as long as each field has a supported data type These will allocate garbage and will be instantiated new on the receiver every time they're sent. ScriptableObject as long as each field has a supported data type These will allocate garbage and will be instantiated new on the receiver every time they're sent. Arrays of any of the above Not supported with SyncVars or SyncLists ArraySegments of any of the above Not supported with SyncVars or SyncLists Game Objects Game Objects in SyncVars, SyncLists, and SyncDictionaries are fragile in some cases, and should be used with caution. As long as the game object already exists on both the server and the client, the reference should be fine. When the sync data arrives at the client, the referenced game object may not yet exist on that client, resulting in null values in the sync data. This is because interally Mirage passes the netId from the NetworkIdentity and tries to look it up on the client's NetworkIdentity.spawned dictionary. If the object hasn't been spawned on the client yet, no match will be found. It could be in the same payload, especially for joining clients, but after the sync data from another object. It could also be null because the game object is excluded from a client due to network visibility, e.g. NetworkProximityChecker . You may find that it's more robust to sync the NetworkIdentity.netID (uint) instead, and do your own lookup in NetworkIdentity.spawned to get the object, perhaps in a coroutine: public GameObject target; [SyncVar(hook = nameof(OnTargetChanged))] public uint targetID; void OnTargetChanged(uint _, uint newValue) { if (NetworkIdentity.spawned.TryGetValue(targetID, out NetworkIdentity identity)) target = identity.gameObject; else StartCoroutine(SetTarget()); } IEnumerator SetTarget() { while (target == null) { yield return null; if (NetworkIdentity.spawned.TryGetValue(targetID, out NetworkIdentity identity)) target = identity.gameObject; } } Custom Data Types Sometimes you don't want mirror to generate serialization for your own types. For example, instead of serializing quest data, you may want to serialize just the quest id, and the receiver can look up the quest by id in a predefined list. Sometimes you may want to serialize data which uses a different type not supported by Mirage, such as DateTime or System.Uri You can add support for any type by adding extension methods to NetworkWriter and NetworkReader . For example, to add support for DateTime , add this somewhere in your project: public static class DateTimeReaderWriter { public static void WriteDateTime(this NetworkWriter writer, DateTime dateTime) { writer.WriteInt64(dateTime.Ticks); } public static DateTime ReadDateTime(this NetworkReader reader) { return new DateTime(reader.ReadInt64()); } } ...then you can use DateTime in your [ServerRpc] or SyncList Inheritance and Polymorphism Sometimes you might want to send a polymorphic data type to your commands. Mirage does not serialize the type name to keep messages small and for security reasons, therefore Mirage cannot figure out the type of object it received by looking at the message. This code does not work out of the box. class Item { public string name; } class Weapon : Item { public int hitPoints; } class Armor : Item { public int hitPoints; public int level; } class Player : NetworkBehaviour { [ServerRpc] void CmdEquip(Item item) { // IMPORTANT: this does not work. Mirage will pass you an object of type item // even if you pass a weapon or an armor. if (item is Weapon weapon) { // The item is a weapon, // maybe you need to equip it in the hand } else if (item is Armor armor) { // you might want to equip armor in the body } } [ServerRpc] void CmdEquipArmor(Armor armor) { // IMPORTANT: this does not work either, you will receive an armor, but // the armor will not have a valid Item.name, even if you passed an armor with name } } CmdEquip will work if you provide a custom serializer for the Item type. For example: public static class ItemSerializer { const byte WEAPON = 1; const byte ARMOR = 2; public static void WriteItem(this NetworkWriter writer, Item item) { if (item is Weapon weapon) { writer.WriteByte(WEAPON); writer.WriteString(weapon.name); writer.WritePackedInt32(weapon.hitPoints); } else if (item is Armor armor) { writer.WriteByte(ARMOR); writer.WriteString(armor.name); writer.WritePackedInt32(armor.hitPoints); writer.WritePackedInt32(armor.level); } } public static Item ReadItem(this NetworkReader reader) { byte type = reader.ReadByte(); switch(type) { case WEAPON: return new Weapon { name = reader.ReadString(), hitPoints = reader.ReadPackedInt32() }; case ARMOR: return new Armor { name = reader.ReadString(), hitPoints = reader.ReadPackedInt32(), level = reader.ReadPackedInt32() }; default: throw new Exception($\"Invalid weapon type {type}\"); } } } Scriptable Objects People often want to send scriptable objects from the client or server. For example, you may have a bunch of swords created as scriptable objects and you want put the equipped sword in a syncvar. This will work fine, Mirage will generate a reader and writer for scriptable objects by calling ScriptableObject.CreateInstance and copy all the data. However the generated reader and writer are not suitable for every occasion. Scriptable objects often reference other assets such as textures, prefabs, or other types that can't be serialized. Scriptable objects are often saved in the in the Resources folder. Scriptable objects sometimes have a large amount of data in them. The generated reader and writers may not work or may be inneficient for these situations. Instead of passing the scriptable object data, you can pass the name and the other side can lookup the same object by name. This way you can have any kind of data in your scriptable object. You can do that by providing a custom reader and writer. Here is an example: [CreateAssetMenu(fileName = \"New Armor\", menuName = \"Armor Data\")] class Armor : ScriptableObject { public int Hitpoints; public int Weight; public string Description; public Texture2D Icon; // ... } public static class ArmorSerializer { public static void WriteArmor(this NetworkWriter writer, Armor armor) { // no need to serialize the data, just the name of the armor writer.WriteString(armor.name); } public static Armor ReadArmor(this NetworkReader reader) { // load the same armor by name. The data will come from the asset in Resources folder return Resources.Load<Armor>(reader.ReadString()); } }"
  },
  "Articles/Guides/DevServer/AWS/index.html": {
    "href": "Articles/Guides/DevServer/AWS/index.html",
    "title": "Amazon Web Services (AWS)",
    "keywords": "Amazon Web Services (AWS) During this section we will focus on using a Windows instance and connecting from a Windows computer. NOTE : AWS requires a payment method/credit card added before being able to use a Windows server. Don't forget to read up on the free tier limitations . During this example we will be using the free tier of the EC2 option, which gives us the possibility to use a Windows instance (if you have already added a payment method). For more information about which services offer a Free Tier, see AWS Free Tier . These are the steps we will go through from start to finish: Account creation Setting up an instance with the EC2 Management Console Configuring the server via RDP (Remote Desktop) Setting up the firewall to allow connections through Testing the connection 1. Account Creation Go to the Account creation page and sign up with your details and payment method (e.g. credit card). Adding the payment method is necessary to run a windows instance on AWS. 2. Setting up an instance with the EC2 Management Console After setting up your account you should be logged in. Always make sure you're in your correct region so it's a good habit to check in the top right corner. Change it to the closest location to you now. After this click on Services in the top left corner and click on EC2. This will bring you to the EC2 instance dashboard and ready to Launch your instance! Click on \"Launch Instance\" . There are 7 steps to creating your AWS Instance: Choose an Amazon Machine Image (AMI) Choose Instance Type Configure Instance Add Storage Add Tags Configure Security Group Review Step 1: Choose an Amazon Machine Image Scroll down until you see the Microsoft Windows Server 2019 Base (take the newest one if this is outdated). Make sure that the option you select has the \"Free Tier Eligible\" under the icon and click on \"Select\". Step 2: Choose Instance Type Make sure you choose the instance type with the \"free tier eligible\", at the time of writing this is the t2.micro instance. Click on \"Next: Configure Instance Details\" . Do not click on Review and Launch. Step 3: Configure Instance Nothing has to be changed at this step. Keep it default. Click on \"Next: Add Storage\" . Step 4: Add Storage Nothing has to be changed. Keep it default. The 30GB is more than you need but there will be an error if you choose a lower amount. Keep in mind that you can always click \"Previous\" if you need to return, you do not need to repeat the entire process if you make a mistake (unless you click Launch at the end). Click on \"Next: Add Tags\" to continue. Step 5: Add Tags Nothing has to be changed. Keep it default. Click on \"Next: Configure Security Groups\" Step 6: Configure Security Groups IMPORTANT STEP This makes it possible to connect to your instance from outside for: RDP (needed for this example) For clients connecting through port 7777 for your Mirage Project. SSH (if needed) Create a new security group and you can give it your own name and description. Add the following rules: RDP with source \"Anywhere\", Description can be whatever but put it as Remote Desktop Program. Custom UDP Rule with port 7777 and source \"Anywhere\", Description can be whatever but put it as Mirage. SSH with source \"Anywhere\", Description can be whatever but put it as SSH. SSH is not strictly necessary but can be used to remote connect to it through other means than the RDP. You can ignore the warning about the source as this is just a testing environment. In the future you might wish to restrict this but you will almost never know the clients' connection IP's beforehand. Click on \"Next: Review and Launch\" Step 7: Review Almost there! Make sure everything is correct and you are using the free tier, then click on \"Launch\" . One more thing: A window will pop up asking for your key pair. Just create a new one by selecting the dropdown: \"Create a new key pair\" and give it a name, click on \"Download Key Pair\" . Keep the key file (.PEM File) somewhere secure (To be 100% certain, back it up somewhere). YOU CANNOT ACCESS THE CREATED INSTANCE WITHOUT THIS KEY Now you can (finally) click on \"Launch Instances\" ! Go back to your EC2 dashboard by clicking on \"Services\" at the top left and clicking on EC2. Now you see you have \"Running Instances: 1\". Click on \"Running Instances\" to continue . A new instance might take around 5-10 minutes to set up. Refresh the page after 10 minutes if nothing changes. Now you did all this but you want to get ON the dedicated server right? Perfect! The next step will get you up and running! 3. Configuring the server via RDP (Remote Desktop) Time to get the RDP file so you can start connecting. There are a few things we'll need: RDP file with the key pair added to it Configure RDP file once downloaded to allow getting files from our C: drive or other drives (so you can easily get your zip project) Enter the windows Admin password once you start the RDP file Once you've done this, you should be able to continue using the same RDP file. RDP file with the key pair added to it Get the password before clicking Download Copy the Password for later Now click on \"Download Remote Desktop File\" . The RDP file will be downloaded. Configure RDP file for easy file access Go to your freshly downloaded RDP file and rightclick it and then click \"Edit\". Go to the third tab \"Local sources\", at the bottom click \"more\" under local devices and sources. On the new window select your C: drive or any other drive. This is your own computer your connecting from. For easy file exchange. Perfect! Now you can run the RDP file! The RDP file will ask a password. If you forgot your password you can get it back by rightclicking the instance and clicking on \"Get Windows Password\". You will be asked to re-enter your key pair (.PEM) file and decrypt the message. Once done you will be able to copy the password. There you have it! Now you have your password and Remote Desktop should show you logging into your dedicated server! Setting up the firewall to allow connections through Go to the windows firewall settings, go to the advanced firewall settings and go to inbound rules. Add a new rule and choose the port type. Select UDP and enter the 7777 port (or any other if you use another port in Mirage). Continue clicking next and keep things default. Close all the windows when done. AWESOME! You now have everything set up to accept incoming requests on port 7777 . 4. Testing the connection Before you can (finally) test out your server build of your project you need to get it on the dedicated server! Place your (zipped) server build at the root of your added drive (C: or another) to make it easier to find it fast. Go to \"My Computer\" and because of our previous changes to the RDP we should now see your local drive under \"Devices and Drives\". Double click it and because you placed your zipped server build on that drive, you should see it immediatly when it's done loading. Now unzip the project in a new folder on the dedicated server's desktop and run it. Want to test if it sees the 7777 port is open after you started your Mirage server? Get your IPv4 public IP from the EC2 Management Console from your instance and use it on your client to connect to that IP. Go to PortChecker and enter the Dedicated Server IP address and enter port 7777. NOTE: If you are not running your game / project then the port will be closed. It's only open when the server is running."
  },
  "Articles/Guides/DevServer/gcloud/index.html": {
    "href": "Articles/Guides/DevServer/gcloud/index.html",
    "title": "Google Cloud Services",
    "keywords": "Google Cloud Services This guide will explain how to set up a Linux server running on Google Cloud . Google cloud offers $300 free credits to new users for a limited time, and it also have \"Always free products\". See overview and docs for more information. Before you begin In the Cloud Console, on the project selector page, select or create a Cloud project. Note: If you don't plan to keep the resources that you create in this procedure, create a project instead of selecting an existing project. After you finish these steps, you can delete the project, removing all resources associated with the project. Go to the project selector page You may need to enable billing for your Google Cloud project. If you have free credits (see above) then these will be used first. Learn how to confirm billing is enabled for your project. Setting up a new Server Start by creating and configuring a new Compute Engine instance. In the Cloud Console, go to the VM instances page: Go to the VM instances page If this is your first instance you will see a dialog prompting you to create a new virtual machine Click Create to get started. On the Create an instance page, configure your instance as follows: Name your instance. This tutorial uses the instance name mirror-instance-demo throughout. Select the region and zone in which you want your instance to be hosted. This tutorial uses the region us-central1 (Iowa) and the zone us-central1-a throughout. Machine configuration depends on the size of your game. For a simple example we can use a small server. select N1 for series select f1-micro for machine type In the Boot disk section, click Change. The Boot disk dialog will pop up. Change the disk type to SSD Persistent Disk. Boot disk can be left as default 10gb standard persistent disk with Debian GNU/Linux 9 (stretch) for this tutorial. You may want to change it to best fit your needs. You can instead use an ssd or increase its size, however this will increase the monthly cost. Note: The monthly estimate should be shown at the top right next to Name To configure Network settings first example the Management, security, disks, networking, solo tenancy section, then click on the Networking tab. Set a Network tag, this will allow you to set up firewall rules later on. This tutorial use mirror-demo as the tag Set up a static IP address for your instance a) Under Network interfaces click on default and it will bring up a config menu b) Select the External IP dropdown and select Create IP address c) Enter a name for this ip and press Reserve . For this tutorial we will use mirror-demo-ip Create your instance. Press the Create button at the bottom of the page to finish set up and create your instance Configure Firewall This will allow other people to connect to your server using its IP and port In the Cloud Console, go to the Firewall page. Go to the Firewall page Click Create firewall rule. On the Create a firewall rule page, fill out the form as follows: Name: mirror-demo-rule Target tags: mirror-demo Source filter: IP ranges Source IP ranges: 0.0.0.0/0 Protocols or ports: Select UDP, and then enter port 7777 into the field provided. note UDP and port 7777 is default settings for KCP transport, if you are using a different transport you will need to find out what settings that uses. Press Create to confirm setting and create the rule. Connect to your new instance Once your instance has finished being created you can press the SSH button to connect to your instance in your web browser Setting up the linux instance When you first connect you will need to set up a few things First update the list of packages sudo apt-get update Install screen and unzip sudo apt-get install -y screen unzip screen allows you to have multiple terminals, allows you do do other stuff while your game is running unzip unzips can be used to extract files from a ZIP file after you upload it to the instance Build your game Build your game with Target Platform Linux and Server Build ticked Upload and extract your game Once you have built your game zip the folder so that you can upload it to your server. In the SSH connection window click on the settings cogwheel and select Upload File then find and select your zipped build folder. This should upload the game folder to the home directory. If you need to go to the home directory you can use: cd ~ Note: the destination will be /home/username where username should be the cloud account you are logged into. Once your file has finished upload you can extract the files unzip ./mirror-demo.zip Run server Move into game folder cd mirror-demo Mark game as executable chmod +x ./mirror-demo.x86_64 You should now be able to run your game server! The following is optional but will most likely be useful Start your server in a detached screen screen -d -m -S mirrorServer ./mirror-demo.x86_64 -logfile ~/server.log The parts of the command above: screen -d -m will create the new terminal in detached mode -S mirrorServer name of the screen ./mirror-demo.x86_64 your game server file -logfile ~/server.log unity argument for log file location, this will create a log file in the home directory Create start file so you can start your server the same way each time a) create start.sh echo \"screen -d -m -S mirrorServer ./mirror-demo.x86_64 -logfile ~/server.log\" > ./start.sh b) mark as executable chmod +x ./start.sh Run your server ./start.sh Using Screen Here are a few useful commands for using screen List active screens screen -ls Attach to existing screen, process-id is show when calling screen -ls screen name is given by -S when creating the screen, for this tutorial it was mirrorServer screen -r <process-id | screen name> Detach from screen press CTRL A + D Stop your game Once attached to a screen you can press CTRL + C to stop the process, this will stop your game and close the screen View log files You can use the -logfile ~/path/to/log.log argument for Unity when starting your game server. This will cause the logs to be written to a file instead of to the terminal. This will means recent logs wont show up in screen -r . you can use the tail command to view the the end of the log file tail -n 50 ./server.log you can use the -n argument to set how many lines to show you can use the -f argument follow the end of the file stream showing you any new logs that are written to the file in real time. You will need to press CTRL + C to exit follow mode Clean up after tutorial If you used an existing project you will need to delete the following: VM instance Firewall rule If you have created a new project you should be able to just delete the project. Go to the Manage resources page"
  },
  "Articles/Guides/DevServer/index.html": {
    "href": "Articles/Guides/DevServer/index.html",
    "title": "Development Servers",
    "keywords": "Development Servers During this guide we will set up a dedicated server and place the server build of our project on the dedicated server. IMPORTANT: Before we begin, there are some potential problems you may face, as no server is truly 'free': Service providers are NOT free. Most of the time you can start with free trials for a limited time, after x amount of time or x amount of used resources the trial will end and you might incur payment. Always read the providers free trial limitations. Some providers require a payment method for using a Windows instance, however as long as you do not go over the limitations the provider should not bill you. NOTE : Mirage is not affiliated and can not be held responsible for any charges or fees associated with service providers like AWS , Microsoft Azure , Google Compute Engine and others... Introduction During your development with Mirage you will need to test your project as a client and as a server. There are a few possible ways to test your project: Default build: Host/client as one and connecting with another build/editor to the host locally on 1 computer. Server build: Server is a separate executable. You can place it on your computer run it and connect to it as a client. Dedicated Server: Same as the server build but placed on an external machine, you connect to it with the server's external ip. This guide will focus on the \"Dedicated Server\" option. There are multiple providers and even self hosted dedicated machines. All possibilities still go through the same process to ensure connectivity to clients. A few requirements for a dedicated server: Port forwarding (Not strictly necessary but makes everything a lot easier without needing NAT punchthrough) Firewall exceptions Computer/machine that stays online and accessible whenever you need it. In the upcoming sections we will go through setting up a provider with the free tier. Always double check that you do not select a paid feature as this is purely meant as a short term period to test out basic functionality during development of your project. Amazon Web Services (AWS) See AWS setup Google Compute Engine See this guides: Google cloud setup Microsoft Azure Microsoft Azure (as of time of writing) allows setting up a windows instance during the free trial without an active payment method. To be added Self Hosted Dedicated Server A self hosted dedicated server is the same as the other providers but you provide the hardware, internet connection and costs for running the computer. Most of the time this is the cheapest option during development if you already have an extra machine. Preferably you would put the machine on a different network (to simulate the conditions as the other providers). This would mean you could connect to the machine and put your server build on whenever you need and have access to the router and security settings of the machine for port forwarding and firewall exceptions. In essence, this is the simplest set up but does require extra hardware."
  },
  "Articles/Guides/FAQ.html": {
    "href": "Articles/Guides/FAQ.html",
    "title": "FAQ",
    "keywords": "FAQ work in progress How do I use this feature? How to Send/Sync custom data types? Mirage can automatically create Serialization functions for many custom data types when your scripts are compiled. For example, mirror will automatically create a functions for MyCustomStruct so that it can be sent without any extra work. [ClientRpc] public void RpcDoSomething(MyCustomStruct data) { // do stuff here } struct MyCustomStruct { int someNumber; Vector3 somePosition; } For More details DataTypes Serialization How to Connect How to connect to games on same PC Make sure the networkAddress field on NetworkManager or the Hud is set up localHost How to connect to a different PC/Device on same network Set the networkAddress field to the LAN IP of the host 192.168.x.x In some cases you may need additional steps, check below To check ip on Windows you can open powershell and use the ipconfig command, then under your current adapter (ethernet/wifi/etc) look for IPv4 Address IPv4 Address. . . . . . . . . . . : 192.168.x.x How to connect to a different PC/Device over the internet Set the networkAddress field to be the IP address of the host (google 'whats my IP') This section does not cover relays/dedicated vps/headless features For this to work, you will need to do some of the following, most of these depend on your set up and router Port forward : you'll have to login your Router Either forward your game port (default is 7777) for your PC's local IP. (192.168.1.20 for example) Or the quick (but less safe) add that local IP to DMZ. PC Firewalls : You can turn it off for a quick test (And turn it back on later) manually allow the editor and any builds you create it in firewalls settings. Try from a build rather than the Unity Editor Some anti virus/phones may have additional blocking. You can turn it off for a quick test (And turn it back on later) In rare cases ISPs or companies/schools block ports and connections, this is harder to adjust yourself. If you need more help it is best to google for guide for your setup and router. An alternative to the above is to use a dedicated server (vps) or use a relay."
  },
  "Articles/Guides/GameObjects/index.html": {
    "href": "Articles/Guides/GameObjects/index.html",
    "title": "Networked Game Objects",
    "keywords": "Networked Game Objects Networked game objects are game objects which are controlled and synchronized by Mirages networking system. Using synchronized networked game objects, you can create a shared experience for all the players who are playing an instance of your game. They see and hear the same events and actions - even though that may be from their own unique viewpoints within your game. Multiplayer games in Mirage are typically built using Scenes that contain a mix of networked game objects and regular (non-networked) game objects. The networked game objects are those which move or change during gameplay in a way that needs to be synchronized across all users who are playing the game together. Non-networked game objects are those which either dont move or change at all during gameplay (for example, static obstacles like rocks or fences), or game objects which have movement or changes that dont need to be synchronized across players (for example, a gently swaying tree or clouds passing by in the background of your game). A networked game object is one which has a Network Identity component attached. However, a Network Identity component alone is not enough for your game object to be functional and active in your multiplayer game. The Network Identity component is the starting point for synchronization, and it allows the Network Manager to synchronize the creation and destruction of the game object, but other than that, it does not specify which properties of your game object should be synchronized. What exactly should be synchronized on each networked game object depends on the type of game you are making, and what each game objects purpose is. Some examples of what you might want to synchronize are: The position and rotation of moving game objects such as the players and non-player characters. The animation state of an animated game object The value of a variable, for example how much time is left in the current round of a game, or how much energy a player has. As a convenience, the initial position, rotation and scale of the object is automatically synchronized by the NetworkIdentity. Any other state you wish to synchronize accross the network needs to go in a NetworkBehaviour inside your GameObject. When an object is created in the server, you must tell Mirage to create it in the clients and keep track of it. This is known as Spawning."
  },
  "Articles/Guides/GameObjects/Lifecycle.html": {
    "href": "Articles/Guides/GameObjects/Lifecycle.html",
    "title": "Lifecycle of a GameObject",
    "keywords": "Lifecycle of a GameObject Networked GameObjects go through several lifecycle states. You can add custom logic to the object lifecycle events by subscribing to the corresponding event in NetworkIdentity Server Client Instantiate Start Server Instantiate StartAuthority StartClient StartLocalPlayer StopAuthority StopServer Destroy StopClient Destroy Note: In Mirror and UNet, you can add logic to lifecycle events by overriding methods in NetworkBehaviour In Mirage you do it by subscribing to events in NetworkIdentity Server Instantiate This is done usual by you using Unity's GameObject.Instantiate This goes through the regular GameObject Lifecycle events such as Awake, Start, Enabled, etc.. Basically this is outside Mirage's control. Scene Objects are normally instantiated as part of the scene. Server Start To start a server object, spawn it . If you wish to perform some logic when the object starts in the server, add a component in your gameobject with your own method and subscribe to OnStartServer For example: class MyComponent : MonoBehaviour { public void Awake() { GetComponent<NetworkIdentity>.OnStartServer.AddListener(OnStartServer); } public void OnStartServer() { Debug.Log(\"The object started on the server\") } } You can also simply drag your OnStartServer method in the OnStartServer event in the inspector. During the spawn a message will be sent to all the clients telling them to spawn the object. The message will include all the data in SyncVars , SyncLists , SyncSet , SyncDictionary Client Instantiate When an object is spawned, the server will send a message to the clients telling it to spawn a GameObject and provide an asset id. By default, Mirage will look up all the known prefabs looking for that asset id. Make sure to add your prefabs in the NetworkClient list of prefabs. Then Mirage will instantiate the prefab, and it will go through the regular Unity Lifecycle events. You can customize how objects are instantiated using Spawn Handlers. Do not add Network logic to these events. Instead, use these events to subscribe to network events in NetworkIdentity. Immediatelly after the object is instantiated, all the data is updated to match the data in the server. Client Start Authority If the object is owned by this client, then NetworkIdentity will invoke the OnStartAuthority Subscribe to this event either by using AddListener , or adding your method to the event in the inspector. Note the Authority can be revoked, and granted again. Every time the client gains authority, this event will be invoked again. Start Client The event OnStartClient will be invoked. Subscribe to this event by using AddListener or adding your method in the event in the inspector Start Local Player If the object spawned is the player object , the event OnStartLocalPlayer is invoked. Subscribe to this event by using AddListener or adding your method in the event in the inspector Stop Authority If the object loses authority over the object, then NetworkIdentity will invoke the OnStopAuthority Subscribe to this event either by using AddListener , or adding your method to the event in the inspector. Note the Authority can be revoked, and granted again. Every time the client loses authority, this event will be invoked again. Server Stop Either because the client disconnected, the server stopped, you called UnSpawn(GameObject) , or you called Destroy(GameObject) the object may stop in the server. During this state, a message is sent to all the clients to unspawn the object. The event OnStopServer will be invoked. Subscribe to this event either by using AddListener , or adding your method to the event in the inspector. Server Destroy By default, the server will call GameObject.Destroy to destroy the object. Note that if it is a Scene Object the server will invoke GameObject.SetActive(false) instead. The regular unity lifecycle events apply. Note that the server will destroy the object, and will not wait for the clients to unspawn their objects. Stop Client This can be triggered either because the client received an Unspawn message or the client was disconnected The event OnStopClient will be invoke. Subscribe to this event either by using AddListener , or adding your method to the event in the inspector. Use it to cleanup any network related resource used by this object. Client Destroy After an object is stopped on the client, by default unity will call GameObject.Destroy if it is a prefab Spawned Object Or it will call GameObject.SetActive(false) if it is a Scene Object You can customize how objects are destroying using Spawn Handlers The normal Unity lifecycle events applies."
  },
  "Articles/Guides/GameObjects/NetworkBehaviour.html": {
    "href": "Articles/Guides/GameObjects/NetworkBehaviour.html",
    "title": "NetworkBehaviour",
    "keywords": "NetworkBehaviour See also NetworkBehaviour in the API Reference. Network Behaviour scripts work with game objects that have a NetworkIdentity component. These scripts can perform high-level API functions such as ServerRpcs, ClientRpcs and SyncVars. With the server-authoritative system of Mirage, the server must use the NetworkServer.Spawn function to spawn game objects with Network Identity components. Spawning them this way assigns them a netId and creates them on clients connected to the server. Note: This is not a component that you can add to a game object directly. Instead, you must create a script which inherits from NetworkBehaviour (instead of the default MonoBehaviour ), then you can add your script as a component to a game object. NetworkBehaviour scripts have the following features: NetworkBehaviour Synchronized variables Server and Client functions Server RPC Calls Client RPC Calls Note: NetworkBehaviors in Mirror and in UNet provide virtual functions as a way for you to add logic in response to lifecycle events. Mirage does not, instead add listeners to the events in NetworkIdentity . Synchronized variables Your component can have data which is automatically synchronized from the server to the client. You can use SyncVars as well as SyncLists , SyncSet and SyncDictionary inside a NetworkBehaviour. They will be automatically propagated to the clients whenever their value change in the server. Server and Client functions You can tag member functions in NetworkBehaviour scripts with custom attributes to designate them as server-only or client-only functions. ServerAttribute will check that the function is called in the server. Likewise, ClientAttribute will check if the function is called in the client. For more information, see Attributes . Server RPC Calls To execute code on the server, you must use Server RPC calls. The high-level API is a server-authoritative system, so ServerRpc are the only way for a client to trigger some code on the server. Only player game objects can send ServerRpcs. When a client player game object sends a ServerRpc, that ServerRpc runs on the corresponding player game object on the server. This routing happens automatically, so it is impossible for a client to send a ServerRpc for a different player. To define a Server RPC Call in your code, you must write a function which has: A name that begins with Cmd The ServerRpc attribute Server RPC Calls are called just by invoking the function normally on the client. Instead of the ServerRpc function running on the client, it is automatically invoked on the corresponding player game object on the server. Server RPC Calls are type-safe, have built-in security and routing to the player, and use an efficient serialization mechanism for the arguments to make calling them fast. See Communications and related sections for more information. Client RPC Calls Client RPC calls are a way for server game objects to make things happen on client game objects. Client RPC calls are not restricted to player game objects, and may be called on any game object with a Network Identity component. To define a Client RPC call in your code, you must write a function which: Has a name that begins with Rpc Has the ClientRpc attribute See Communications and related sections for more information."
  },
  "Articles/Guides/GameObjects/PickupDropChild.html": {
    "href": "Articles/Guides/GameObjects/PickupDropChild.html",
    "title": "Pickups, Drops, and Child Objects",
    "keywords": "Pickups, Drops, and Child Objects Frequently the question comes up about how to handle objects that are attached as children of the player prefab that all clients need to know about and synchronize, such as which weapon is equipped, picking up networked scene objects, and players dropping objects into the scene. Mirage cannot support multiple Network Identity components within an object hierarchy. Since the Player object must have a Network Identity, none of its descendant objects can have one. Child Objects Let's start with the simple case of a single attachment point that is somewhere down the hierarchy of our Player, such as a hand at the end of an arm. In a script that inherits from NetworkBehaviour on the Player Prefab, we'd have a GameObject reference where the attachment point can be assigned in the inspector, a SyncVar enum with various choices of what the player is holding, and and a Hook for the SyncVar to swap out the art of the held item based on the new value. In the image below, Kyle has an empty game object, RightHand , added to the wrist, and some prefabs to be equipped (Ball, Box, Cylinder), and a Player Equip script to handle them. NOTE : The item prefabs are art only ...they have no scripts, and they must not have networking components. They can have monobehaviour-based scripts, of course, which can be referenced and called from ClientRpc's on the player prefab. The inspector shows RightHand assigned in 2 places, the Player Equip script, as well as the target of the Network Transform Child component, so we could adjust the relative position of the attachment point (not the art) for all clients as needed. Below is the Player Equip script to handle the changing of the equipped item, and some notes for consideration: While we could just have all the art items attached at design time and just enable / disable them based on the enum, this doesn't scale well to a lot of items and if they have scripts on them for how they behave in the game, such as animations, special effects, etc. it could get ugly pretty fast, so this example locally instantiates and destroys instead as a design choice. The example makes no effort to deal with position offset between the item and the attach point, e.g. having the grip or handle of an item align with the hand. This is best dealt with in a monobehaviour script on the item that has public fields for the local position and rotation that can be set in the designer and a bit of code in Start to apply those values in local coordinates relative to the parent attach point. using UnityEngine; using System.Collections; using Mirage; public enum EquippedItem : byte { nothing, ball, box, cylinder } public class PlayerEquip : NetworkBehaviour { public GameObject sceneObjectPrefab; public GameObject rightHand; public GameObject ballPrefab; public GameObject boxPrefab; public GameObject cylinderPrefab; [SyncVar(hook = nameof(OnChangeEquipment))] public EquippedItem equippedItem; void OnChangeEquipment(EquippedItem oldEquippedItem, EquippedItem newEquippedItem) { StartCoroutine(ChangeEquipment(newEquippedItem)); } // Since Destroy is delayed to the end of the current frame, we use a coroutine // to clear out any child objects before instantiating the new one IEnumerator ChangeEquipment(EquippedItem newEquippedItem) { while (rightHand.transform.childCount > 0) { Destroy(rightHand.transform.GetChild(0).gameObject); yield return null; } switch (newEquippedItem) { case EquippedItem.ball: Instantiate(ballPrefab, rightHand.transform); break; case EquippedItem.box: Instantiate(boxPrefab, rightHand.transform); break; case EquippedItem.cylinder: Instantiate(cylinderPrefab, rightHand.transform); break; } } void Update() { if (!isLocalPlayer) return; if (Input.GetKeyDown(KeyCode.Alpha0) && equippedItem != EquippedItem.nothing) CmdChangeEquippedItem(EquippedItem.nothing); if (Input.GetKeyDown(KeyCode.Alpha1) && equippedItem != EquippedItem.ball) CmdChangeEquippedItem(EquippedItem.ball); if (Input.GetKeyDown(KeyCode.Alpha2) && equippedItem != EquippedItem.box) CmdChangeEquippedItem(EquippedItem.box); if (Input.GetKeyDown(KeyCode.Alpha3) && equippedItem != EquippedItem.cylinder) CmdChangeEquippedItem(EquippedItem.cylinder); } [ServerRpc] void CmdChangeEquippedItem(EquippedItem selectedItem) { equippedItem = selectedItem; } } Dropping Items Now that we can equip the items, we need a way to drop the current item into the world as a networked item. Remember that, as child art, the item prefabs have no networking components on them at all. First, let's add one more Input to the Update method above, and a CmdDropItem method: void Update() { if (!isLocalPlayer) return; if (Input.GetKeyDown(KeyCode.Alpha0) && equippedItem != EquippedItem.nothing) CmdChangeEquippedItem(EquippedItem.nothing); if (Input.GetKeyDown(KeyCode.Alpha1) && equippedItem != EquippedItem.ball) CmdChangeEquippedItem(EquippedItem.ball); if (Input.GetKeyDown(KeyCode.Alpha2) && equippedItem != EquippedItem.box) CmdChangeEquippedItem(EquippedItem.box); if (Input.GetKeyDown(KeyCode.Alpha3) && equippedItem != EquippedItem.cylinder) CmdChangeEquippedItem(EquippedItem.cylinder); if (Input.GetKeyDown(KeyCode.X) && equippedItem != EquippedItem.nothing) CmdDropItem(); } [ServerRpc] void CmdDropItem() { // Instantiate the scene object on the server Vector3 pos = rightHand.transform.position; Quaternion rot = rightHand.transform.rotation; GameObject newSceneObject = Instantiate(sceneObjectPrefab, pos, rot); // set the RigidBody as non-kinematic on the server only (isKinematic = true in prefab) newSceneObject.GetComponent<Rigidbody>().isKinematic = false; SceneObject sceneObject = newSceneObject.GetComponent<SceneObject>(); // set the child object on the server sceneObject.SetEquippedItem(equippedItem); // set the SyncVar on the scene object for clients sceneObject.equippedItem = equippedItem; // set the player's SyncVar to nothing so clients will destroy the equipped child item equippedItem = EquippedItem.nothing; // Spawn the scene object on the network for all to see NetworkServer.Spawn(newSceneObject); } In the image above, there's a sceneObjectPrefab field that is assigned to a prefab that will act as a container for our item prefabs. The SceneObject prefab has a SceneObject script with a SyncVar like the Player Equip script, and a SetEquippedItem method that takes the shared enum value as a parameter. using UnityEngine; using System.Collections; using Mirage; public class SceneObject : NetworkBehaviour { [SyncVar(hook = nameof(OnChangeEquipment))] public EquippedItem equippedItem; public GameObject ballPrefab; public GameObject boxPrefab; public GameObject cylinderPrefab; void OnChangeEquipment(EquippedItem oldEquippedItem, EquippedItem newEquippedItem) { StartCoroutine(ChangeEquipment(newEquippedItem)); } // Since Destroy is delayed to the end of the current frame, we use a coroutine // to clear out any child objects before instantiating the new one IEnumerator ChangeEquipment(EquippedItem newEquippedItem) { while (transform.childCount > 0) { Destroy(transform.GetChild(0).gameObject); yield return null; } // Use the new value, not the SyncVar property value SetEquippedItem(newEquippedItem); } // SetEquippedItem is called on the client from OnChangeEquipment (above), // and on the server from CmdDropItem in the PlayerEquip script. public void SetEquippedItem(EquippedItem newEquippedItem) { switch (newEquippedItem) { case EquippedItem.ball: Instantiate(ballPrefab, transform); break; case EquippedItem.box: Instantiate(boxPrefab, transform); break; case EquippedItem.cylinder: Instantiate(cylinderPrefab, transform); break; } } } In the run-time image below, the Ball(Clone) is attached to the RightHand object, and the Box(Clone) is attached to the SceneObject(Clone), which is shown in the inspector. The art prefabs have simple colliders on them (sphere, box, capsule). If your art item has a mesh collider, it must be marked as Convex to work with the RigidBody on the SceneObject container. Pickup Items Now that we have a box dropped in the scene, we need to pick it up again. To do that, a CmdPickupItem method is added to the Player Equip script: // CmdPickupItem is public because it's called from a script on the SceneObject [ServerRpc] public void CmdPickupItem(GameObject sceneObject) { // set the player's SyncVar so clients can show the equipped item equippedItem = sceneObject.GetComponent<SceneObject>().equippedItem; // Destroy the scene object NetworkServer.Destroy(sceneObject); } This method is simply called from OnMouseDown in the Scene Object script: void OnMouseDown() { NetworkClient.connection.identity.GetComponent<PlayerEquip>().CmdPickupItem(gameObject); } Since the SceneObject(Clone) is networked, we can pass it directly through to CmdPickupItem on the player object to set the equipped item SyncVar and destroy the scene object. For this entire example, the only prefab that needs to be registered with Network Manager besides the Player is the SceneObject prefab."
  },
  "Articles/Guides/GameObjects/SceneObjects.html": {
    "href": "Articles/Guides/GameObjects/SceneObjects.html",
    "title": "Scene Game Objects",
    "keywords": "Scene Game Objects There are two types of networked game objects in Mirages multiplayer system: Those that are created dynamically at runtime Those that are saved as part of a Scene Game objects that are created dynamically at runtime use the multiplayer Spawning system, and the prefabs they are instantiated from must be registered in the Network Managers list of networked game object prefabs. However, networked game objects that you save as part of a Scene (and therefore already exist in the Scene when it is loaded) are handled differently. These game objects are loaded as part of the Scene on both the client and server, and exist at runtime before any spawn messages are sent by the multiplayer system. When the Scene is loaded, all networked game objects in the Scene are disabled on both the client and the server. Then, when the Scene is fully loaded, the Network Manager automatically processes the Scenes networked game objects, registering them all (and therefore causing them to be synchronized across clients), and enabling them, as if they were spawned at runtime. Networked game objects will not be enabled until a client has requested a Player object. Saving networked game objects in your Scene (rather than dynamically spawning them after the scene has loaded) has some benefits: They are loaded with the level, so there will be no pause at runtime. They can have specific modifications that differ from prefabs Other game object instances in the Scene can reference them, which can avoid you having to use code to finding the game objects and make references to them up at runtime. When the Network Manager spawns the networked Scene game objects, those game objects behave like dynamically spawned game objects. Mirage sends them updates and ClientRPC calls. If a Scene game object is destroyed on the server before a client joins the game, then it is never enabled on new clients that join. When a client connects, the client is sent an ObjectSpawnScene spawn message for each of the Scene game objects that exist on the server, that are visible to that client. This message causes the game object on the client to be enabled, and has the latest state of that game object from the server in it. This means that only game objects that are visible to the client, and not destroyed on the server, are activated on the client. Like regular non-Scene game objects, these Scene game objects are started with the latest state when the client joins the game."
  },
  "Articles/Guides/GameObjects/SpawnObject.html": {
    "href": "Articles/Guides/GameObjects/SpawnObject.html",
    "title": "Spawning Game Objects",
    "keywords": "Spawning Game Objects In Unity, you usually spawn (that is, create) new game objects with Instantiate . However, in Mirage, the word spawn means something more specific. In the server-authoritative model of the Mirage, to spawn a game object on the server means that the game object is created on clients connected to the server, and is managed by the spawning system. Once the game object is spawned using this system, state updates are sent to clients whenever the game object changes on the server. When Mirage destroys the game object on the server, it also destroys it on the clients. The server manages spawned game objects alongside all other networked game objects, so that if another client joins the game later, the server can spawn the game objects on that client. These spawned game objects have a unique network instance ID called netId that is the same on the server and clients for each game object. The unique network instance ID is used to route messages set across the network to game objects, and to identify game objects. When the server spawns a game object with a Network Identity component, the game object spawned on the client has the same state. This means it is identical to the game object on the server; it has the same Transform, movement state, and (if Network Transform and SyncVars are used) synchronized variables. Therefore, client game objects are always up-to-date when Mirage creates them. This avoids issues such as game objects spawning at the wrong initial location, then reappearing at their correct position when a state update arrives. A game object Prefab must have a Network Identity component before trying to register it with the Network Manager. To register a Prefab with the Network Manager in the Editor, select the Network Manager game object, and in the Inspector, navigate to the Network Manager component. Click the triangle next to Spawn Info to open the settings, then under Registered Spawnable Prefabs, click the plus (+) button. Drag and drop Prefabs into the empty field to assign them to the list. Spawning Without Network Manager For more advanced users, you may find that you want to register Prefabs and spawn game objects without using the Network Manager component. To spawn game objects without using the Network Manager, you can handle the Prefab registration yourself via script. Use the ClientScene.RegisterPrefab method to register Prefabs to the Network Manager. using UnityEngine; using Mirage; public class MyNetworkManager : MonoBehaviour { public GameObject treePrefab; // Register prefab and connect to the server public void ClientConnect() { ClientScene.RegisterPrefab(treePrefab); NetworkClient.RegisterHandler<ConnectMessage>(OnClientConnect); NetworkClient.Connect(\"localhost\"); } void OnClientConnect(NetworkConnection conn, ConnectMessage msg) { Debug.Log(\"Connected to server: \" + conn); } } In this example, you create an empty game object to act as the Network Manager, then create and attach the MyNetworkManager script (above) to that game object. Create a prefab that has a Network Identity component attached to it, and drag that onto the treePrefab slot on the MyNetworkManager component in the Inspector. This ensures that when the server spawns the tree game object, it also creates the same kind of game object on the clients. Registering prefabs ensures that there is no stalling or loading time for creating the Asset. For the script to work, you also need to add code for the server. Add this to the MyNetworkManager script: public void ServerListen() { NetworkServer.RegisterHandler<ConnectMessage>(OnServerConnect); NetworkServer.RegisterHandler<ReadyMessage>(OnClientReady); // start listening, and allow up to 4 connections NetworkServer.Listen(4); } // When client is ready spawn a few trees void OnClientReady(NetworkConnection conn, ReadyMessage msg) { Debug.Log(\"Client is ready to start: \" + conn); NetworkServer.SetClientReady(conn); SpawnTrees(); } void SpawnTrees() { int x = 0; for (int i = 0; i < 5; ++i) { GameObject treeGo = Instantiate(treePrefab, new Vector3(x++, 0, 0), Quaternion.identity); NetworkServer.Spawn(treeGo); } } void OnServerConnect(NetworkConnection conn, ConnectMessage msg) { Debug.Log(\"New client connected: \" + conn); } The server does not need to register anything, as it knows what game object is being spawned (and the asset ID is sent in the spawn message). The client needs to be able to look up the game object, so it must be registered on the client. When writing your own network manager, its important to make the client ready to receive state updates before calling the spawn command on the server, otherwise they wont be sent. If youre using Mirages built-in Network Manager component, this happens automatically. For more advanced uses, such as object pools or dynamically created Assets, you can use the ClientScene.RegisterSpawnHandler method, which allows callback functions to be registered for client-side spawning. See documentation on Custom Spawn Functions for an example of this. If the game object has a network state like synchronized variables, then that state is synchronized with the spawn message. In the following example, this script is attached to the tree Prefab: using UnityEngine; using Mirage; class Tree : NetworkBehaviour { [SyncVar] public int numLeaves; public override void OnStartClient() { Debug.Log(\"Tree spawned with leaf count \" + numLeaves); } } With this script attached, you can change the numLeaves variable and modify the SpawnTrees function to see it accurately reflected on the client: void SpawnTrees() { int x = 0; for (int i = 0; i < 5; ++i) { GameObject treeGo = Instantiate(treePrefab, new Vector3(x++, 0, 0), Quaternion.identity); Tree tree = treeGo.GetComponent<Tree>(); tree.numLeaves = Random.Range(10,200); Debug.Log(\"Spawning leaf with leaf count \" + tree.numLeaves); NetworkServer.Spawn(treeGo); } } Attach the Tree script to the treePrefab script created earlier to see this in action. Constraints A NetworkIdentity must be on the root game object of a spawnable Prefab. Without this, the Network Manager cant register the Prefab. NetworkBehaviour scripts must be on the same game object as the NetworkIdentity, not on child game objects Game Object Creation Flow The actual flow of internal operations that takes place for spawning game objects is: Prefab with Network Identity component is registered as spawnable. game object is instantiated from the Prefab on the server. Game code sets initial values on the instance (note that 3D physics forces applied here do not take effect immediately). NetworkServer.Spawn is called with the instance. The state of the SyncVars on the instance on the server are collected by calling OnSerialize on [Network Behaviour] components. A network message of type ObjectSpawn is sent to connected clients that includes the SyncVar data. OnStartServer is called on the instance on the server, and isServer is set to true Clients receive the ObjectSpawn message and create a new instance from the registered Prefab. The SyncVar data is applied to the new instance on the client by calling OnDeserialize on Network Behaviour components. OnStartClient is called on the instance on each client, and isClient is set to true As game play progresses, changes to SyncVar values are automatically synchronized to clients. This continues until game ends. NetworkServer.Destroy is called on the instance on the server. A network message of type ObjectDestroy is sent to clients. OnNetworkDestroy is called on the instance on clients, then the instance is destroyed. Player Game Objects Player game objects in the HLAPI work slightly differently to non-player game objects. The flow for spawning player game objects with the Network Manager is: Prefab with NetworkIdentity is registered as the PlayerPrefab Client connects to the server Client calls AddPlayer , network message of type MsgType.AddPlayer is sent to the server Server receives message and calls NetworkManager.OnServerAddPlayer game object is instantiated from the Player Prefab on the server NetworkManager.AddPlayerForConnection is called with the new player instance on the server The player instance is spawned - you do not have to call NetworkServer.Spawn for the player instance. The spawn message is sent to all clients like on a normal spawn. A network message of type Owner is sent to the client that added the player (only that client!) The original client receives the network message OnStartLocalPlayer is called on the player instance on the original client, and isLocalPlayer is set to true Note that OnStartLocalPlayer is called after OnStartClient , because it only happens when the ownership message arrives from the server after the player game object is spawned, so isLocalPlayer is not set in OnStartClient . Because OnStartLocalPlayer is only called for the clients local player game object, it is a good place to perform initialization that should only be done for the local player. This could include enabling input processing, and enabling camera tracking for the player game object. Spawning Game Objects with Client Authority To spawn game objects and assign authority of those game objects to a particular client, use NetworkServer.Spawn , which takes as an argument the NetworkConnection of the client that is to be made the authority. For these game objects, the property hasAuthority is true on the client with authority, and OnStartAuthority is called on the client with authority. That client can issue Server RPCs for that game object. On other clients (and on the host), hasAuthority is false. Objects spawned with client authority must have LocalPlayerAuthority set in their NetworkIdentity . For example, the tree spawn example above can be modified to allow the tree to have client authority like this (note that we now need to pass in a NetworkConnection game object for the owning clients connection): void SpawnTrees(NetworkConnection conn) { int x = 0; for (int i = 0; i < 5; ++i) { GameObject treeGo = Instantiate(treePrefab, new Vector3(x++, 0, 0), Quaternion.identity); Tree tree = treeGo.GetComponent<Tree>(); tree.numLeaves = Random.Range(10,200); Debug.Log(\"Spawning leaf with leaf count \" + tree.numLeaves); NetworkServer.Spawn(treeGo, conn); } } The Tree script can now be modified to send a Server RPC Call to the server: public override void OnStartAuthority() { CmdMessageFromTree(\"Tree with \" + numLeaves + \" reporting in\"); } [ServerRpc] void CmdMessageFromTree(string msg) { Debug.Log(\"Client sent a tree message: \" + msg); } Note that you cant just add the CmdMessageFromTree call into OnStartClient , because at that point the authority has not been set yet, so the call would fail."
  },
  "Articles/Guides/GameObjects/SpawnObjectCustom.html": {
    "href": "Articles/Guides/GameObjects/SpawnObjectCustom.html",
    "title": "Custom Spawn Functions",
    "keywords": "Custom Spawn Functions You can use spawn handler functions to customize the default behavior when creating spawned game objects on the client. Spawn handler functions ensure you have full control of how you spawn the game object, as well as how you destroy it. Use ClientScene.RegisterSpawnHandler or ClientScene.RegisterPrefab to register functions to spawn and destroy client game objects. The server creates game objects directly, and then spawns them on the clients through this functionality. This functions takes either the asset ID or a prefab and two function delegates: one to handle creating game objects on the client, and one to handle destroying game objects on the client. The asset ID can be a dynamic one, or just the asset ID found on the prefab game object you want to spawn. The spawn / unspawn delegates will look something like this: Spawn Handler GameObject SpawnDelegate(Vector3 position, System.Guid assetId) { // do stuff here } or GameObject SpawnDelegate(SpawnMessage msg) { // do stuff here } UnSpawn Handler void UnSpawnDelegate(GameObject spawned) { // do stuff here } When a prefab is saved its assetId field will be automatically set. If you want to create prefabs at runtime you will have to generate a new GUID. Generate prefab at runtime // generate a new unique assetId System.Guid creatureAssetId = System.Guid.NewGuid(); // register handlers for the new assetId ClientScene.RegisterSpawnHandler(creatureAssetId, SpawnCreature, UnSpawnCreature); Use existing prefab // register prefab you'd like to custom spawn and pass in handlers ClientScene.RegisterPrefab(coinAssetId, SpawnCoin, UnSpawnCoin); Spawn on Server // spawn a coin - SpawnCoin is called on client NetworkServer.Spawn(gameObject, coinAssetId); The spawn functions themselves are implemented with the delegate signature. Here is the coin spawner. The SpawnCreature would look the same, but have different spawn logic: public GameObject SpawnCoin(SpawnMessage msg) { return Instantiate(m_CoinPrefab, msg.position, msg.rotation); } public void UnSpawnCoin(GameObject spawned) { Destroy(spawned); } When using custom spawn functions, it is sometimes useful to be able to unspawn game objects without destroying them. This can be done by calling NetworkServer.UnSpawn . This causes the object to be Reset on the server and sends a ObjectDestroyMessage to clients. The ObjectDestroyMessage will cause the custom unspawn function to be called on the clients. If there is no unspawn function the object will instead be Destroy Note that on the host, game objects are not spawned for the local client, because they already exist on the server. This also means that no spawn or unspawn handler functions are called. Setting Up a Game Object Pool with Custom Spawn Handlers Here is an example of how you might set up a simple game object pooling system with custom spawn handlers. Spawning and unspawning then puts game objects in or out of the pool. using System.Collections.Generic; using Mirage; using UnityEngine; namespace Mirage.Examples { public class PrefabPoolManager : MonoBehaviour { [Header(\"Settings\")] public int startSize = 5; public int maxSize = 20; public GameObject prefab; [Header(\"Debug\")] [SerializeField] Queue<GameObject> pool; [SerializeField] int currentCount; void Start() { InitializePool(); ClientScene.RegisterPrefab(prefab, SpawnHandler, UnspawnHandler); } void OnDestroy() { ClientScene.UnregisterPrefab(prefab); } private void InitializePool() { pool = new Queue<GameObject>(); for (int i = 0; i < startSize; i++) { GameObject next = CreateNew(); pool.Enqueue(next); } } GameObject CreateNew() { if (currentCount > maxSize) { Debug.LogError($\"Pool has reached max size of {maxSize}\"); return null; } // use this object as parent so that objects dont crowd hierarchy GameObject next = Instantiate(prefab, transform); next.name = $\"{prefab.name}_pooled_{currentCount}\"; next.SetActive(false); currentCount++; return next; } // used by ClientScene.RegisterPrefab GameObject SpawnHandler(SpawnMessage msg) { return GetFromPool(msg.position, msg.rotation); } // used by ClientScene.RegisterPrefab void UnspawnHandler(GameObject spawned) { PutBackInPool(spawned); } /// <summary> /// Used to take Object from Pool. /// <para>Should be used on server to get the next Object</para> /// <para>Used on client by ClientScene to spawn objects</para> /// </summary> /// <param name=\"position\"></param> /// <param name=\"rotation\"></param> /// <returns></returns> public GameObject GetFromPool(Vector3 position, Quaternion rotation) { GameObject next = pool.Count > 0 ? pool.Dequeue() // take from pool : CreateNew(); // create new because pool is empty // CreateNew might return null if max size is reached if (next == null) { return null; } // set position/rotation and set active next.transform.position = position; next.transform.rotation = rotation; next.SetActive(true); return next; } /// <summary> /// Used to put object back into pool so they can b /// <para>Should be used on server after unspawning an object</para> /// <para>Used on client by ClientScene to unspawn objects</para> /// </summary> /// <param name=\"spawned\"></param> public void PutBackInPool(GameObject spawned) { // disable object spawned.SetActive(false); // add back to pool pool.Enqueue(spawned); } } } To use this manager, create a new empty game object and add the PrefabPoolManager component (code above). Next, drag a prefab you want to spawn multiple times to the Prefab field, and set startSize and maxSize fields. startSize is how many will be spawned when your game starts. maxSize is the max number that can be spawned, if this number is reached then an error will be given when trying to more new objects. Finally, set up a reference to the PrefabPoolManager in the script you are using for player movement: PrefabPoolManager prefabPoolManager; void Start() { prefabPoolManager = FindObjectOfType<PrefabPoolManager>(); } Your player logic might contain something like this, which moves and fires coins: void Update() { if (!isLocalPlayer) return; // move var x = Input.GetAxis(\"Horizontal\") * 0.1f; var z = Input.GetAxis(\"Vertical\") * 0.1f; transform.Translate(x, 0, z); // shoot if (Input.GetKeyDown(KeyCode.Space)) { // Server RPC Call function is called on the client, but invoked on the server CmdFire(); } } In the fire logic on the player, make it use the game object pool: [ServerRpc] void CmdFire() { // Set up bullet on server GameObject bullet = prefabPoolManager.GetFromPool(transform.position + transform.forward, Quaternion.identity); bullet.GetComponent<Rigidbody>().velocity = transform.forward * 4; // tell server to send SpawnMessage, which will call SpawnHandler on client NetworkServer.Spawn(bullet); // destroy bullet after 2 seconds StartCoroutine(Destroy(bullet, 2.0f)); } public IEnumerator Destroy(GameObject go, float delay) { yield return new WaitForSeconds(delay); // return object to pool on server prefabPoolManager.PutBackInPool(go); // tell server to send ObjectDestroyMessage, which will call UnspawnHandler on client NetworkServer.UnSpawn(go); } The Destroy method above shows how to return game objects to the pool so that they can be re-used when you fire again"
  },
  "Articles/Guides/GameObjects/SpawnPlayer.html": {
    "href": "Articles/Guides/GameObjects/SpawnPlayer.html",
    "title": "Player Game Objects",
    "keywords": "Player Game Objects Mirages multiplayer HLAPI system handles player game objects differently to non-player game objects. When a new player joins the game (when a new client connects to the server), that players game object becomes a local player game object on the client of that player, and Unity associates the players connection with the players game object. Unity associates one player game object for each person playing the game, and routes networking Server RPC Calls to that individual game object. A player cannot invoke a Server RPC Call on another players game object, only their own. The NetworkBehaviour class (which you derive from to create your network scripts) has a property called IsLocalPlayer . On each clients player game object, Mirage sets that property to true on the NetworkBehaviour script, and invokes the OnStartLocalPlayer callback on the object's NetworkIdentity . This means each client has a different game object set up like this, because on each client a different game object is the one that represents the local player. The diagram below shows two clients and their local players. Only the player game object that is yours (from your point of view as the player) has the IsLocalPlayer flag set. Usually you should set this flag in script to determine whether to process input, whether to make the camera track the game object, or do any other client-side things that should only occur for the player belonging to that client. Player game objects represent the player (that is, the person playing the game) on the server, and have the ability to run Server RPC Calls from the players client. These Server RPC Calls are secure client-to-server remote procedure calls. In this server-authoritative system, other non-player server-side game objects cannot receive Server RPC Calls directly from client-side game objects. This is both for security, and to reduce the complexity of building your game. By routing all incoming Server RPC Calls from users through the player game object, you can ensure that these messages come from the right place, the right client, and can be handled in a central location. The PlyerSpawner component adds a player every time a client connects to the server. In some situations though, you might want it not to add players until an input event happens - such as a user pressing a start button on the controller. To disable automatic player creation, you may want to write your own PlayerSpawner component and wait for the AddPlayerMessage message to be sent from the client."
  },
  "Articles/Guides/GameObjects/SpawnPlayerCustom.html": {
    "href": "Articles/Guides/GameObjects/SpawnPlayerCustom.html",
    "title": "Custom Character Spawning",
    "keywords": "Custom Character Spawning Mirage comes with a PlayerSpawner which will automatically spawn a player object when a client connects. Many games need character customization. You may want to pick the color of the hair, eyes, skin, height, race, etc. In this case, you will need to create your own PlayerSpawner. Follow these steps: Create your player prefabs (as many as you need) and add them to the Spawnable Prefabs in your NetworkClient. Create a message that describes your player. For example: public struct CreateMMOCharacterMessage { public Race race; public string name; public Color hairColor; public Color eyeColor; } public enum Race { None, Elvish, Dwarvish, Human } Create Player Spawner class and add it to some GameObject in your scene public class PlayerSpawner : MonoBehaviour { public NetworkSceneManager SceneManager; public NetworkClient Client; public NetworkServer Server; } Drag the NetworkClient and NetworkServer and Scene manager to the fields Hook into events: public virtual void Start() { Client.Authenticated.AddListener(OnClientAuthenticated); Server.Authenticated.AddListener(OnServerAuthenticated); } ``` 6) Send your message with your character data when your client connects, or after the user submits his preferences. ``` cs // you can send the message here if you already know // everything about the character at the time of connection // or at a later time when the user submits his preferences private void OnClientAuthenticated(INetworkConnection connection) { sceneManager.SetClientReady(); var mmoCharacter = new CreateMMOCharacterMessage { // populare the message with your data } connection.Send(mmoCharacter) } Receive your message in the server and spawn the player private void OnServerAuthenticated(INetworkConnection connection) { // wait for client to send us an AddPlayerMessage connection.RegisterHandler<CreateMMOCharacterMessage>(OnCreateCharacter); } void OnCreateCharacter(INetworkConnection conn, CreateMMOCharacterMessage msg) { // create your player object // use the data in msg to configure it GameObject playerObject = ...; // spawn it as the player object server.AddPlayerForConnection(conn, playerObject); } Ready State In addition to players, client connections also have a ready state. The host sends clients that are ready information about spawned game objects and state synchronization updates; clients which are not ready are not sent these updates. When a client initially connects to a server, it is not ready. While in this non-ready state, the client can do things that dont require real-time interactions with the game state on the server, such as loading Scenes, allowing the player to choose an avatar, or fill in log-in boxes. Once a client has completed all its pre-game work, and all its Assets are loaded, it can call ClientScene.Ready to enter the ready state. The simple example above demonstrates implementation of ready states; because adding a player with NetworkServer.AddPlayerForConnection also puts the client into the ready state if it is not already in that state. Clients can send and receive network messages without being ready, which also means they can do so without having an active player game object. So a client at a menu or selection screen can connect to the game and interact with it, even though they have no player game object. See documentation on Network Messages for more details about sending messages without using RPC calls. Note the ready state may be going away in the future. Switching Players To replace the player game object for a connection, use NetworkServer.ReplacePlayerForConnection . This is useful for restricting the Server RPC Calls that players can issue at certain times, such as in a pregame room screen. This function takes the same arguments as AddPlayerForConnection , but allows there to already be a player for that connection. The old player game object does not have to be destroyed. The NetworkRoomManager uses this technique to switch from the NetworkRoomPlayer game object to a game play player game object when all the players in the room are ready. You can also use ReplacePlayerForConnection to respawn a player or change the object that represents the player. In some cases it is better to just disable a game object and reset its game attributes on respawn. The following code sample demonstrates how to actually replace the player game object with a new game object: public class MyNetworkManager : MonoBehaviour { public NetworkServer Server; public void ReplacePlayer(NetworkConnection conn, GameObject newPrefab) { // Cache a reference to the current player object GameObject oldPlayer = conn.identity.gameObject; // Instantiate the new player object and broadcast to clients kServer.ReplacePlayerForConnection(conn, Instantiate(newPrefab)); // Remove the previous player object that's now been replaced Server.Destroy(oldPlayer); } } If the player game object for a connection is destroyed, then that client cannot execute ServerRpc's. They can, however, still send network messages. To use ReplacePlayerForConnection you must have the NetworkConnection game object for the players client to establish the relationship between the game object and the client. This is usually the property connectionToClient on the NetworkBehaviour class, but if the old player has already been destroyed, then that might not be readily available. To find the connection, there are some lists available. If using the NetworkRoomManager , then the room players are available in roomSlots . The NetworkServer also has lists of connections ."
  },
  "Articles/Guides/IDs.html": {
    "href": "Articles/Guides/IDs.html",
    "title": "Got ID?",
    "keywords": "Got ID? Asset Id Mirage uses GUID for Asset Ids. Every prefab with a NetworkIdentity component has an Asset Id, which is simply Unity's AssetDatabase.AssetPathToGUID converted to 16 bytes. Mirage needs that to know which prefabs to spawn. Scene Id Mirage uses uint for Scene Ids. Every game object with a NetworkIdentity in the scene (hierarchy) is assigned a scene id in OnPostProcessScene. Mirage needs that to distinguish scene objects from each other, because Unity has no unique id for different game objects in the scene. Network Instance Id (a.k.a. NetId) Mirage uses uint for NetId. Every NetworkIdentity is assigned a NetId in NetworkIdentity.OnStartServer, or after spawning it. Mirage uses the id when passing messages between client and server to tell which object is the recipient of the message. Connection Id Every network connection has a connection id, which is assigned by the low level Transport layer. Connection id 0 is reserved for the local connection when the server is also a client (host)"
  },
  "Articles/Guides/index.html": {
    "href": "Articles/Guides/index.html",
    "title": "Networking Concepts Overview",
    "keywords": "Networking Concepts Overview High level scripting API Mirages networking has a high-level scripting API (which well refer to as the HLAPI). Using this means you get access to commands which cover most of the common requirements for multiuser games without needing to worry about the lower level implementation details. The HLAPI allows you to: Control the networked state of the game using a Network Manager. Operate client hosted games, where the host is also a player client. Serialize data using a general-purpose serializer. Send and receive network messages. Send networked commands from clients to servers. Make remote procedure calls (RPCs) from servers to clients. Send networked events from servers to clients. Engine and Editor integration Mirages networking is integrated into the engine and the editor, allowing you to work with components and visual aids to build your multiplayer game. It provides: A NetworkIdentity component for networked objects. A NetworkBehaviour for networked scripts. Configurable automatic synchronization of object transforms. Automatic synchronization of script variables. Support for placing networked objects in Unity scenes. Network components"
  },
  "Articles/Guides/Profiler.html": {
    "href": "Articles/Guides/Profiler.html",
    "title": "Mirage Network Profiler",
    "keywords": "Mirage Network Profiler The Mirage Profiler is part of the Mirage Pro suit. As of this writing it is accessible to our GitHub Sponsors . Installation Make sure you have the latest version of Mirage. Become a GitHub Sponsor if you haven't. Visit with the Mirage Networking Discord. In the information channel you will learn how to join the github_sponsors channel. In the github_sponsors channel, pinned messages will guide you on how to download the profiler. Install the unity package in your project. Usage In Unity menu, click on Open Window -> Analysis -> Mirage Network Profiler. The profiler view will appear You may dock the profiler anywhere you want Start your game in the editor Press \"Record\" in the profiler Begin your game as host, client or server At the top a chart will show messages coming in and out Click the chart to select a frame The profiler will display information about all the messages sent and received in that frame Currently the messages display the following fields: In/Out: Whether the message was received (in) or sent (out) Name: Short name of the message, if the message was a [Command] , [ClientRpc] , [TargetRpc] or [TargetEvent] , this will display the name of the method, otherwise it will display the name of the message class. Bytes: The size of the message in bytes Count: In the case of out messages, this will contain how many clients the message was sent to. Total Bytes: the size of the message multiplied by the amount of clients the message was sent to (Bytes * Count) Channel: The channel used to send the message. As of this writing, we cannot determine the channel for inbound messages, so it displays -1. This will be improved in future versions. Transports can use channels for many purposes such as reliable, unreliable, encrypted, compressed, etc. Optimizing bandwidth On most transports, the total bandwidth is dominated by the Count column. This is because each message is packaged in a TCP or UDP frame, which have large headers. If you are sending multiple [Command] in the same frame, consider consolidating them into a single [Command] call if it makes sense If you see a large Count number on a specific message, consider adding a NetworkProximityChecker to your object, so that it is only visible to nearby players instead of the entire world. This can dramatically reduce the Count (and total bytes) depending on your game. If you are sending a message every single frame, consider changing your logic so that you only send messages when things change, or use a timer. Consider using SyncToOwner feature so that only the owner gets a message when private information such as inventory changes. This can dramatically reduce the Count depending on your game. If you have a lot of [ClientRpc] calls that synchronize data, consider using [SyncVar] and synclists instead. They can reduce the amount of messages because they only send deltas when they change, plus they get batched together, so hundreds of variables can be synchronized with a single message."
  },
  "Articles/Guides/Resources.html": {
    "href": "Articles/Guides/Resources.html",
    "title": "Resources",
    "keywords": "Resources work in progress Video Tutorials Playlists Unity - Mirage Networking by First Gear Games Mirage Multiplayer by Dapper Dino Object Pooling Simple object pooling script Advanced object pooling scripts"
  },
  "Articles/Guides/Serialization.html": {
    "href": "Articles/Guides/Serialization.html",
    "title": "Serialization",
    "keywords": "Serialization This page goes into depth about Serialization, for the basics see DataTypes . Mirage creates Serialize and Deserialize functions for types using Weaver. Weaver edits dll after unity compiles them using Mono.Cecil. This allows mirror to have a lot of complex features like SyncVar, ClientRpc and Message Serialization without the user needed to manually set everything up. Rules and tips There are some rules and limits for what Weaver can do. Some features add complexity and are hard to maintain so have not been implemented. These features are not impossible to implement and could be added if there is a high demand for them. You should be able to write Custom Read/Write functions for any type, and Weaver will use. This means if there is a unsupported type like int[][] creating a custom Read/Write function will allow you to sync int[][] in SyncVar/ClientRpc/etc If you have a type that has a field that is not able to be Serialize, you can mark that field with [System.NonSerialized] and weaver will ignore it Unsupported Types Some of these types are unsupported due to the complexity they would add, as mentioned above. NOTE: Types in this list can have custom writers. Jagged and Multidimensional array Types that Inherit from UnityEngine.Component UnityEngine.Object UnityEngine.ScriptableObject Generic Types, eg MyData<T> Custom Read/Write must declare T, eg MyData<int> Interfaces Types that references themselves Built-in Read Write Functions Mirage provides some built-in Read/Write Functions. They can be found in NetworkReaderExtensions and NetworkWriterExtensions . This is a Non-compete list of types that have built-in functions, check the classes above to see the full list. Most c# primitive types Common Unity structs Vector3 Quaternion Rect Ray Guid NetworkIdentity, GameObject, Transform NetworkIdentity, GameObject, Transform The netId of the Object is sent over the network, and the Object with the same netId is returned on the other side. If the netId is zero or an object is not found then null will be returned. Generated Read Write Functions Weaver will Generate Read Write functions for Classes or Structs Enums Arrays eg int[] ArraySegments eg ArraySegment<int> Lists eg List<int> Classes and Structs Weaver will Read/Write every public field in the type, unless the field is marked with [System.NonSerialized] . If there is an unsupported type in the class or struct Weaver will fail to make Read/Write functions for it. NOTE: Weaver does not check properties Enums Weaver will use the underlying Type of an enum to Read and Write them. By default this is int . For example Switch will use the byte Read/Write functions to be Serialized public enum Switch : byte { Left, Middle, Right, } Collections Weaver will Generate writes for the collections listed above. Weaver will use the elements Read/Write function. The element must have a Read/Write function so must be a supported type, or have a custom Read/Write function. For example: float[] is a supported type because Mirage has a built-in Read/Write function for float . MyData[] is a supported type as Weaver is able to generate a Read/Write function for MyData public struct MyData { public int someValue; public float anotherValue; } Adding Custom Read Write functions Read Write functions are static methods in the form of: public static void WriteMyType(this NetworkWriter writer, MyType value) { // write MyType data here } public static MyType ReadMyType(this NetworkReader reader) { // read MyType data here } It is best practice to make Read/Write functions extension methods so they can be called like writer.WriteMyType(value) . It is a good idea to call them ReadMyType and WriteMyType so it is obvious what type they are for. However the name of the function doesn't matter, weaver should be able to find it no matter what it is called. Properties Example Weaver wont write properties, but a custom writer can be used to send them over the network. This can be useful if you want to have private set for your properties public struct MyData { public int someValue { get; private set; } public float anotherValue { get; private set; } public MyData(int someValue, float anotherValue) { this.someValue = someValue; this.anotherValue = anotherValue; } } public static class CustomReadWriteFunctions { public static void WriteMyType(this NetworkWriter writer, MyData value) { writer.WriteInt32(value.someValue); writer.WriteSingle(value.anotherValue); } public static MyData ReadMyType(this NetworkReader reader) { return new MyData(reader.ReadInt32(), reader.ReadSingle()); } } Unsupported type Example Rigidbody is an unsupported type because it inherits from Component . But a custom writer can be added so that it is synced using a NetworkIdentity if one is attached. public struct MyCollision { public Vector3 force; public Rigidbody rigidbody; } public static class CustomReadWriteFunctions { public static void WriteMyCollision(this NetworkWriter writer, MyCollision value) { writer.WriteVector3(value.force); NetworkIdentity networkIdentity = value.rigidbody.GetComponent<NetworkIdentity>(); writer.WriteNetworkIdentity(networkIdentity); } public static MyCollision ReadMyCollision(this NetworkReader reader) { Vector3 force = reader.ReadVector3(); NetworkIdentity networkIdentity = reader.ReadNetworkIdentity(); Rigidbody rigidBody = networkIdentity != null ? networkIdentity.GetComponent<Rigidbody>() : null; return new MyCollision { force = force, rigidbody = rigidBody, }; } } Above are functions for MyCollision , but instead you could add functions for Rigidbody and let weaver would generate a writer for MyCollision . public static class CustomReadWriteFunctions { public static void WriteRigidbody(this NetworkWriter writer, Rigidbody rigidbody) { NetworkIdentity networkIdentity = rigidbody.GetComponent<NetworkIdentity>(); writer.WriteNetworkIdentity(networkIdentity); } public static Rigidbody ReadRigidbody(this NetworkReader reader) { NetworkIdentity networkIdentity = reader.ReadNetworkIdentity(); Rigidbody rigidBody = networkIdentity != null ? networkIdentity.GetComponent<Rigidbody>() : null; return rigidBody; } } Debugging You can use tools like dnSpy to view the complied code after Weaver has altered it. This can help to understand and debug what Mirage and Weaver does."
  },
  "Articles/Guides/Sync/index.html": {
    "href": "Articles/Guides/Sync/index.html",
    "title": "State Synchronization",
    "keywords": "State Synchronization State synchronization refers to the synchronization of values such as integers, floating point numbers, strings and boolean values belonging to scripts. State synchronization is done from the Server to remote clients. The local client does not have data serialized to it. It does not need it, because it shares the Scene with the server. However, SyncVar hooks are called on local clients. Data is not synchronized in the opposite direction - from remote clients to the server. To do this, you need to use Server RPC calls. SyncVars SyncVars are variables of scripts that inherit from NetworkBehaviour , which are synchronized from the server to clients. SyncLists SyncLists contain lists of values and synchronize data from servers to clients. SyncDictionary A SyncDictionary is an associative array containing an unordered list of key, value pairs. SyncHashSet An unordered set of values that do not repeat. SyncSortedSet A sorted set of values that do not repeat. Sync To Owner It is often the case when you don't want some player data visible to other players. In the inspector change the \"Network Sync Mode\" from \"Observers\" (default) to \"Owner\" to let Mirage know to synchronize the data only with the owning client. For example, suppose you are making an inventory system. Suppose player A,B and C are in the same area. There will be a total of 12 objects in the entire network: Client A has Player A (himself), Player B and Player C Client B has Player A , Player B (himself) and Player C Client C has Player A , Player B and Player C (himself) Server has Player A, Player B, Player C each one of them would have an Inventory component Suppose Player A picks up some loot. The server adds the loot to Player's A inventory, which would have a SyncLists of Items. By default, Mirage now has to synchronize player A's inventory everywhere, that means sending an update message to client A, client B and client C, because they all have a copy of Player A. This is wasteful, Client B and Client C do not need to know about Player's A inventory, they never see it on screen. It is also a security problem, someone could hack the client and display other people's inventory and use it to their advantage. If you set the \"Network Sync Mode\" in the Inventory component to \"Owner\", then Player A's inventory will only be synchronized with Client A. Now, suppose instead of 3 people you have 50 people in an area and one of them picks up loot. It means that instead of sending 50 messages to 50 different clients, you would only send 1. This can have a big impact in bandwith in your game. Other typical use cases include quests, player's hand in a card game, skills, experience, or any other data you don't need to share with other players. Advanced State Synchronization In most cases, the use of SyncVars is enough for your game scripts to serialize their state to clients. However in some cases you might require more complex serialization code. This page is only relevant for advanced developers who need customized synchronization solutions that go beyond Mirages normal SyncVar feature. Custom Serialization Functions To perform your own custom serialization, you can implement virtual functions on NetworkBehaviour to be used for SyncVar serialization. These functions are: public virtual bool OnSerialize(NetworkWriter writer, bool initialState); public virtual void OnDeserialize(NetworkReader reader, bool initialState); Use the initialState flag to differentiate between the first time a game object is serialized and when incremental updates can be sent. The first time a game object is sent to a client, it must include a full state snapshot, but subsequent updates can save on bandwidth by including only incremental changes. The OnSerialize function should return true to indicate that an update should be sent. If it returns true, the dirty bits for that script are set to zero. If it returns false, the dirty bits are not changed. This allows multiple changes to a script to be accumulated over time and sent when the system is ready, instead of every frame. The OnSerialize function is only called for initialState or when the NetworkBehaviour is dirty. A NetworkBehaviour will only be dirty if a SyncVar or SyncObject (e.g. SyncList ) has changed since the last OnSerialize call. After data has been sent the NetworkBehaviour will not be dirty again until the next syncInterval (set in the inspector). A NetworkBehaviour can also be marked as dirty by manually calling SetDirtyBit (this does not bypass the syncInterval limit). Although this works, it is usually better to let Mirage generate these methods and provide custom serializers for your specific field. Serialization Flow Game objects with the Network Identity component attached can have multiple scripts derived from NetworkBehaviour . The flow for serializing these game objects is: On the server: Each NetworkBehaviour has a dirty mask. This mask is available inside OnSerialize as syncVarDirtyBits Each SyncVar in a NetworkBehaviour script is assigned a bit in the dirty mask. Changing the value of SyncVars causes the bit for that SyncVar to be set in the dirty mask Alternatively, calling SetDirtyBit writes directly to the dirty mask NetworkIdentity game objects are checked on the server as part of its update loop If any NetworkBehaviour s on a NetworkIdentity are dirty, then an UpdateVars packet is created for that game object The UpdateVars packet is populated by calling OnSerialize on each NetworkBehaviour on the game object NetworkBehaviour s that are not dirty write a zero to the packet for their dirty bits NetworkBehaviour s that are dirty write their dirty mask, then the values for the SyncVars that have changed If OnSerialize returns true for a NetworkBehaviour , the dirty mask is reset for that NetworkBehaviour so it does not send again until its value changes. The UpdateVars packet is sent to ready clients that are observing the game object On the client: an UpdateVars packet is received for a game object The OnDeserialize function is called for each NetworkBehaviour script on the game object Each NetworkBehaviour script on the game object reads a dirty mask. If the dirty mask for a NetworkBehaviour is zero, the OnDeserialize function returns without reading any more If the dirty mask is non-zero value, then the OnDeserialize function reads the values for the SyncVars that correspond to the dirty bits that are set If there are SyncVar hook functions, those are invoked with the value read from the stream. So for this script: using Mirror; public class Data : NetworkBehaviour { [SyncVar(hook = nameof(OnInt1Changed))] public int int1 = 66; [SyncVar] public int int2 = 23487; [SyncVar] public string MyString = \"Example string\"; void OnInt1Changed(int oldValue, int newValue) { // do something here } } The following sample shows the code that is generated by Mirage for the SerializeSyncVars function which is called inside NetworkBehaviour .OnSerialize : public override bool SerializeSyncVars(NetworkWriter writer, bool initialState) { // Write any SyncVars in base class bool written = base.SerializeSyncVars(writer, forceAll); if (initialState) { // The first time a game object is sent to a client, send all the data (and no dirty bits) writer.WritePackedUInt32((uint)this.int1); writer.WritePackedUInt32((uint)this.int2); writer.Write(this.MyString); return true; } else { // Writes which SyncVars have changed writer.WritePackedUInt64(base.syncVarDirtyBits); if ((base.get_syncVarDirtyBits() & 1u) != 0u) { writer.WritePackedUInt32((uint)this.int1); written = true; } if ((base.get_syncVarDirtyBits() & 2u) != 0u) { writer.WritePackedUInt32((uint)this.int2); written = true; } if ((base.get_syncVarDirtyBits() & 4u) != 0u) { writer.Write(this.MyString); written = true; } return written; } } The following sample shows the code that is generated by Mirage for the DeserializeSyncVars function which is called inside NetworkBehaviour .OnDeserialize : public override void DeserializeSyncVars(NetworkReader reader, bool initialState) { // Read any SyncVars in base class base.DeserializeSyncVars(reader, initialState); if (initialState) { // The first time a game object is sent to a client, read all the data (and no dirty bits) int oldInt1 = this.int1; this.int1 = (int)reader.ReadPackedUInt32(); // if old and new values are not equal, call hook if (!base.SyncVarEqual<int>(num, ref this.int1)) { this.OnInt1Changed(num, this.int1); } this.int2 = (int)reader.ReadPackedUInt32(); this.MyString = reader.ReadString(); return; } int dirtySyncVars = (int)reader.ReadPackedUInt32(); // is 1st SyncVar dirty if ((dirtySyncVars & 1) != 0) { int oldInt1 = this.int1; this.int1 = (int)reader.ReadPackedUInt32(); // if old and new values are not equal, call hook if (!base.SyncVarEqual<int>(num, ref this.int1)) { this.OnInt1Changed(num, this.int1); } } // is 2nd SyncVar dirty if ((dirtySyncVars & 2) != 0) { this.int2 = (int)reader.ReadPackedUInt32(); } // is 3rd SyncVar dirty if ((dirtySyncVars & 4) != 0) { this.MyString = reader.ReadString(); } } If a NetworkBehaviour has a base class that also has serialization functions, the base class functions should also be called. Note that the UpdateVar packets created for game object state updates may be aggregated in buffers before being sent to the client, so a single transport layer packet may contain updates for multiple game objects."
  },
  "Articles/Guides/Sync/SyncDictionary.html": {
    "href": "Articles/Guides/Sync/SyncDictionary.html",
    "title": "SyncDictionary",
    "keywords": "SyncDictionary A SyncDictionary is an associative array containing an unordered list of key, value pairs. Keys and values can be of the following types: Basic type (byte, int, float, string, UInt64, etc) Built-in Unity math type (Vector3, Quaternion, etc) NetworkIdentity Game object with a NetworkIdentity component attached. Struct with any of the above SyncDictionary works much like SyncLists : when you make a change on the server the change is propagated to all clients and the Callback is called. To use it, create a class that derives from SyncDictionary for your specific type. This is necessary because the Weaver will add methods to that class. Then add a field to your NetworkBehaviour class. Note that by the time you subscribe to the callback, the dictionary will already be initialized, so you will not get a call for the initial data, only updates. Note SyncDictionaries must be initialized in the constructor, not in Startxxx(). You can make them readonly to ensure correct usage. Simple Example using UnityEngine; using Mirage; [System.Serializable] public struct Item { public string name; public int hitPoints; public int durability; } [System.Serializable] public class SyncDictionaryStringItem : SyncDictionary<string, Item> {} public class ExamplePlayer : NetworkBehaviour { [SerializeField] public readonly SyncDictionaryStringItem Equipment = new SyncDictionaryStringItem(); public override void OnStartServer() { Equipment.Add(\"head\", new Item { name = \"Helmet\", hitPoints = 10, durability = 20 }); Equipment.Add(\"body\", new Item { name = \"Epic Armor\", hitPoints = 50, durability = 50 }); Equipment.Add(\"feet\", new Item { name = \"Sneakers\", hitPoints = 3, durability = 40 }); Equipment.Add(\"hands\", new Item { name = \"Sword\", hitPoints = 30, durability = 15 }); } public override void OnStartClient() { // Equipment is already populated with anything the server set up // but we can subscribe to the callback in case it is updated later on Equipment.Callback += OnEquipmentChange; } void OnEquipmentChange(SyncDictionaryStringItem.Operation op, string key, Item item) { // equipment changed, perhaps update the gameobject Debug.Log(op + \" - \" + key); } } By default, SyncDictionary uses a Dictionary to store it's data. If you want to use a different IDictionary implementation such as SortedList or SortedDictionary , add a constructor to your SyncDictionary implementation and pass a dictionary to the base class. For example: [System.Serializable] public class SyncDictionaryStringItem : SyncDictionary<string, Item> { public SyncDictionaryStringItem() : base (new SortedList<string,Item>()) {} } public class ExamplePlayer : NetworkBehaviour { [SerializeField] public readonly SyncDictionaryStringItem Equipment = new SyncDictionaryStringItem(); }"
  },
  "Articles/Guides/Sync/SyncEvent.html": {
    "href": "Articles/Guides/Sync/SyncEvent.html",
    "title": "SyncEvent (Obsolete)",
    "keywords": "SyncEvent (Obsolete) IMPORTANT SyncEvents have been removed in version 18.0.0, see this Issue for more information This is an attribute that can be put on events in NetworkBehaviour classes to allow them to be invoked on client when the event is called on the server. SyncEvent events are called by user code on the server, and then invoked on corresponding client objects on clients connected to the server. The arguments to the Event call are serialized across the network, so that the client event is invoked with the same values as the method on the server. These events must begin with the prefix \"Event\". using UnityEngine; using Mirage; public class DamageClass : NetworkBehaviour { public delegate void TakeDamageDelegate(int amount, float dir); [SyncEvent] public event TakeDamageDelegate EventTakeDamage; [Command] public void CmdDoMe(int val) { EventTakeDamage(val, 1.0f); } } public class Other : NetworkBehaviour { public DamageClass damager; int health = 100; void Start() { if (NetworkClient.active) damager.EventTakeDamage += TakeDamage; } public void TakeDamage(int amount, float dir) { health -= amount; } } SyncEvents allow networked actions to be propagated to other scripts attached to the object. In the example above, the Other class registers for the TakeDamage event on the DamageClass. When the event happens on the DamageClass on the server, the TakeDamage() method will be invoked on the Other class on the client object. This allows modular network aware systems to be created, that can be extended by new scripts that respond to the events generated by them."
  },
  "Articles/Guides/Sync/SyncHashSet.html": {
    "href": "Articles/Guides/Sync/SyncHashSet.html",
    "title": "SyncHashSet",
    "keywords": "SyncHashSet SyncHashSet are sets similar to C# HashSet<T> that synchronize their contents from the server to the clients. A SyncHashSet can contain any supported Mirage type Usage Create a class that derives from SyncHashSet for your specific type. This is necessary because Mirage will add methods to that class with the weaver. Then add a SyncHashSet field to your NetworkBehaviour class. For example: [System.Serializable] public class SyncSkillSet : SyncHashSet<string> {} public class Player : NetworkBehaviour { [SerializeField] readonly SyncSkillSet skills = new SyncSkillSet(); int skillPoints = 10; [Command] public void CmdLearnSkill(string skillName) { if (skillPoints > 1) { skillPoints--; skills.Add(skillName); } } } You can also detect when a SyncHashSet changes. This is useful for refreshing your character in the client or determining when you need to update your database. Subscribe to the Callback event typically during Start , OnClientStart or OnServerStart for that. Note that by the time you subscribe, the set will already be initialized, so you will not get a call for the initial data, only updates. Note SyncSets must be initialized in the constructor, not in Startxxx(). You can make them readonly to ensure correct usage. [System.Serializable] public class SyncSetBuffs : SyncHashSet<string> {}; public class Player : NetworkBehaviour { [SerializeField] public readonly SyncSetBuffs buffs = new SyncSetBuffs(); // this will add the delegate on the client. // Use OnStartServer instead if you want it on the server public override void OnStartClient() { buffs.Callback += OnBuffsChanged; } void OnBuffsChanged(SyncSetBuffs.Operation op, string buff) { switch (op) { case SyncSetBuffs.Operation.OP_ADD: // we added a buff, draw an icon on the character break; case SyncSetBuffs.Operation.OP_CLEAR: // clear all buffs from the character break; case SyncSetBuffs.Operation.OP_REMOVE: // We removed a buff from the character break; } } }"
  },
  "Articles/Guides/Sync/SyncLists.html": {
    "href": "Articles/Guides/Sync/SyncLists.html",
    "title": "SyncLists",
    "keywords": "SyncLists SyncLists are array based lists similar to C# List<T> that synchronize their contents from the server to the clients. A SyncList can contain any supported Mirage type . Differences with HLAPI HLAPI also supports SyncLists, but we have redesigned them to better suit our needs. Some of the key differences include: In HLAPI, SyncLists were synchronized immediately when they changed. If you add 10 elements, that means 10 separate messages. Mirage synchronizes SyncLists with the SyncVars. The 10 elements and other SyncVars are batched together into a single message. Mirage also respects the sync interval when synchronizing lists. In HLAPI if you want a list of structs, you have to use SyncListStruct<MyStructure> , we changed it to just SyncList<MyStructure> In HLAPI the Callback is a delegate. In Mirage we changed it to an event, so that you can add many subscribers. In HLAPI the Callback tells you the operation and index. In Mirage, the callback also receives an item. We made this change so that we could tell what item was removed. Usage Create a class that derives from SyncList for your specific type. This is necessary because Mirage will add methods to that class with the weaver. Then add a SyncList field to your NetworkBehaviour class. For example: [System.Serializable] public struct Item { public string name; public int amount; public Color32 color; } [System.Serializable] public class SyncListItem : SyncList<Item> {} public class Player : NetworkBehaviour { readonly SyncListItem inventory = new SyncListItem(); public int coins = 100; [Command] public void CmdPurchase(string itemName) { if (coins > 10) { coins -= 10; Item item = new Item { name = \"Sword\", amount = 3, color = new Color32(125, 125, 125, 255) }; // during next synchronization, all clients will see the item inventory.Add(item); } } } There are some ready made SyncLists you can use: SyncListString SyncListFloat SyncListInt SyncListUInt SyncListBool You can also detect when a SyncList changes in the client or server. This is useful for refreshing your character when you add equipment or determining when you need to update your database. Subscribe to the Callback event typically during Start , OnClientStart , or OnServerStart for that. Note that by the time you subscribe, the list will already be initialized, so you will not get a call for the initial data, only updates. Note SyncLists must be initialized in the constructor, not in Startxxx(). You can make them readonly to ensure correct usage. class Player : NetworkBehaviour { readonly SyncListItem inventory = new SyncListItem(); // this will add the delegates on both server and client. // Use OnStartClient instead if you just want the client to act upon updates void Start() { inventory.Callback += OnInventoryUpdated; } void OnInventoryUpdated(SyncListItem.Operation op, int index, Item oldItem, Item newItem) { switch (op) { case SyncListItem.Operation.OP_ADD: // index is where it got added in the list // item is the new item break; case SyncListItem.Operation.OP_CLEAR: // list got cleared break; case SyncListItem.Operation.OP_INSERT: // index is where it got added in the list // item is the new item break; case SyncListItem.Operation.OP_REMOVEAT: // index is where it got removed in the list // item is the item that was removed break; case SyncListItem.Operation.OP_SET: // index is the index of the item that was updated // item is the previous item break; } } } By default, SyncList uses a List to store it's data. If you want to use a different list implementation, add a constructor and pass the list implementation to the parent constructor. For example: class SyncListItem : SyncList<Item> { public SyncListItem() : base(new MyIList<Item>()) {} }"
  },
  "Articles/Guides/Sync/SyncSortedSet.html": {
    "href": "Articles/Guides/Sync/SyncSortedSet.html",
    "title": "SyncSortedSet",
    "keywords": "SyncSortedSet SyncSortedSet are sets similar to C# SortedSet<T> that synchronize their contents from the server to the clients. Unlike SyncHashSets, all elements in a SyncSortedSet are sorted when they are inserted. Please note this has some performance implications. A SyncSortedSet can contain any supported Mirage type Usage Create a class that derives from SyncSortedSet for your specific type. This is necessary because Mirage will add methods to that class with the weaver. Then add a SyncSortedSet field to your NetworkBehaviour class. For example: class Player : NetworkBehaviour { class SyncSkillSet : SyncSortedSet<string> {} readonly SyncSkillSet skills = new SyncSkillSet(); int skillPoints = 10; [Command] public void CmdLearnSkill(string skillName) { if (skillPoints > 1) { skillPoints--; skills.Add(skillName); } } } You can also detect when a SyncSortedSet changes. This is useful for refreshing your character in the client or determining when you need to update your database. Subscribe to the Callback event typically during Start , OnClientStart or OnServerStart for that. Note that by the time you subscribe, the set will already be initialized, so you will not get a call for the initial data, only updates. Note SyncSets must be initialized in the constructor, not in Startxxx(). You can make them readonly to ensure correct usage. class Player : NetworkBehaviour { class SyncSetBuffs : SyncSortedSet<string> {}; readonly SyncSetBuffs buffs = new SyncSetBuffs(); // this will add the delegate on the client. // Use OnStartServer instead if you want it on the server public override void OnStartClient() { buffs.Callback += OnBuffsChanged; } void OnBuffsChanged(SyncSetBuffs.Operation op, string buff) { switch (op) { case SyncSetBuffs.Operation.OP_ADD: // we added a buff, draw an icon on the character break; case SyncSetBuffs.Operation.OP_CLEAR: // clear all buffs from the character break; case SyncSetBuffs.Operation.OP_REMOVE: // We removed a buff from the character break; } } }"
  },
  "Articles/Guides/Sync/SyncVarHook.html": {
    "href": "Articles/Guides/Sync/SyncVarHook.html",
    "title": "SyncVar Hook",
    "keywords": "SyncVar Hook The hook attribute can be used to specify a function to be called when the SyncVar changes value on the client. The Hook method must have two parameters of the same type as the SyncVar property. One for the old value, one for the new value. The Hook is always called after the property value is set. You don't need to set it yourself. The Hook only fires for changed values, and changing a value in the inspector will not trigger an update. As of version 11.1.4 (March 2020) and later, hooks can be virtual methods and overriden in a derived class. Below is a simple example of assigning a random color to each player when they're spawned on the server. All clients will see all players in the correct colors, even if they join later. Note: The signature for hook methods was changed in version 9.0 (Feb 2020) to having 2 parameters (old and new values). If you're on an older version, hook methods just have one parameter (new value). using UnityEngine; using Mirage; public class PlayerController : NetworkBehaviour { [SyncVar(hook = nameof(SetColor))] Color playerColor = Color.black; // Unity makes a clone of the Material every time GetComponent<Renderer>().material is used. // Cache it here and Destroy it in OnDestroy to prevent a memory leak. Material cachedMaterial; public override void OnStartServer() { base.OnStartServer(); playerColor = Random.ColorHSV(0f, 1f, 1f, 1f, 0.5f, 1f); } void SetColor(Color oldColor, Color newColor) { if (cachedMaterial == null) cachedMaterial = GetComponent<Renderer>().material; cachedMaterial.color = newColor; } void OnDestroy() { Destroy(cachedMaterial); } }"
  },
  "Articles/Guides/Sync/SyncVars.html": {
    "href": "Articles/Guides/Sync/SyncVars.html",
    "title": "SyncVars",
    "keywords": "SyncVars SyncVars are properties of classes that inherit from NetworkBehaviour, which are synchronized from the server to clients. When a game object is spawned, or a new player joins a game in progress, they are sent the latest state of all SyncVars on networked objects that are visible to them. Use the SyncVar custom attribute to specify which variables in your script you want to synchronize. The state of SyncVars is applied to game objects on clients before OnStartClient() is called, so the state of the object is always up-to-date inside OnStartClient() . SyncVars can use any type supported by Mirage . You can have up to 64 SyncVars on a single NetworkBehaviour script, including SyncLists (see next section, below). The server automatically sends SyncVar updates when the value of a SyncVar changes, so you do not need to track when they change or send information about the changes yourself. Changing a value in the inspector will not trigger an update. The SyncVar hook attribute can be used to specify a method to be called when the SyncVar changes value on the client. SyncVar Example Let's say we have a networked object with a script called Enemy: public class Enemy : NetworkBehaviour { [SyncVar] public int health = 100; void OnMouseUp() { NetworkIdentity ni = NetworkClient.connection.identity; PlayerController pc = ni.GetComponent<PlayerController>(); pc.currentTarget = gameObject; } } The PlayerController might look like this: public class PlayerController : NetworkBehaviour { public GameObject currentTarget; void Update() { if (isLocalPlayer) if (currentTarget != null) if (currentTarget.tag == \"Enemy\") if (Input.GetKeyDown(KeyCode.X)) CmdShoot(currentTarget); } [Command] public void CmdShoot(GameObject enemy) { // Do your own shot validation here because this runs on the server enemy.GetComponent<Enemy>().health -= 5; } } In this example, when a Player clicks on an Enemy, the networked enemy game object is assigned to PlayerController.currentTarget . When the player presses X, with a correct target selected, that target is passed through a Command, which runs on the server, to decrement the health SyncVar. All clients will be updated with that new value. You can then have a UI on the enemy to show the current value. Class inheritance SyncVars work with class inheritance. Consider this example: class Pet : NetworkBehaviour { [SyncVar] String name; } class Cat : Pet { [SyncVar] public Color32 color; } You can attach the Cat component to your cat prefab, and it will synchronize both it's name and color . Warning Both Cat and Pet should be in the same assembly. If they are in separate assemblies, make sure not to change name from inside Cat directly, add a method to Pet instead."
  },
  "Articles/Guides/Visibility.html": {
    "href": "Articles/Guides/Visibility.html",
    "title": "Network Visibility",
    "keywords": "Network Visibility Multiplayer games use the concept of network visibility to determine which players can see which game objects at any given time during game play. In a game that has a moving viewpoint and moving game objects, its common that players cannot see everything that is happening in the game at once. If a particular player, at a certain point in time during game play, cannot see most of the other players, non-player characters, or other moving or interactive things in your game, there is usually no need for the server to send information about those things to the players client. This can benefit your game in two ways: It reduces the amount of data sent across the network between players. This can help improve the responsiveness of your game, and reduce bandwidth use. The bigger and more complex your multiplayer game, the more important this issue is. It also helps prevent some cheating. Since a player client does not have information about things that cant be seen, a hack on that players computer cannot reveal the information. The idea of visibility in the context of networking doesnt necessarily relate to whether game objects are directly visible on-screen. Instead, it relates to whether data should or shouldnt be sent about the game object in question to a particular client. Put simply, if a client cant see an game object, it does not need to be sent information about that game object across the network. Ideally you want to limit the amount of data you are sending across the network to only what is necessary, because sending large amounts of unnecessary data across the network can cause network performance problems. However, it can be also be resource intensive or complex to determine accurately whether a game object truly visible to a given player, so its often a good idea to use a more simple calculation for the purposes of determining whether a player should be sent networked data about it - i.e. whether it is Network Visible. The balance you want to achieve when considering this is between the cost of the complexity of the calculation for determining the visibility, and the cost of sending more information than necessary over the network. A very simple way to calculate this is a distance (proximity) check, and Mirage provides a built-in component for this purpose. Network Proximity Checker Component Mirages Network Proximity Checker component is simplest way to implement network visibility for players. It works in conjunction with the physics system to determine whether game objects are close enough (that is, visible for the purposes of sending network messages in your multiplayer game). Network Scene Checker Component Mirage's Network Scene Checker component can be used to isolate players and networked objects on the server in additive scene instances. Network Visibility on Remote Clients When a player on a remote client joins a networked game, only game objects that are network-visible to the player will be spawned on that remote client. This means that even if the player enters a large world with many networked game objects, the game can start quickly because it does not need to spawn every game object that exists in the world. Note that this applies to networked game objects in your Scene, but does not affect the loading of Assets. Unity still takes time to load the Assets for registered Prefabs and Scene game objects. When a player moves within the world, the set of network-visible game objects changes. The players client is told about these changes as they happen. The ObjectHide message is sent to clients when a game object becomes no longer network-visible. By default, Mirage destroys the game object when it receives this message. When a game object becomes visible, the client receives an ObjectSpawn message, as if Mirage has spawned the game object for the first time. By default, the game object is instantiated like any other spawned game object. Network Visibility on the Host The host shares the same Scene as the server, because it acts as both the server and the client to the player hosting the game. For this reason, it cannot destroy game objects that are not visible to the local player. Instead, there is the virtual method OnSetLocalVisibility in the NetworkVisibility class that is invoked. This method is invoked on all scripts that inherit from NetworkVisibility on game objects that change visibility state on the host. The default implementation of OnSetLocalVisibility disables or enables all renderer components on the game object. If you want to customize this implementation, you can override the method in your script, and provide a new behavior for how the host (and therefore the local client) should respond when a game object becomes network-visible or invisible (such as disabling HUD elements or renderers). Customizing Network Visibility Sometimes you might want to use other kinds of visibility check, such as grid-based rules, line-of-sight tests, navigation path tests, or any other type of test that suits your game. To do this, you can create your own custom Network Observer from a script template via the Assets menu by clicking Create -> Mirage -> Network Observer. It may be helpful to understand how the Network Proximity Checker works. The Network Proximity Checker is implemented using the public visibility interface of Mirages HLAPI. Using this same interface, you can implement any kind of visibility rules you desire. Each NetworkIdentity keeps track of the set of players that it is visible to. The players that a NetworkIdentity game object is visible to are called the observers of the NetworkIdentity. The Network Proximity Checker calls the RebuildObservers method on the Network Identity component at a fixed interval (set using the Vis Update Interval value in the inspector), so that the set of network-visible game objects for each player is updated as they move around. In the NetworkVisibility class (which your custom observer scripts inherit from), there are some virtual functions for determining visibility. These are: OnCheckObserver This method is called on the server, on each networked game object when a new player enters the game. If it returns true, that player is added to the objects observers. The Network Proximity Checker does a simple distance check in its implementation of this function, and uses Physics.OverlapSphereNonAlloc to find the players that are within the visibility distance for this object. OnRebuildObservers This method is called on the server when RebuildObservers is invoked. This method expects the set of observers to be populated with the players that can see the object. The NetworkServer then handles sending ObjectHide and ObjectSpawn messages based on the differences between the old and new visibility sets. OnSetHostVisibility This method is called on the server by the visibility system for objects on a host. Objects on a host (with a local client) cannot be disabled or destroyed when they are not visibile to the local client. So this function is called to allow custom code to hide these objects. A typical implementation will disable renderer components on the object. This is only called on local clients on a host. You can check whether any given networked game object is a player by checking if its NetworkIdentity has a valid connectionToClient. For example: int hitCount = Physics.OverlapSphereNonAlloc(transform.position, visRange, hitsBuffer3D, castLayers); for (int i = 0; i < hitCount; i++) { Collider hit = hitsBuffer3D[i]; NetworkIdentity identity = hit.GetComponent<NetworkIdentity>(); if (identity != null && identity.connectionToClient != null) observers.Add(identity.connectionToClient); }"
  },
  "Articles/Transports/FizzyFacepunch.html": {
    "href": "Articles/Transports/FizzyFacepunch.html",
    "title": "FizzyFacepunch Transport",
    "keywords": "FizzyFacepunch Transport FizzyFacepunch is a Steam P2P transport for Mirage, it utilizes Steam's P2P service to directly connect or relay your connection to another player. FizzyFacepunch is based on the Facepunch.Steamworks wrapper. You can get the release Here or you can clone the repo Here . Features Multiple Customizable Channels : You can customize the channels in the transport, whether you want just 1 or 5 channels that are unreliable or reliable (best to leave channel 0 as reliable). Steam Nat Punching & Relay : The transport will use Steam to do Nat Punching to your destination, and if that doesn't work, steam's relay Server will be used to ensure you can always connect (latency may vary). No Code Changes Needed : If you Already use Mirage, you just need to slap this transport in (maybe add your steam App ID in your build), and everything should work the same like any other Mirage Transport. \"It Just Works\" -Todd Howard Credits Chykary : The author of this Transport. Facepunch : Creator of Facepunch.Steamworks. vis2k : Creator of Mirror. Valve : Steam"
  },
  "Articles/Transports/FizzySteamworks.html": {
    "href": "Articles/Transports/FizzySteamworks.html",
    "title": "FizzySteamworks Transport",
    "keywords": "FizzySteamworks Transport FizzySteamworks is a Steam P2P transport for Mirage, it utilizes Steam's P2P service to directly connect or relay your connection to another player. FizzySteamworks is based on the Steamworks.Net wrapper. You can get the release Here with the latest version of Steamworks.Net included or you can clone the repo Here . Features Multiple Customizable Channels : You can customize the channels in the transport, whether you want just 1 or 5 channels that are unreliable or reliable (best to leave channel 0 as reliable). Steam Nat Punching & Relay : The transport will use Steam to do Nat Punching to your destination, and if that doesn't work, steam's relay Server will be used to ensure you can always connect (latency may vary). No Code Changes Needed : If you Already use Mirage, you just need to slap this transport in (maybe add your steam App ID in your build), and everything should work the same like any other Mirage Transport. \"It Just Works\" -Todd Howard Credits Fizz Cube : Original author for this Transport. Chykary : The current maintainer for this Transport. rlabrecque : Creator of Steamworks.Net. vis2k : Creator of Mirror. Valve : Steam"
  },
  "Articles/Transports/Ignorance.html": {
    "href": "Articles/Transports/Ignorance.html",
    "title": "Ignorance",
    "keywords": "Ignorance What is Ignorance? Ignorance is a reliable UDP transport layer that utilizes the native ENET C Networking library via a custom fork of ENet-CSharp providing an reliable and unreliable sequenced UDP transport for both 64Bit desktop operating systems (Windows, Mac OS and Linux) and Mobile OSes (Apple iOS and Android). It also supports up to 255 channels and 4096 clients connected at one time. ENET is a solid reliable UDP C++ network library that is mature and stable. Unity's LLAPI needs a replacement. Ignorance was designed with that goal in mind - fill the gap and provide a solid, performant RUDP transport for Mirage. Why Ignorance over the Unity LLAPI? Unity's old LLAPI was horridly inefficient, and lots of testing has shown that you will get reduced performance using Unity LLAPI in your project. This is due to the design of the old networking code - Unity Tech made \"by design\" decisions and poor bug fixes that were seen to other developers as band-aids over a gaping wound. They did not care about performance or bug fixes. Unity LLAPI was also closed source, meaning the Mirage developers could not take a knife to it and make it better. This is where the concept of Ignorance took shape. Who develops Ignorance? Coburn is the lead developer of the transport. Oiran Studio actively uses this transport for networked game projects. It is currently also being utilized by some game projects, where you can find on the Mirage Discord server. Why would I want to use reliable UDP over TCP? if you have realtime communications that you need speed over reliability (VoIP...) if you need channels if you need custom channel send types if you need a data hose for your game (a first person shooter, racing game, etc) Why wouldn't I want to use reliable UDP over TCP? if you have mission critical things (as in, data NEEDS to go from A and B, no exceptions) if you need fully reliable network protocol if you're paranoid if you're making a Minecraft-like game and need to keep everyone in sync I want to know more about reliable UDP... A little explanation is required. UDP is best described as a \"shattershot\" data transmission protocol, which means you just spray and pray that packets at a destination and hope for the best. The remote destination may or may not receive those packets, nor are they going to be in order. For example, if you have a packet stream that is: 1 2 3 4 5 6 7 ...then it may end up like any of the following on the other end due to packets arriving out of order. A dot in the following example means that packet went missing. 7 6 1 3 2 4 5 7 6 . . 4 . 1 . . . . 1 2 3 1 2 3 5 4 6 7 For example, say you lost a packet and that contained a player's health update. Everyone else might know they took 69 damage, but that client will still have the old value of say, 72 health. Without reliable UDP, you can become out of sync very quickly. When you're out of sync, the game is over - everything will start operating very strangely. Sequencing and Reliable Delivery Sequencing Sequencing basically tags packets so they know what number they are when being dispatched. So if you send packets 100, 101, 102 to the remote destination, the other end will reconstruct the packet in that order rather than in a different order (like 101, 100, 102 ). If a packet is missing, it'll be skipped but the network library will take note that it's missing and compensate. Reliable mode just tells ENET to send this while waiting for the remote to acknowledge packet reception, before claiming it was 'lost'. ENET will still classify said packets as lost if it doesn't hear back from the remote, but it will retransmit them to compensate for lossy connections or high latency situations. Reliable mode tries to emulate some of TCP's resending if not acknowledged in time, but as UDP does not have all the overhead TCP protocol has, it adds some packet overhead. Ignorance comes with two channels in both Reliable and Unreliable mode by default. There are other channel modes that developers can test as different ones might suit different loads, but the average person does not need to worry about this. Ignorance comes with sane defaults out of the box. Does Ignorance support Websockets? No, it does not. Mirage comes with built-in websockets support. Where can I get Ignorance? Grab the latest build from the releases page on the Ignorance repository . Simply import the Unity Package from the release you downloaded. Where can I get support? You can get support by opening a issue ticket on the Ignorance repository issue tracker or the #ignorance channel in the Mirage Discord server. I still don't understand what this transport is, my head is spinning, help! Come by the Discord and we'll do our best to explain it in plain English."
  },
  "Articles/Transports/index.html": {
    "href": "Articles/Transports/index.html",
    "title": "Transports Overview",
    "keywords": "Transports Overview Mirage is a high level Networking Library that can use several different low level transports. To use a transport, simply add it as component to the NetworkManager and drag it into the NetworkManager's Transport field. KCP Simple, message based, MMO Scale UDP networking in C#. And no magic. WebGL - WebSockets WebSockets transport layer for Mirage that target WebGL clients, without relying on Unity's stodgy old LLAPI. Multiplexer Multiplexer is a bridging transport to allow a server to handle clients on different transports concurrently, for example desktop clients using Kcp together with WebGL clients using Websockets. UDP - Ignorance Ignorance implements a reliable and unreliable sequenced UDP transport based on ENet. UDP - LiteNetLib4Mirror LiteNetLib4Mirror implements a UDP transport based on LiteNetLib with Network Discovery and uPnP included. Steam - FizzySteamworks Transport utilising Steam P2P network, building on Steamworks.NET. Steam - FizzyFacepunch Transport utilising Steam P2P network, building on Facepunch.Steamworks."
  },
  "Articles/Transports/Kcp.html": {
    "href": "Articles/Transports/Kcp.html",
    "title": "Kcp Transport",
    "keywords": "Kcp Transport KCP is the default transport in Mirage Simple, message based, MMO Scale UDP networking in C#. Scales to 1000+ clients. Zero allocations. Portable, works in every platform except webgl DoS prevention with HashCash . Data corruption detection with CRC64 . reliable and low latency Uses very little CPU and RAM Settings Port chose the port the server will listen to Hash Cash Bits Choose how much work clients need to do to connect to your server. Higher numbers mean it takes longer to connect, which makes it harder to perform a DoS attack on your server. If it is too high, you might annoy your users. Delay Mode Chose normal for lowest bandwidth and CPU usage. Chose Fast3 for lowest latency."
  },
  "Articles/Transports/LiteNetLib4Mirror.html": {
    "href": "Articles/Transports/LiteNetLib4Mirror.html",
    "title": "LiteNetLib4Mirror Transport",
    "keywords": "LiteNetLib4Mirror Transport LiteNetLib based transport for Mirage. Usage Download the unity package from Releases and import it to your project (it does not contain Mirage) Put LiteNetLib4MirrorTransport component on gameobject with NetworkManager and assign it there (Optional) Make your NetworkManager derrive from LiteNetLib4MirrorNetworkManager and use optional overloads from it Features UDP Built-in Network Discovery and UPnP Fully managed code Small CPU and RAM usage Small packet size overhead ( 1 byte for unreliable, 3 bytes for reliable packets ) Different send mechanics Reliable with order Reliable without order Ordered but unreliable with duplication prevention Simple UDP packets without order and reliability Automatic small packets merging Automatic fragmentation of reliable packets Automatic MTU detection NTP time requests Packet loss and latency simulation IPv6 support (dual mode) Connection statisitcs (need DEBUG or STATS_ENABLED flag) Multicasting (for discovering hosts in local network) IL2CPP Warning! With IL2CPP, IPv6 is only supported on Unity 2018.3.6f1 and later because of this: Unity ChangeLog IL2CPP: Added protocol support for IPv6 on Windows. (1099133) IL2CPP: Correctly indicate that IPv6 is not supported on non-IPv6 platforms. (1108823) Also, socket Reuse Address option isn't available in IL2CPP. Credits RevenantX - for LiteNetLib vis2k & Paul - for Mirror Coburn - for Ignorance which i've used as an example Dankrushen - for helping me find one small mistake which i couldn't find for two days Lucas Ontivero - for Open.Nat , used for UPnP shiena - for NetworkDiscoveryHUD"
  },
  "Articles/Transports/Multiplexer.html": {
    "href": "Articles/Transports/Multiplexer.html",
    "title": "Multiplex Transport",
    "keywords": "Multiplex Transport The MultiplexTransport is not a transport itself, but it allows you to combine other transports so that your clients can connect to your servers via either one of them. A common use case for the MultiplexTransport is a server listening to both websockets and KCP. Your webgl clients can connect to the server using websockets and your mobile or desktop clients can connect to the same server via KCP. In HLAPI, you had to chose between websockets and UDP, but you cannot use both at the same time. You can configure any number of transports in the MultiplexTransport. To use the MultiplexTransport follow these steps: Add a gameobject with a NetworkManager to your scene if you have not done so By default, Unity will add KcpTransport to your NetworkManager game object Add a MultiplexTransport component to the gameobject Assign the MultiplexTransport component in your NetworkManager's transport Add a WebsocketTransport component to the gameobject Add the KcpTransport component to the MultiplexTransport as the first transport Add the WebsocketTransport component to the MultiplexTransport as the second transport If you build your game as a webgl game, the KcpTransport will be skipped and your client will use the websocket transport. If you build your game as a mobile or desktop app, it will choose KcpTransport. The server will happily accept connections from both. Here is what the configuration should look like:"
  },
  "Articles/Transports/WebSockets.html": {
    "href": "Articles/Transports/WebSockets.html",
    "title": "WebSockets Transport",
    "keywords": "WebSockets Transport General description of WebSockets"
  },
  "index.html": {
    "href": "index.html",
    "title": "Mirage Networking for Unity",
    "keywords": "Mirage Networking for Unity Mirage is the most compatible direct replacement for the deprecated Unity Networking API. Mirage has nearly all of the components and features from UNet, making networking easy, concise and maintainable, whether you're starting from scratch or converting an existing project. Built to support games of any scale, from LAN party games to dedicated high-volume authoritative servers running hundreds of players, Mirage is the core networking solution for Cubica , and more ! Full Source included for debugging convenience Several working examples included Active Discord for prompt support Requires Unity 2018.4 LTS and Runtime .Net 4.x (default in Unity 2019) and .Net 2.0 Compatibility is recommended Alpha / Beta Unity versions cannot be supported Key Features & Components: Transports are interchangeable components NetworkSceneManager to load normal and additive network scenes. Single and separated Unity projects supported Network Authenticators to manage access to your game Network Discovery to easily connect LAN players to a LAN Server or Host Network Manager and HUD Network Room Manager and Room Player Network Identity Network Transform to sync position, rotation, and scale with interpolation Network Animator with 64 parameters Network Proximity Checker to help with Area of Interest Network Scene Checker to isolate players and networked objects to Additive scene instances Network Match Checker to isolate players and networked objects by Network Visibility SyncVar , SyncList , SyncDictionary , and SyncHashSet List Server where game servers can register and clients can connect to find those servers to play on them."
  }
}